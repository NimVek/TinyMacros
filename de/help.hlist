/set help___036886849=<I>~getway>I<<II>type>II<mak<II>list>II<ways<II>info>II<Liefert einen kompletten Weg aus der Liste ?ways zurueck.<II>see>II<~addway, ways<II>fileinfo>II<way.tf<II><I>
/set help___1202626348=<I>hilfe_html>I<<II>type>II<comm<II>mak>II</forEach, /show_help_html<II>list>II<addh_sublist, help_keywords<II>info>II<Gibt per /echo eine HTML-Version der Onlinehilfe fuer einen Hilfeeintrag aus.<II>comm>II</help<II>var>II<%html_full, %html_file_name,<II>see>II</hilfe, /make_html_file<II>fileinfo>II<help.tf<II><I>
/set help___014102108=<I>cfg_help_build>I<<II>type>II<cfg<II>info>II<Flag, das das dynamische Aufbauen der Hilfe beim Laden von Files ein- und ausschaltet.<II>dtype>II<flag<II>fileinfo>II<help.tf<II><I>
/set help___013098110=<I>abbreviations>I<<II>type>II<list<II>info>II<Diese Liste enthaelt die definierten Abkuerzungen und deren Liste von Inhalten.<II>fileinfo>II<util.abbrev.tf<II><I>
/set help___022102095=<I>get_filename_file_info>I<<II>type>II<misc<II>info>II<wandelt den uebergebenen Dateinamen in eine Form um, die fuer die Dateiinfo Variablen (z.B. filename_version) nutzbar ist, dabei werden z.b. [.-] in Unterstriche _ umgewandelt und nur der Dateiname ohne Pfad genutzt<II>see>II<user_echo_file_info, echo_file_info, is_file_loaded<II>fileinfo>II<loading.tf<II><I>
/set help___000479445=<I>find5>I<<II>type>II<mak<II>mak>II<initfind, getshortestway, find6<II>list>II<l_k, temp_fromidx, temp_toidx<II>info>II<Enthaelt die Hauptschleife fuer das Wegesuchsystem, d.h. von den zwei Endpunkten aus werden sternfoermig die kuerzesten Wege gesucht, und bei Ueberschneidungen der beiden Netze wird der gefundene Gesamtweg benutzt.<II>var>II<portals, gmaxlen, break,<II>fileinfo>II<way.tf<II><I>
/set help___013117101=<I>purge_renamed>I<<II>type>II<comm<II>mak>II</forEach<II>info>II<Dem Makro wird ein Paketname uebergeben, woraufhin alle Makros, die in der Variablen %renamed_list_<Paketname> stehen, mittels /purge geloescht werden. Diese Funktion ist in Verbindung mit ?/rename_mac dazu gedacht, das vollstaendige Entfernen von Paketen zu erleichtern und trotzdem die Moeglichkeit zu erhalten, Makros z. B. laenderspezifische Namen zu geben. Ein Makro zum Entfernen des Paktes comm.tf koennte dann so aussehen:@{N}/def comm_remove = \@{N}@{n}    /purge -mglob comm_*%;\@{N}@{n}    /purge_renamed comm%;\@{N}@{n}    ...@{N}(Einfacher geht's natürlich mit "/remove_packet comm".)<II>syn>II</purge_renamed ways<II>ex>II<Nach@{N}/rename_mac wo ways_where ways@{N}/rename_mac gehe go ways@{N}/rename_mac keine_portale noport ways@{N}wuerde@{N}/purge_renamed ways@{N}die Makros /wo, /gehe und /keine_portale loeschen.<II>see>II</rename_mac, /remove_packet<II>fileinfo>II<util.tf<II><I>
/set help___1982313171=<I>hashlists>I<<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>
/set help___011111099=<I>sortforeach>I<<II>type>II<mak<II>info>II<Hat die gleiche Funktionalitaet wie /forEach, die Werte werden aber alphabetisch sortiert bearbeitet.<II>syn>II</sortForEach listenname k[v] /makroname<II>var>II<%value<II>see>II</forEach<II>fileinfo>II<lists.tf<II><I>gotank_back>I<<II>type>II<comm<II>info>II<Mit /gotank kann man das Tanken etwas beschleunigen. Man gibt als Parameter einfach den Zielknoten an, fuer den in der Liste 'pubs' (siehe /pub_init bzw. /settank) ein Eintrag vorhanden ist. Wenn man schon an einem Knoten steht, der eine Tanke enthaelt, kann man auch den Parameter weglassen, um sofort zu tanken. Wenn man sich vom letzten Knoten wegbewegt hat, wird das /go zum Zielknoten nur vorgeschlagen, ansonsten wird es automatisch ausgefuehrt. Durch Nutzung der Variablen %after_go (siehe /go) wird nach dem Ablaufen des Weges das Tanken ausgefuehrt. Falls fuer den Zielknoten mehr als ein Eintrag vorhanden ist, gibt es eine Auswahlliste. Und danach geht es zurueck zum Ausgangsknoten.<II>ex>II</gotank_back ziel [nach_tank_ziel|none|autmatisch akt. knoten] [auswahlnr] [(M|L)zielwert (uebertanken)]<II>fileinfo>II<uselists.tf<II><I>
/set help___011111105=<I>load_config>I<<II>type>II<mak<II>info>II<laedt die beiden Konfigurationsdateien name.def und name.cfg aus dem ueber die Parameter spezifizierten Verzeichnis<II>opt>II<siehe /custom<II>ex>II</load_config user_config<II>fileinfo>II<loading.tf<II><I>
/set help___013102104=<I>tf_not_flucht>I<<II>type>II<var<II>info>II<die Fluchtrichtung, die gesetzt wird, wenn TF die Steuerung der Vorsicht komplett uebernimmt<II>fileinfo>II<vorsicht.tf<II><I>
/set help___003647809=<I>addway>I<<II>type>II<info<II>info>II<Fuegt den als Parameter uebergebenen Weg mit Standardparametern (b all laenge) zur Wegeliste hinzu. Der Weg kann dann mit /editway editiert werden.<II>fileinfo>II<way.tf<II><I>
/set help___000479446=<I>find6>I<<II>type>II<mak<II>mak>II<iskey, disabled, allowed, testcon<II>list>II<~ bedeutet jeweils from und to l_k, temp_~idx, temp_list<II>info>II<Fuehrt die Wegesuche fuer jeden einzelnen Knoten der Start- und Zielnetze aus.<II>var>II<(~ bedeutet jeweils from und to) ~len, ~node, ~way, ~maxlen, len, node, way, maxlen<II>fileinfo>II<way.tf<II><I>
/set help___025121110=<I>cfg_way_go_show_condition>I<<II>type>II<cfg<II>info>II<Zeigt vor der Wegberechnung, die aktuell gueltigen Bedingungen, wie Portale, Gilde, Dimension, Spielerstatus usw<II>dtype>II<flag<II>fileinfo>II<way.tf<II><I>
/set help___022117095=<I>status_config_set_attr>I<<II>type>II<mak<II>info>II<Gibt einen TF-Ausdruck zurueck, der die uebergebene Variable mit dem Operator mit den Vergleichswerten vergleicht und die korrekten Statuskonfigurationsvariablen als Ergebniswerte einsetzt (abhaengig vom ersten Parameter), ausserdem werden die Konfigurationsvariablen gleich auf die uebergebenen Werte gesetzt. @{N}Dabei erhalten die Konfigurationsvariablen jeweils den angegebenen Suffix.<II>syn>II</status_config_set_attr [c|t] varname operator ['".] vergleichswert1 ConfigSuffix1 Configwert1 vergleichswert2 ConfigSuffix2 Configwert2 ... [[ConfigSuffixDefault] DefaultConfigWert]<II>ex>II</status_config_set_attr c p_lp < . 60 THIRD Cred 120 TWOTHIRD Cyellow FULL Cgreen@{N}/status_config_set_attr t p_align =~ ' gut + neutral * boese -<II>see>II<status_config_attr<II>fileinfo>II<status.tf<II><I>
/set help___2127468084=<I>save_most>I<<II>type>II<mak<II>list>II<most<II>info>II<Wenn die Most-Liste geaendert wurde, wird bei /quit dieses Makro aufgerufen, mit dem sie sortiert und abgespeichert wird.<II>see>II<most, /sort_most<II>fileinfo>II<untroom.tf<II><I>
/set help___000007864=<I>map>I<<II>type>II<comm<II>info>II<schickt den uebergebenen Text als Kommando an den Mapper<II>var>II<mapper<II>fileinfo>II<mapper.tf<II><I>
/set help___033737315=<I>returns>I<<II>type>II<mak<II>info>II<Gibt alle uebergebenen Parameter als String zurueck der diese ueber ein /test %? als lokale Variablen R1 .. Rn setzt<II>syn>II</return returns(expr1,...,exprN)<II>ex>II</let a=5%;/let c=3%;/return returns(a,10,c*30)@{N}dann /test %?%;/echo %R1 %R2 %R3 -> 5 10 90<II>fileinfo>II<util.tf<II><I>
/set help___003968886=<I>is_win>I<<II>type>II<mak<II>info>II<Liefert True wenn OS irgendwie 'win' enthaelt<II>fileinfo>II<util.tf<II><I>
/set help___259246715=<I>loadways>I<<II>type>II<mak<II>info>II<Laedt die Wegelisten neu, besonders vor Aenderungen wegen der Konsistenz zu empfehlen.<II>fileinfo>II<way.tf<II><I>
/set help___033867276=<I>saveall>I<<II>type>II<comm<II>list>II<${world_character}tosave<II>changes>II<Wird nun in ${world_host}/${world_character} gespeichert.<II>info>II<Speichert alle in der Liste angegebenen Variablenwerte in ${world_character}saved.list im Verzeichnis ${world_host}/${world_character} bzw. speichert die angegebenen Listen in ihre entsprechenden Dateien.<II>see>II</addsave, /loadsaved<II>fileinfo>II<worldconnect.tf<II><I>
/set help___013104115=<I>showshortlist>I<<II>type>II<comm<II>mak>II</foreEach<II>info>II<Zeigt die Liste an, so dass Wert aus Sublisten durch Komata getrennt werden und nicht jeweils auf einer Zeile stehen.<II>syn>II</showshortlist listenname<II>fileinfo>II<lists.tf<II><I>
/set help___017116105=<I>watch_action_list>I<<II>type>II<list<II>info>II<Falls bei Aenderung einer Variablen ein Makro aufgerufen werden soll, steht das Paar Variablenname/Makro in dieser Liste.<II>see>II</watch_var, /watch_loop, /watch_check_var, watch_list<II>fileinfo>II<util.debug.tf<II><I>
/set help___017103116=<I>cfg_connect_title>I<<II>type>II<cfg<II>info>II<Konfiguration Fenstertitel<II>update>II</eval /xtitle %CFG_CONNECT_TITLE<II>fileinfo>II<worldconnect.tf<II><I>
/set help___003817029=<I>enable>I<<II>type>II<comm<II>list>II<disabled<II>info>II<Damit werden temporaer gesperrte Wegstuecke wieder freigegeben.<II>syn>II</enable Anfangsknoten Endknoten<II>see>II<disable, go, disabled, sperren<II>fileinfo>II<way.tf<II><I>
/set help___011108104=<I>clear_cache>I<<II>type>II<mak<II>info>II<Loescht den Cache mit den Wegen.<II>see>II<cache, remove_from_cache, show_cache<II>fileinfo>II<way.tf<II><I>
/set help___016097111=<I>status_get_quote>I<<II>type>II<mak<II>info>II<liefert wenn ein TF-Quote Zeichen uebergeben wurde dieses zurueck, sonst einen Leerstring<II>fileinfo>II<status.tf<II><I>
/set help___351116102=<I>infodefiniert eine variable fuer die statuszeile sofort (on the fly). die informationen zur darstellung werden aus den konfigurationsvariablen fuer farbe und text geholt (cfg_status_color_varname*, cfg_status_text_varname*)@{n}wenn statt des defaultwerts der variablenname noch einmal angegeben wird, wird die variable per selbstzuweisung aktualisiert>I<<II>type>II<misc<II>fileinfo>II<status.tf<II><I>
/set help___2127465563=<I>save_room>I<<II>type>II<var<II>info>II<Speichert, ob nach Beenden des Untersuchens der aktuelle Raum gespeichert werden soll.<II>fileinfo>II<untroom.tf<II><I>
/set help___031095355=<I>go_way3>I<<II>type>II<mak<II>mak>II<bug_way, def_psave_trig, def_psave3_trig<II>info>II<Fuehrt den angegebenen Weg aus. Dabei werden die integrierten Sonderbefehle bzw. die eigenen Makros entsprechend beruecksichtigt. Beim Wegablaufen mit Ueberpruefung wird auf die Fehlerausgaben des Muds (?mud_blocking_output) getriggert. Wenn Prefixmakros innerhalb der Wege angegeben sind, werden sie vor jedem Mud-Befehl ausgefuehrt.<II>var>II<fulldetail, way_Trig, last_comm, nextmakro, mud_blocking_output<II>fileinfo>II<way.tf<II><I>
/set help___034256038=<I>testcon>I<<II>type>II<mak<II>mak>II<killlongerways<II>list>II<~l_k<II>info>II<Testet, ob sich Hinweg und Rueckweg schon treffen.<II>var>II<min_steps, gmaxlen, min_way, (~ bedeutet jeweils from bzw. to) ~slen, ~maxlen<II>fileinfo>II<way.tf<II><I>
/set help___025116101=<I>default -c mudverzeichnis>I<<II>type>II<misc<II>info>II<Speicherort siehe /hilfe custom (z.B. -c Mudverzeichnis, -c -p Mud/Spieler, garnix im TinyMacros Verzeichnis usw.)<II>fileinfo>II<keys.tf<II><I>
/set help___2065225194=<I>mapauthor>I<<II>type>II<mak<II>mak>II<restricttoexit,<II>info>II<das Makro parst den Autor, die als Ergebnis von /mapinfo erhalten wird<II>req>II<way.tf<II>var>II<mapper<II>fileinfo>II<mapper.tf<II><I>
/set help___234325440=<I>aforeach>I<<II>type>II<comm<II>func>II<astart, alen, aget<II>info>II<Wie /forEach bzw. /hforEach fuer Listen arbeitet /aforEach alle Elemente eines Feldes durch, indem sie als Parameter fuer das uebergebene Makro genutzt werden.<II>syn>II</aforEach feldname /makroname<II>ex>II</aforEach baeume /ernte<II>see>II</aforEach2, /asortforEach<II>fileinfo>II<lists.tf<II><I>
/set help___012101101=<I>removehashed>I<<II>type>II<comm<II>mak>II</tokenize<II>info>II<Wandelt eine ?Hashliste wieder in eine normale Liste mit dem gleichen Namenum. Das kann ggf. dauern. ;)<II>syn>II</removehashed listenname<II>var>II<%value<II>see>II<Hashliste<II>fileinfo>II<lists.tf<II><I>
/set help___012101102=<I>team_angriff>I<<II>type>II<comm<II>info>II<Startet den Team Angriff in n Sekunden, ohne Parameter sofort. Nur ausfuehrbar fuer den Teamleiter. Mit /team_angriff, waehrend es laeuft, wird es wieder abgebrochen.@{N}Per Default ist @{B}/ta@{x} als Kuerzel dafuer definiert, falls nicht schon ein Makro mit diesem Namen existiert.<II>syn>II</team_angriff [n]<II>ex>II</team_angriff 10<II>fileinfo>II<team.tf<II><I>
/set help___016101105=<I>create_help_file>I<<II>type>II<mak<II>info>II<Erzeugt fuer das angegebene File die Hilfeeintraege.<II>see>II</create_help<II>fileinfo>II<help.tf<II><I>
/set help___000509740=<I>mload>I<<II>type>II<comm<II>mak>II<hook_reload, add_to_hook, eval_hook<II>changes>II</custom wurde ausgegliedert.<II>info>II<Laedt ein Makrofile. Dabei kann die Endung '.tf' oder '.mak' weggelassen werden.@{N}Die geladenen Dateien werden im Hookmakro reload zum Neuladen gespeichert.Mit '/mload -c' werden die Dateien aus dem Verzeichnis ${world_host} geladen.@{N}Es wird der Hook loaded ausgefuehrt, der nach dem Laden eines Files mit dem Dateinamen (1), mit vollem Pfad(2) und mit den Ladeparametern(-2) ausgefuehrt wird. (z.B. /eval_hook loaded kampf.tf mg.mud.de/kampf/kampf.tf -c -dkampf)@{N}Wenn ein Makro dateiname_tf_init definiert ist, wird dieses nach dem Laden ausgefuehrt (load_init_config) um ggf. eine Initialisierung nach dem Fileladen zu ermoeglichen.<II>version>II<1.02<II>opt>II<-m bedeutet multiple Files der Filename ist dann ein Pattern z.B. *.tf, es wird pro File ein /mload aufgerufen@{N}/addh syn /mload [-q] [-p[directory]] [-c[directory]] -mfile[.tf|.mak]<II>hook>II<loaded, reload<II>see>II<re, purge, load, load_init_config, custom<II>fileinfo>II<loading.tf<II><I>
/set help___012116101=<I>attr_ordered>I<<II>type>II<mak<II>info>II<Erzeugt einen Ausdruck, der den ersten Parameter (Varname) mit den jeweils folgenden vergleicht und die angegebenen Attribute zurueckgibt.<II>syn>II</attr_ordered varname vglwert1 attr1 vglwert2 attr2 .. default_attr<II>ex>II</attr_ordered lp 80 Cred 160 Cyellow Cgreen<II>fileinfo>II<status.tf<II><I>
/set help___012103111=<I>hgetdvalueof>I<<II>type>II<comm<II>func>II<hash<II>mak>II</getdvalueof<II>info>II<Liefert den ersten Wert, der mit dem angegebenen Schluessel in der ?Hashliste eingetragen ist, und loescht diesen Eintrag. Gut zum Durcharbeiten der Liste geeignet.@{N}Rueckgabe in %value und als return-Wert.<II>syn>II</hgetdvalueof listenname schluessel<II>var>II<%value<II>see>II</getdvalueof, /hgetvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___012101104=<I>testvorsicht>I<<II>type>II<mak<II>info>II<Makro, das beim Anspringen der Vorsicht im Mud ausgefuehrt wird. Es testet, ob man grad im Kampf ist (%kampf>0) und ob die aktuellen LP kleiner als die gesetzte Vorsicht sind (%p_lp<=%p_whimpie). Dann wird der Kampfmodus deaktiviert (%kampf=-1) und die Vorsicht im Mud fuer 10 Sekunden auf 0 gesetzt, damit man dem PingPong-Effekt aus dem Weg geht. Anschliessend wird die in %p_escape_tf gespeicherte Fluchtrichtung ausgefuehrt, da die in %p_escape gespeicherte Flucht schon vom Mud ausgefuehrt wurde. (Alles von TF machen zu lassen kann bei LAG toedlich sein.)<II>fileinfo>II<vorsicht.tf<II><I>
/set help___2016265403=<I>appendnode>I<<II>type>II<comm<II>mak>II<getnode, getali<II>info>II<Fuegt eine @{B}zusaetzliche@{n} Knotenbeschreibung fuer den aktuellen Raum zur Liste hinzu. Wenn der zusaetzliche Parameter Zeilenzahl angegeben wird, wird nur die gewuenschte Anzahl Zeilen gespeichert. Ansonsten wird die Variabel ?addlines beachtet. Wenn die Zeilenzahl 0 ist, wird die komplette Raumbeschreibung bis zu den Ausgaengen gespeichert.<II>syn>II</appendnode [knoten [zeilenzahl]]<II>var>II<lastpoint, addlines<II>see>II<knoten, addnode, delnode<II>fileinfo>II<way.tf<II><I>
/set help___016116099=<I>attr_ordered_cmp>I<<II>type>II<mak<II>info>II<Liefert einen Vergleichsausdruck für die Variable (%1), mit dem Operator (%2). Dabei kann angegeben werden, ob die Vergleichswerte Strings sind (%3 ist " oder ') und ob die Ergebnisswerte Strings oder Variablennamen sind (%4 ist ' oder " bei String), in %5+2*i stehen die Vergleichswerte, und in %6+2*i die Ergebniswerte<II>syn>II</attr_ordered_cmp varname operator ['".] ['".] compare1 result1 compare2 result2 ... [result_default]<II>ex>II</attr_ordered_cmp hp < . . maxhp/3 COLOR_HP_33 maxhp*2/3 COLOR_HP_66 COLOR_HP<II>fileinfo>II<status.tf<II><I>
/set help___034816933=<I>untroom>I<<II>type>II<comm<II>info>II<Mit diesem Befehl wird das Untersuchen eines Raumes (neu) gestartet. Die vorhandenen Listen werden resettet. Es beginnt mit '%mud_look_command'.<II>syn>II</untroom<II>see>II<%mud_look_command<II>fileinfo>II<untroom.tf<II><I>
/set help___000000930=<I>n2>I<<II>type>II<comm<II>info>II<Wiederholt den als Restparameter uebergebenen String sooft, wie er den Parameter 1 halbieren kann. Dabei ist es egal, ob es sich um Mud- oder tf-Kommandos handelt. Der Zaehler von /n2  (Variable n2) kann auch im Code genutz werden.<II>ex>II<z.B. soviele Muenzen wie moeglich tragen ;) @{N}/n2 100000 nimm %n2 muenzen (oder besser /n 100000 nm %n2)<II>fileinfo>II<util.repeat.tf<II><I>
/set help___003855369=<I>getali>I<<II>type>II<mak<II>info>II<Liefert das Alias zum Knoten; wenn keins vorhanden ist, dann den Knotennamen selbst.<II>fileinfo>II<way.tf<II><I>
/set help___020102097=<I>config_status_static>I<<II>type>II<mak<II>info>II<Parst und verarbeitet die statischen Elemente der Statuszeile wie _ und feste Strings.<II>syn>II</config_status_static String mit nur statischen Elementen<II>return>II<verabeiteter String<II>ex>II</config_status_static __MP:___LP:__!!!____abc__@{N}return: :2 "MP:" :3 "LP:" :2 "!!!" :4 "abc" :2<II>see>II<config_status<II>fileinfo>II<status.tf<II><I>
/set help___013110104=<I>init_col_echo>I<<II>type>II<mak<II>info>II<Initialisiert die Ausgabebreite und die Spaltenbreite fuer die naechsten /col_echo.<II>syn>II</init_col_echo width col_width<II>ex>II</init_col_echo 80 15<II>fileinfo>II<util.echo.tf<II><I>
/set help___273427820=<I>team_pad>I<<II>type>II<func<II>info>II<Gibt fuer das angegebene Attribut die fuer pad() noetige Zahl zurueck, um eine formatierte Ausgabe zu erreichen.<II>syn>II</team_pad Attribut<II>ex>II</expr team_pad("mlp") -> 003@{N}/expr team_pad("fl")  -> -21<II>fileinfo>II<team.tf<II><I>
/set help___012097115=<I>tasten_slist>I<<II>type>II<var<II>list>II<tasten<II>info>II<wenn diese Variable auf 1 gesetzt ist, wird die Liste bei jeder Aenderung gespeichert.<II>fileinfo>II<keys.tf<II><I>
/set help___011101101=<I>getidxofkey>I<<II>type>II<func<II>func>II<count_entries, isVar<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>info>II<Liefert den Index eines Schluessels innerhalb einer Liste. Die Zaehlung beginnt bei 0. Das Ergebnis wird zurueckgegeben und in %value gespeichert. Ist der Schluessel nicht in der Liste, so ist das Ergebnis %error. Ist der Schluessel mehrmals in der Liste, wird der kleinste passende Index zurueckgegeben.@{N}/addh syn /getidxofkey liste|listenname schluessel<II>return>II<Index oder %error als Rueckgabewert und in %value.<II>ex>II<Sowohl@{N}@{}  /test index:=getidxofvalue("skills_list","50%")@{N}als auch@{N}@{}  /test index:=getidxofvalue(skills_list,"50%")@{N}liefern den gleichen Wert.<II>var>II<%value<II>see>II</getidxofvalue<II>fileinfo>II<lists.tf<II><I>getfirstkey>I<<II>type>II<func<II>info>II<Liefert den ersten Schluessel der Liste zurueck.<II>syn>II</getfirstkey listenname<II>return>II<erster Schluessel der Liste oder %error bei Misserfolg Rueckgabewert und in %value<II>var>II<%value<II>fileinfo>II<lists.tf<II><I>detail_idee>I<<II>type>II<comm<II>info>II<Fuegt das letzte nicht vorhandene Detail in eine Liste ein, die dann nach dem Untersuchen des Raumes mit /send_idee abgeschickt wird.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>var>II<%ideas<II>see>II</send_idee, herkunftsanzeige<II>fileinfo>II<untroom.tf<II><I>
/set help___011101102=<I>delnodeinfo>I<<II>type>II<comm<II>info>II<Loescht Zusatzinformationen ueber einen Knoten, wenn keiner angegeben wird, werden die Infos zum aktuellen Knoten geloescht<II>syn>II</delnodeinfo [knoten]<II>fileinfo>II<way.tf<II><I>team_tab_fl>I<<II>type>II<comm<II>info>II<Der Teamleiter kann mit diesem Befehl Angriffsbefehl und Fluchtrichtung fuer die Teammitglieder setzen. Dazu muessen die einzelnen Mitglieder dies mit ?/team_allow erlauben. Eigener Angriffsbefehl und Fluchtrichtung werden in jedem Fall gesetzt.@{N}Angriffsbefehl oder Fluchtrichtung koennen auch weggelassen werden (das '&' allerdings nicht), um keine Aenderung vorzunehmen. Eine Loeschung von Angriffsbefehl oder Fluchtrichtung kann mit '-' erreicht werden.<II>syn>II</team_tab_fl Angriffsbefehl & Fluchtrichtung<II>ex>II</team_tab_fl betrete portal & oeffne tuer@{N}/team_tab_fl -&renne ganz schnell raus<II>fileinfo>II<team.tf<II><I>
/set help___000487573=<I>hilfe>I<<II>type>II<comm<II>list>II<helpindex, help, addh_sublist<II>info>II<Falls vorhanden, zeigt es den Hilfetext fuer den angegebenen Parameter an. Mit einem vorangestellten '+' wird eine ausfuehrliche Hilfe angezeigt. Ansonsten gibt es den Parameter an das tf-Hilfesystem weiter.<II>syn>II</hilfe [+][/]eintrag<II>ex>II</hilfe /addh, /hilfe +mload, /hilfe +%tf_html, /hilfe + /iskey<II>var>II<%addh_sublist<II>see>II</addh, /defh<II>fileinfo>II<help.tf<II><I>
/set help___018108110=<I>util.completion.tf>I<<II>type>II<fileinfo<II>info>II<Erweiterte Vervollstaendigung (Completion)<II>req>II<util.trigger.tf<II>comm>II<completion<II>version>II<util.completion.tf,v 1.6 2001/11/27 21:33:49 mh14 (Mesirii@mg.mud.de)<II>var>II<completion_recall_count<II>fileinfo>II<util.completion.tf<II><I>
/set help___012097116=<I>savealllists>I<<II>type>II<comm<II>mak>II</createlist, /foreach<II>list>II<lists<II>info>II<Speichert die veraenderten Listen ab.<II>syn>II</savealllists<II>var>II<%tlists, %hlists2<II>see>II</savelist, /loadlist, /addlisttosave<II>fileinfo>II<lists.tf<II><I>
/set help___000000935=<I>go>I<<II>type>II<comm<II>changes>II<1.04 Fehlermeldung, wenn Teilknoten des Weges keine Ausgaenge hat, andere Fehlermeldungen praezisiert.@{N}1.05 der Inhalt der Variablen %after_go wird nach komplettem Ablaufen des Weges ausgefuehrt.<II>info>II<Ist der wichtigste Befehl des Wegeprogramms.@{N}Syntax: /go [knoten1 knoten2 ...] endknoten@{N}Es wird ein Weg ueber die angegebenen Knoten zum Endknoten berechnet. Der Weg wird angezeigt und dann geht es los. ;)@{N}Da der Weg, der vom letzten bekannten Knoten aus gegangen wurde, mitgeloggt wurde, wird zuerst zu dem letzten bekannten Knoten gegangen, danach wird der berechnete Weg zum Zielknoten gegangen.@{N}Dabei gibt es folgende Besonderheiten: Fehler treten auf, wenn auf dem Weg zum letzten bekannten Knoten Wegebefehle auftreten, die keine Richtungs- befehle sind oder wenn der Rueckweg zum Knoten anders verlaeuft als der Hinweg.@{N}Fehler (Zyklus) werden gemeldet, wenn der Startknoten im Laufe des (erzwungenen) Weges wieder passiert wird.@{N}Waehrend des Weges kann allerlei passieren:@{N}Fall kein bekannter Startpunkt vorhanden ist, wird das gemeldet.@{N}Wenn ein Hindernis im Weg steht und das im Weg vorgesehen ist, wird man gefragt, ob man den Weg temporaer sperren will. Wenn ja, wird dies getan, und man kann mit /continue oder /c zum letzten Knotenpunkt zuruecklaufen Wenn nein, muss man das Hindernis beseitigen und kann dann mit /continue weiterlaufen bis zum Ziel.@{N}Wenn ein NPC vorgesehen ist, den man sowieso weghaut, gibt es die erste Variante nicht. Man bekommt aber eine schoene Meldung ;).@{N}Ausserdem koennen im Weg beliebige Makros enthalten sein, die dann alles moegliche machen. Zu diesen Sachen steht viel mehr unter Wegeingabe.@{N}Schon gegangene Wege werden in einer Liste temporaer zwischengespeichert, damit es beim zweiten Mal schneller geht. Wenn man einen Weg dauerhaft speichern will, so sollte man /ao benutzen.<II>see>II</gof, %after_go<II>fileinfo>II<way.tf<II><I>
/set help___004126110=<I>myconn>I<<II>type>II<hook<II>mak>II<saveall, loadsaved<II>info>II<Beim Connect wird einmalig die Datei ${world_host}/${world_character} geladen.Ausserdem werden die mittels /saveall abgespeicherten Variablen mit /loadsaved wieder geladen.<II>hook>II<CONNECT<II>fileinfo>II<worldconnect.tf<II><I>
/set help___668270365=<I>make_hrefs>I<<II>type>II<mak<II>list>II</help_keywords, /help<II>info>II<Scannt uebergebene Strings nach potentiellen Links und erzeugt diese, Parameteruebergabe in %value.<II>return>II<in %value der modifizierte String<II>comm>II<help<II>var>II<%html_file_name, %html_eval_list, %value<II>fileinfo>II<help.tf<II><I>
/set help___003818650=<I>felder>I<<II>type>II<misc<II>info>II<Die Felder sind einfach eine Abbildung auf TF-Variablen, in denen dann die Inhalte stehen. Dabei wird der Variablenname wie folgt zusammengesetzt: 'array_feldname___index'. Die hoechsten und niedrigsten Indizes stehen in 'array_feldname___maxlen' und '*___minlen', werden aber auch von /alen und /astart geliefert.<II>see>II</aget, /aput, /ashow, /asshow, /asort, /amsort, /aforEach, alen, astart, /aclear<II>fileinfo>II<lists.tf<II><I>
/set help___011103111=<I>hgetvalueof>I<<II>type>II<comm<II>func>II<hash<II>info>II<Wie /getvalueof fuer normale Listen liefert es den zum angegebenen Schluessel gehoerenden Wert bei ?Hashlisten. Falls der Schluessel nicht existiert, wird %error zurueckgegeben.<II>syn>II</hgetvalueof listenname schluessel<II>return>II<zugehoeriger Wert als Rueckgabewert und in %value<II>var>II<%value, %hvalue<II>see>II</getvalueof, Hashliste, /getkeyofvalue<II>fileinfo>II<lists.tf<II><I>
/set help___000001055=<I>uw>I<<II>type>II<misc<II>info>II<Untersucht die Wand.<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___016118119=<I>move_to_window_r>I<<II>type>II<comm<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Regexp-Trigger geschrieben, aber wird nicht mehr im normalen Fenster angezeigt.<II>ex>II</move_to_window_r Tod \\[Tod:.*<II>fileinfo>II<util.windows.tf<II><I>move_to_window_g>I<<II>type>II<comm<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Global-Trigger geschrieben, aber wird nicht mehr im normalen Fenster angezeigt.<II>ex>II</move_to_window_g Tod *[Tod:*<II>fileinfo>II<util.windows.tf<II><I>
/set help___033988346=<I>set_var>I<<II>type>II<mak<II>info>II<Setzt die Variable auf den angegeben Wert, falls sie noch nicht gesetzt war<II>syn>II</set_var varname value<II>ex>II</set_var a bac<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___012097118=<I>watch_active>I<<II>type>II<var<II>info>II<Dieses Flag regelt, ob eine Variablenueberwachung stattfindet.<II>see>II</watch_loop, /watch_var<II>fileinfo>II<util.debug.tf<II><I>
/set help___011101099=<I>repeat_once>I<<II>type>II<mak<II>info>II<Schaut nach, ob es den als 2. Paramter uebergebenen Prozess bereits gibt. Ist dies nicht der Fall wird er nach Paramter 1 Sekunden ausgefuehrt. Rueckgabewert ist die pid des repeats oder 0 falls es den Prozess schon gibt.<II>syn>II</repeat_once time makro<II>ex>II</repeat_once 5 /purge -mglob mytrigger_*<II>see>II<repeat<II>fileinfo>II<util.repeat.tf<II><I>
/set help___023101095=<I>completion_recall_count>I<<II>type>II<var<II>info>II<Anzahl der Zeilen im Recall, die die ?completion zurueckgehen soll (Default 200).<II>see>II<completion<II>fileinfo>II<util.completion.tf<II><I>
/set help___000460952=<I>ancmp>I<<II>type>II<func<II>info>II<Vergleichsfunktion auf numerischer Basis. Liefert einen Wert < 0, wenn der Feldwert an 'index1' kleiner ist als an 'index2'. Bei Gleichheit wird 0 zurueckgegeben, ansonste ein positiver Wert.<II>syn>II</ancmp feldname index1 index2<II>return>II<in %value und als Rueckgabewert<II>var>II<%value<II>see>II<asicmp, ascmp<II>fileinfo>II<lists.tf<II><I>
/set help___1905762017=<I>check_info>I<<II>type>II<comm<II>info>II<Aktualisiert die Spielereigenschaften (info)<II>fileinfo>II<mg_properties.tf<II><I>
/set help___019095110=<I>cfg_map_ignore_npcs>I<<II>type>II<cfg<II>info>II<Liste von NPC-Namen, die nicht an den Mapper geschickt werden sollen, wenn sie sich im Raum befinden<II>fileinfo>II<mapper.tf<II><I>
/set help___011097114=<I>mapper_port>I<<II>type>II<cfg<II>info>II<Port auf dem der Mapper laeuft (default 2000)<II>fileinfo>II<mapper.tf<II><I>
/set help___024097116=<I>def_catch_tf_prompt_trig>I<<II>type>II<trig<II>info>II<Faengt den Text von der aktuellen Zeile bis zum Auftreten des TF-Prompts ab, das mit dem uebergebenen Text oder default mit def_catch_tf_prompt_trig ausgefuehrt wird. Der gegrabbte Text steht in der Variablen fulldetail<II>syn>II</def_catch_tf_prompt_trig [endtext [tf-code]]<II>ex>II</set nextmakro=/echo \%fulldetail%; /def_catch_tf_prompt_trig%;@{N}oder@{N}/set nextmakro=/echo \%fulldetail%;/def_catch_tf_prompt_trig EndText%;@{N}oder@{N}/def_catch_tf_prompt_trig EndText /echo \%fulldetail%;@{N}oder@{N}/test def_catch_tf_prompt_trig("EndText","/echo \%fulldetail")<II>fileinfo>II<util.trigger.tf<II><I>
/set help___692512332=<I>watch_list>I<<II>type>II<list<II>info>II<Diese Liste enthaelt die Namen der zu ueberwachenden Variablen als Key und ihre Inhalte als Value. Sie wird mittels /watch_loop und /watch_check_var aktualisiert.<II>see>II</watch_var, /watch_loop, /watch_check_var, watch_action_list<II>fileinfo>II<util.debug.tf<II><I>
/set help___015100105=<I>add_deklination>I<<II>type>II<comm<II>list>II<deklinations<II>info>II<Erweitert die Liste der bekannten Deklinationen. Falls waehrend des untersuchens eins dieser deklinierten Worte auftaucht, wird automatisch sein Nominativ untersucht.@{N}Eine Aenderung der Liste wird erst beim naechsten /untroom wirksam.<II>syn>II</add_deklination <dekliniertes Wort> <Nominativ><II>ex>II</add_deklination waenden waende<II>fileinfo>II<untroom.tf<II><I>
/set help___011097115=<I>xaddbtolist>I<<II>type>II<comm<II>mak>II</paramparse<II>info>II<Fuegt einen Schluessel, in dem auch Leerzeichen enthalten sein koennen, und einen Wert, die durch ein kaufmaennisches UND ('&') getrennt sind, an den Anfang einer Liste ein. Schluessel oder Wert duerfen allerdings nicht mit einem Leerzeichen enden.<II>syn>II</xaddbtolist listenname&schluessel&wert<II>ex>II</xaddbtolist fruechte&reife Aepfel&10 Stueck<II>see>II</addbtolist, /xaddtolist, /xuaddtolist<II>fileinfo>II<lists.tf<II><I>mapper_host>I<<II>type>II<cfg<II>info>II<Host auf dem der Mapper laeuft (default localhost)<II>fileinfo>II<mapper.tf<II><I>
/set help___011101108=<I>test_result>I<<II>type>II<mak<II>info>II<Wertet das Ergebnis eines Unit Test Bestandteils aus. Dazu wird als Parameter die Testbedingung uebergeben. Die Variablen param und res muessen im Test benutzt werden, und sind hier als lokale Variablen verfuegbar<II>syn>II</test_result Bedingung<II>ex>II</test_result<II>var>II<res, param<II>fileinfo>II<util.debug.tf<II><I>
/set help___238182716=<I>cfg_init>I<<II>type>II<mak<II>info>II<Die ueber die Config-Hierarchie-Namen bestimmte Variable wird auf den Wert des letzten Parameters gesetzt.<II>syn>II</cfg_init Config-Hierarchie-Namen Wert<II>return>II<Variablenname<II>ex>II</cfg_init USE LOADING 1<II>fileinfo>II<config.tf<II><I>
/set help___000068092=<I>wait>I<<II>type>II<mak<II>mak>II<cont_way<II>info>II<Wartet die angegebene Zahl Sekunden, bis der Weg weiter ausgefuehrt wird, und fuehrt ggf. das angegebenen Kommando aus. /wait kann benutzt werden, um im Zusammenhang mit /cond_go vor jedem Wegschritt eine Pause einzulegen (/cond_go /wait sekunden).<II>syn>II</wait sekunden [kommando]<II>see>II<cond_go, no_cond_go<II>fileinfo>II<way.tf<II><I>
/set help___279447712=<I>wayindex>I<<II>type>II<comm<II>mak>II<sort_idx_list, savelist, alle moeglichen Listenbefehle<II>list>II<fromidx, toidx<II>info>II<Nach manuellen Arbeiten an der Liste ways MUSS /wayindex aufgerufen werden, damit die Indexlisten neu erstellt werden!<II>var>II<temp_list, temp_list2<II>see>II<wege, ways<II>fileinfo>II<way.tf<II><I>
/set help___011097117=<I>catch_ouput>I<<II>type>II<mak<II>info>II<Definiert den Abbruchtrigger (bzw. -hook), der fuer /def_catch_output_trig gilt. Als Paramter kann angegeben werden, wieviele Prompts (Default-Prompt '>') gewartet werden soll (Standard 1). Das Ergebnis des Grabbens wird in der Variablen %fulldetail gespeichert. Es wird anschliessend das in %nextmakro stehende Makro ausgefuehrt, das eine Weiterverarbeitung vornehmen kann.<II>syn>II</catch_output [Anzahl der zu wartenden Prompts == Anzahl der Kommandos]<II>ex>II</set nextmakro=/do_next%;@{N}/set fulldetail=%;@{N}/def_catch_output_trig%;@{N}/catch_output 2%;@{N}unt decke%;unt boden%;<II>hook>II<psave2<II>var>II<fulldetail, nextmakro<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, /def_catch_2regexp_trig, /catch_output, /def_catch_prefix_trig, /def_catch_regexp_trig, /def_catch_output_trig, (alte Namen: /def_psave_trig, /def_psave3_trig)<II>fileinfo>II<util.trigger.tf<II><I>
/set help___020032111=<I>ret /custom-optionen>I<<II>type>II<misc<II>info>II<Liefert die /custom-Optionen, wo ein Savefile fuer die angegebene Config-Variable zu finden ist.<II>syn>II</cfg_get_dest cfg-hierarchie-name<II>fileinfo>II<config.tf<II><I>
/set help___000464324=<I>asort>I<<II>type>II<comm<II>mak>II</aswap<II>info>II<Quick-Sort-Implementation fuer die Felder. Es werden das zu sortierende Feld, minIndex und maxIndex sowie der Name der Vergleichsfunktion uebergeben. Ausserdem ist es moeglich, ein Feld anzugeben, das in der selben Weise wie das Sortierfeld mitgetauscht wird. Als Vergleichsfunktionen kommen in erster Linie ascmp, asicmp (Default) und ancmp in Frage.<II>syn>II</asort feldname von bis [vergleichsfunktion] [zweitfeld]<II>ex>II</asort baeume 4 10 ascmp obst<II>see>II</amsort, asicmp, ascmp, ancmp<II>fileinfo>II<lists.tf<II><I>
/set help___049115097=<I>eh syn /sreplace (old|\space) (new|\space) string>I<<II>type>II<misc<II>info>II<Ersetzt Parameter1 durch Parameter2 im String, der als restlicher Parameter angegeben ist. Das Ergebnis wird mit /result zurueckgegeben, also ueber $() holen. Dabei koennen Parameter1 bzw. Parameter2 auch \space fuer Leerzeichen sein.<II>syn>II</sreplace (suchtext|\space) (ersetztext|\space) string<II>return>II<ueber /result den veraenderten String<II>ex>II</sreplace beutel paket oeffne beutel@{N}wuerde "oeffne paket" zurueckgeben.<II>fileinfo>II<<II>fileinfo>II<lists.tf<II><I>
/set help___274814162=<I>time2str>I<<II>type>II<mak<II>info>II<Gibt einen String aus, der die uebergebene Zeit minutengenau im Klartext enthaelt. Soll die Zeit sekundengenau ausgegeben werden muss sek_flag gesetzt werden.<II>syn>II</time2str zeit [sek_flag]<II>ex>II</time2str 1000000 1<II>fileinfo>II<util.conv.tf<II><I>
/set help___030039802=<I>dep_var>I<<II>type>II<mak<II>info>II<Erzeugt eine Liste abhaengiger Variablen von der angegebenen Variablen X, diese werden beim Setzen dieser Variablen X per /dset mit aktualisiert (per Selbstzuweisung, so dass sie z.B. in der Statuszeile aktualisiert werden).@{N}Mit nur einem Parameter werden die abhaengigen Variablen angezeigt<II>syn>II</dep_var varname [depending_var]<II>ex>II</dep_var a b@{N}/dep_var a (Zeigt Liste an)<II>see>II</undep_var, /dset<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___013109115=<I>umerge_lists2>I<<II>type>II<mak<II>mak>II</forEach, /uaddtolist<II>info>II<Kopiert in Inhalt der ersten in die zweite Liste, wobei je nach drittem Parameter (kv) Schluessel und/oder Werte kopiert werden. Dabei werden schon vorhandene Schluessel ueberschrieben.@{N}Die Schluessel der ersten Liste duerfen keine Leerzeichen enthalten.<II>syn>II</umerge_lists2 quelllistenname zielllistenname k[v]<II>ex>II</umerge_lists2 katzen tiere kv<II>fileinfo>II<lists.tf<II><I>
/set help___014115101=<I>is_file_loaded>I<<II>type>II<mak<II>info>II<testet ob das angegebene File schon geladen ist, dabei wird auf die Existenz der filename_version Variablen geprueft<II>fileinfo>II<loading.tf<II><I>
/set help___019095116=<I>mud_shortest_output>I<<II>type>II<misc<II>info>II<Kommando zum Unterdruecken aller Bewegungsmeldungen durchs MUD.<II>see>II<way.tf<II>fileinfo>II<warok<II><I>
/set help___1995943796=<I>highlight>I<<II>type>II<mak<II>info>II<Faerbt die als Parameter angegebenen Worte mit den als ersten Parameter vorgegebenen Attributen ein.Gross-/Kleinschreibung beachten! Es werden Trigger mit -mregexp dafuer erzeugt, der Name ist t_highlight_%2<II>ex>II</highlight BCred Mekare Maharet<II>fileinfo>II<util.echo.tf<II><I>
/set help___391243340=<I>uaddtolist>I<<II>type>II<comm<II>mak>II</deleteallkeysandvalues, /addtolist<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und einen Wert an das Ende einer Liste an, nachdem alle bisherigen Vorkommen des Schluessels geloescht wurden.<II>syn>II</uaddtolist listenname schluessel wert<II>see>II</addtolist, /addbtolist, /xuaddtolist, /getvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___014115097=<I>bs_teilemit_an>I<<II>type>II<cfg<II>info>II<Ausgabe der gesendeten Mitteilungen<II>fileinfo>II<crypt.tf<II><I>
/set help___029773404=<I>cfg_set>I<<II>type>II<mak<II>info>II<Wenn die ueber die Config-Hierarchie-Namen bestimmte Variable noch nicht gesetzt ist, wird sie auf den Wert des letzten Parameters gesetzt<II>syn>II</cfg_set Config-Hierarchie-Namen Wert<II>return>II<Variablenname<II>ex>II</cfg_set USE LOADING 1<II>fileinfo>II<config.tf<II><I>
/set help___000057180=<I>aget>I<<II>type>II<func<II>info>II<Liefert den Wert des Feldes am angegebenen Index zurueck.<II>syn>II</aget feldname index<II>return>II<Wert in %value und als Rueckgabewert<II>var>II<%value<II>see>II</aput<II>fileinfo>II<lists.tf<II><I>
/set help___011111110=<I>load_depend>I<<II>type>II<mak<II>info>II<Laedt abhaengige Dateien fuer die, mit vollem Pfad uebergebene, Makrodatei. Dabei enthaelt dateiname.def die Standardeinstellungen und sollte nicht vom Benutzer veraendert werden, dazu ist die Kopie namens dateiname.cfg da. Bei einer Neuinstallation wird dateiname.def ueberschrieben, damit dort auch aktuelle Aenderungen (z. B. neue Konfigurationsparameter) zum Tragen kommen. In Dateiname.test kann eine Testdatei stehen.<II>syn>II</load_depend voller_dateiname<II>ex>II</load_depend loading.tf<II>fileinfo>II<loading.tf<II><I>
/set help___2024963834=<I>inner_var>I<<II>type>II<func<II>info>II<Erlaubt den Zugriff auf beliebig tief aufeinander verweisende Variablen (z.B. a2="a1" a1="a0" a0=5).<II>syn>II</inner_var [tiefe] varname<II>ex>II<a2="a1" a1="a0" a0=5@{N}/inner_var a2 -> "a1"@{N}/inner_var 1 a2 -> "a1"@{N}/inner_var 2 a2 -> "a0"@{N}/inner_var 3 a2 -> "5"<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___2119076245=<I>tf-macros>I<<II>type>II<see<II>fileinfo>II<help.tf, properties.tf, worldconnect.tf, mapper.tf, keys.tf, untroom.tf, status.tf, way.tf, mg_properties.tf, uselists.tf, ari.tf, kampf.tf, vorsicht.tf, team.tf<II><I>
/set help___011111112=<I>count_steps>I<<II>type>II<mak<II>info>II<Berechnet die Laenge des Wegs ueber das Zaehlen von %;<II>syn>II<$(/count_steps Weg)<II>return>II<die Laenge ueber /echo, also $()<II>fileinfo>II<way.tf<II><I>
/set help___013100102=<I>addh_fileinfo>I<<II>type>II<mak<II>mak>II</forEach, /addh, /fi_add<II>list>II<file_comm, file_mak<II>info>II<Fuegt die in dieser Makrodatei erstellten Kommandos und Makros in den Hilfeeintrag fuer die Datei ein und schliesst diesen Hilfeeintrag ab.<II>var>II<%fi_list, %file_name<II>fileinfo>II<help.tf<II><I>
/set help___269211541=<I>pub_done>I<<II>type>II<mak<II>info>II<Die gesammelten Daten werden nach Abfrage in die Liste 'pubs' geschrieben. Das Makro /pub_count wird aus dem Hook 'points' entfernt.@{N}Die erhaltenen Lebenspunkte/Magiepunkte werden in %pub_lp bzw. %pub_mp gespeichert.@{N}Die erhaltenen Daten werden angezeigt und nach Abfrage in der Liste 'pubs' gespeichert.<II>var>II<pubs, pub_temp_list, pub_nr, pubs_name<II>fileinfo>II<uselists.tf<II><I>
/set help___000469121=<I>delay>I<<II>type>II<mak<II>func>II<time()<II>info>II<Verzoegert eine Aktion die angegebene Zeit.<II>syn>II</delay zeit aktion<II>var>II<%permit<II>fileinfo>II<untroom.tf<II><I>
/set help___000539371=<I>todos>I<<II>type>II<comm<II>info>II<Merkt sich Details in der Detailliste zum spaeteren Untersuchen. Praktisch wenn man mittendrin noch Details feststellt, die es lohnen, untersucht zu werden. Es koennen mehrere Details (jeweils ein Wort) zusammen uebergeben werden.<II>ex>II</todos Ast Zweige Baum<II>fileinfo>II<untroom.tf<II><I>
/set help___1985775180=<I>hcopylist>I<<II>type>II<comm<II>mak>II</hcreatelist, /hcopylist2<II>info>II<Erstellt eine Kopie der angegebenen ?Hashliste.<II>syn>II</hcopylist quelllistenname ziellistenname<II>fileinfo>II<lists.tf<II><I>
/set help___013102111=<I>cfg_echocolor>I<<II>type>II<mak<II>info>II<Gibt den uebergebenen String je nach CFG_ECHO_GAG_LEVEL farbig oder ohne Attribute aus.<II>syn>II</cfg_echocolor configname %*<II>ex>II</set CFG_MG_ZAUBERER_ZSCHILD_ECHO_ATTR=Cblue@{N}/cfg_echocolor MG_ZAUBERER_ZSCHILD Zauberschild<II>fileinfo>II<config.tf<II><I>
/set help___000068107=<I>walk>I<<II>type>II<comm<II>list>II<xtramoves<II>changes>II<1.03 Der Hook kommuniziert mit der Mapper Application ?mapper.tf, wenn die Variable ?mapper auf 1 gesetzt ist. Wenn %automapper auf 1 gesetzt ist, werden Bewegungen sofort in neue Ausgaenge umgewandelt.@{N}Der Hook wird jetzt erst in der customize.tf definiert, wenn der 'movement_marker' feststeht, damit unnoetige Sufrufe vermieden werden. Susserdem kommen sich so hoffentlich die verschiedenen Send-Hooks nicht mehr in die Quere.@{N}1.04 * Einbindung des Mappers (?mapper.tf). Die Befehle, die ans Mud gesandt werden, bekommt auch der Mapper, sofern (%mapper==1). Wenn (%automapper==1) werden dem Mapper zuvor die Befehle zum Erzeugen der Ausgaenge uebermittelt.@{N}* Bug beim Speichern des Rueckweges behoben.<II>info>II<Ein Send-Hook, der auch als Makro aufgerufen werden kann und die Syntax des ?speedwalk versteht. Er fuegt die expandierten Bewegungen den Wegespeichern des Wegesystems hinzu. Das Besondere ist, dass das Trennzeichen ?movement_marker selbst gesetzt werden kann und dass die Befehle als eine Zeile an das Mud gesendet werden. Das Trennzeichen muss auch vor dem ersten Befehl auftauchen, damit nicht beliebige ans Mud gesendete Strings untersucht werden muessen.<II>syn>II<regexp: (/walk )?(,([0-9]+)?[^0-9,]+)+<II>version>II<1.03<II>ex>II<[/walk ],5o,2n,25 klatsche,ob,schaue<II>var>II<movement_marker<II>see>II<shorten, customize.tf<II>fileinfo>II<way.tf<II><I>
/set help___011111114=<I>do_wait_tri>I<<II>type>II<mak<II>info>II<So etwas wie ein if Trigger, er versucht das angegebene Kommando auszufuehren, kommt da TriggerTextOk, dann fuehrt er den Weg fort sonst wartet er auf TriggertextNaechsterVersuch und fuehrt dann den Befehl noch einmal aus und fuert den Weg fort. Zb gut geeignet fuer Schiffe,Grossmaeule usw. zum betreten.<II>syn>II</do_wait_tri kommando,TriggertextOK,TriggertextNaechsterVersuch<II>fileinfo>II<way.tf<II><I>
/set help___000007872=<I>max>I<<II>type>II<mak<II>info>II<Liefert das Maximum von zwei Zahlenwerten ueber /echo zurueck. Also Ergebnis mit $() holen.<II>return>II<ueber /echo das Maximum der Zahlen<II>see>II<substitutions<II>fileinfo>II<util.tf<II><I>
/set help___018095116=<I>def_catch_num_trig>I<<II>type>II<trig<II>info>II<Nach dem Triggern der Startzeile werden die naechsten n Zeilen in der Variablen %fulldetail gesammelt und dann das Makro in der Variablen %nextmakro ausgefuehrt, das diesen Text dann verarbeiten kann.<II>syn>II</def_catch_num_trig num_catch_lines Starttext<II>ex>II<'/def_catch_num_trig 5 Inventory:' sammelt die 5 Zeilen des Inventories auf.<II>fileinfo>II<util.trigger.tf<II><I>cfg_help_show_tips>I<<II>type>II<cfg<II>info>II<Flag fuer Help Tips<II>fileinfo>II<help.tf<II><I>
/set help___030098279=<I>cond_go>I<<II>type>II<mak<II>info>II<Wenn innerhalb eines Weges angewandt, wird das Kommando gesetzt, das vor jedem Mud-Wegbefehl ausgefuehrt wird. Es kann z.B. zum Ueberpruefen komplexer Bedingungen in einem Gebiet genutzt werden, oder mit /wait zum Setzen einer Pause vor jedem Wegebefehl. Mit /no_cond_go wird dieser Modus wieder aufgehoben. Fuer die Kommandos, die mit /cond_go gesetzt werden, gelten folgende Bedingungen:@{N}* Der uebergebene Wegebefehl muss im Erfolgsfall ausgefuehrt werden.@{N}* Das Makro muss im Erfolgsfall mit /cont_way beendet werden, damit der Weg fortgesetzt werden kann.@{N}* Bei Komplettabbruch des Weges muss die Variable ?go auf 0 gesetzt werden.<II>ex>II</def check = /echo naechster Befehl %*%;/cw%; /cond_go /check@{N}'/cond_go /wait 4' wartet vor jedem Wegebefehl 4 Sekunden<II>var>II<cond_go<II>see>II<wait, no_cond_go<II>fileinfo>II<way.tf<II><I>
/set help___013100105=<I>add_to_detail>I<<II>type>II<mak<II>info>II<Fuegt die einzelnen Zeilen der Mudausgabe zu einem String zusammen. Dabei werden Trennungsstriche am Zeilenende zusammengefuegt.<II>var>II<f%ulldetail, %detail<II>fileinfo>II<untroom.tf<II><I>
/set help___023111111=<I>untroom_hide_mud_output>I<<II>type>II<cfg<II>info>II<Wenn gesetzt, wird vom TF die Herkunft des gerade angezeigten Details angezeigt (als Hervorhebung im Originaltext).<II>fileinfo>II<untroom.tf<II><I>
/set help___000527092=<I>reval>I<<II>type>II<mak<II>info>II<Evaluiert den uebergebenen String und gibt das Ergebnis zurueck, noetig, weil /eval /let a=b ist %b nicht funktioniert<II>syn>II</reval String<II>return>II<Evaluierter String<II>var>II<lokal: tmp_eval<II>fileinfo>II<util.sfunc.tf<II><I>
/set help___101101050=<I>result das sortierte feld in %amsort_base und das ggf. mitzusortierende zweite feld in %amsort_base2.>I<<II>type>II<misc<II>info>II<Implementation von Merge-Sort fuer die Felder. Es werden das zu sortierende Feld, minIndex und maxIndex sowie der Name der Vergleichsfunktion uebergeben. Ausserdem ist es moeglich, ein Feld anzugeben, das in derselben Weise wie das Sortierfeld mitgetauscht wird. Als Vergleichsfunktionen kommen in erster Linie ascmp, asicmp (Default) und ancmp in Frage.<II>syn>II</amsort feldname von bis [sortierfunc] [zweitfeld]<II>ex>II</amsort baeume 4 10 ascmp obst<II>fileinfo>II<lists.tf<II><I>
/set help___011111116=<I>vorsicht.tf>I<<II>type>II<fileinfo<II>mak>II<testvorsicht<II>info>II<Enthaelt Befehle, Hooks und Trigger, die es erlauben, erstens dem Pingpongeffekt bei der Vorsicht aus dem Weg zu gehen und zweitens die Fluchtrichung beliebig komplex (TF-Befehle und speedwalk (siehe /walk)) zu machen.<II>req>II<lists.tf<II>comm>II<v, fl<II>trig>II<t_whimpie, t_vorsicht<II>version>II<vorsicht.tf,v 1.20 2003/12/09 16:24:07 thufhnik (Dotz@mg.mud.de, Mesirii@mg.mud.de)<II>hook>II<h_send_v, h_send_fl<II>var>II<tf_vorsicht, tf_min_vorsicht, tf_not_flucht, vorsicht_null, fr_vorsicht_null<II>fileinfo>II<vorsicht.tf<II><I>
/set help___004249185=<I>setkey>I<<II>type>II<mak<II>list>II<tasten<II>info>II<legt eine Tastenbelegung fest.<II>syn>II</setkey Modus Taste Befehl Beschreibung@{N}Befehl und/oder Beschreibung mit Leerzeichen@{N}/setkey Modus Taste Befehl&Beschreibung<II>ex>II</setkey 2 5 i Inventory@{N}/setkey 2 5 zuecke %waffe&Waffe zuecken<II>fileinfo>II<keys.tf<II><I>
/set help___017116110=<I>artikel_entfernen>I<<II>type>II<mak<II>info>II<Entfernt einen bestimmten bzw. unbestimmten Artikel vom Parameter, unter Nutzung von regmatch.<II>ex>II</artikel_entfernen Ein NPC - return NPC<II>fileinfo>II<util.tf<II><I>
/set help___018116116=<I>lists promt_action>I<<II>type>II<misc<II>info>II<Fuehrt nach dem erfolgreichen Ausfuehren der x naechsten Befehle, die ans Mud geschickt werden, den angegebenen Code aus. Dieser wird in einer Liste gespeichert und vom Hook 'h_action_prompt' ausgefuehrt. Es wird auf die Zahl der bisher gesendeten Befehle der Parameter (Standard 1) aufaddiert, und nach dieser Zahl Prompts wird der Code ausgefuehrt.<II>syn>II</add_prompt_action (Zahl der abzuwartetende Befehle) Code<II>ex>II<n%;n%;o%;@{N}/promt_action 5 /echo fertig%;@{N}o%;n%;ob%;s%;w%; (wenn diese Befehle vom Mud fertig ausgefuehrt wurden, kommt das '/echo fertig')<II>see>II<def_prompt_hook<II>fileinfo>II<util.prompts.tf<II><I>
/set help___011111117=<I>wo_show_bug>I<<II>type>II<cfg<II>info>II<Schaltet die Ausgabe des gegrabbten Textes fuer den Raum bei einem fehlerhaften /wo ein bzw. aus<II>fileinfo>II<way.tf<II><I>
/set help___022119120=<I>cfg_windows_show_xterm>I<<II>type>II<cfg<II>info>II<Flag das angibt ob ein xterm/dos box aufgemacht werden soll, die den Inhalt des Logfiles anzeigt<II>dtype>II<flag<II>fileinfo>II<util.windows.tf<II><I>
/set help___000483889=<I>hash1>I<<II>type>II<mak<II>info>II<Liefert einen Hashwert des uebergebenen Strings zurueck. Dieser wird gebildet, indem eine Verkettung aus Stringlaenge modulo 1000, sowie den ASCII Werten der folgenden Zeichen erzeugt wird. 1. Zeichen bei Position Stringlaenge modulo 100 (als Prozentwert dividiert durch 100) mal Stringlaenge (hier mod. 1000, ist aber nicht so wichtig). 2. Zeichen bei Stringlaenge (mod 1000) - Position1.@{N}Wenn der String weniger als 10 Zeichen beinhaltet, wird der Hashcode nach folgender Formel berechnet: x=0, x:=x*8+ascii(i), i=0..strlen<II>syn>II</hash1 string, Returnwert per /result<II>fileinfo>II<util.sfunc.tf<II><I>
/set help___013102115=<I>cfg_save_list>I<<II>type>II<mak<II>info>II<Speichert die angegebene Liste ab, wenn sie schon geladen wurde, wird der Zielort aus der Liste lists genommen, sonst wird er aus der Config-Hierarchier per /cfg_get_dest ermittelt, die Liste dahin gespeichert und an die jeweilige user_config.cfg das Ladekommando angehaengt.<II>see>II<cfg_save<II>fileinfo>II<config.tf<II><I>
/set help___034257217=<I>testway>I<<II>type>II<comm<II>info>II<Fuehrt die Berechnung genauso wie /go aus und zeigt den Ergebnisweg komplett an. Der Weg wird nicht ausgefuehrt, aber trotzdem in den Cache geschrieben, so dass bei einem nachfolgenden /go sofort losgelaufen wird.<II>syn>II</testway zielknoten<II>ex>II</testway gilde<II>see>II<go<II>fileinfo>II<way.tf<II><I>
/set help___029535825=<I>amsort1>I<<II>type>II<mak<II>func>II<aget<II>mak>II</aput<II>info>II<Eigentliche Implementation des Merge-Sort-Algorithmus. Wird rekursiv aufgerufen. Das zu sortierende Feld steht in %amsort_base, das ggf. mitzusortierende Fehld in %amsort_base2 und die Vergleichsfunktion in %amsort_func<II>syn>II</amsort1 von bis<II>var>II<%amsort_base = Sortierfeld, %amsort_func = Vergleichsfunktion, %amsort_base2 ggf. Zweitfeld<II>see>II</amsort<II>fileinfo>II<lists.tf<II><I>
/set help___238184461=<I>cfg_name>I<<II>type>II<mak<II>info>II<Liefert eine Verkettung der Parameter mit cfg_ davor. Wird fuer konfigurierte Variablennamen und cfg-Listen verwendet.<II>syn>II</cfg_name Config-Hierarchie-Namen<II>see>II<cfg_var_name, cfg_list_name<II>fileinfo>II<config.tf<II><I>
/set help___313237217=<I>nodes_info>I<<II>type>II<comm<II>info>II<Sucht in den Knoteninfomationen alle Knoten, die im Text den angegebenen String enthalten.<II>fileinfo>II<way.tf<II><I>
/set help___000008527=<I>weg>I<<II>type>II<comm<II>mak>II<vorwaerts<II>info>II<Speichert ab dem Einschalten @{B}alle@{n} Kommandos im Hin- und (sofern erahnbar) auch im Rueckweg. Ab dem Ausschalten per /weg oder /end dann nicht mehr.<II>syn>II<einschalten mit /weg und ausschalten mit /weg oder /end<II>hook>II<SEND<II>var>II<weg, wegeingabe<II>see>II<wege,<II>fileinfo>II<way.tf<II><I>
/set help___1738199231=<I>create_way>I<<II>type>II<mak<II>list>II<ways<II>info>II<Aus der uebergebenen Abfolge der Wegknoten ermittelt diese Funktion den kompletten Weg.<II>syn>II</create_way Anfangsknoten:knoten1:knoten2:...:Endknoten<II>var>II<real_way<II>fileinfo>II<way.tf<II><I>
/set help___2114036083=<I>show_idee>I<<II>type>II<comm<II>info>II<Zeigt die Liste mit den fehlenden Details an.<II>see>II<herkunftsanzeige, /detail_idee, /send_idee<II>fileinfo>II<untroom.tf<II><I>
/set help___015105100=<I>write_to_window>I<<II>type>II<comm<II>info>II<In das als erster Parameter angegebene Fenster wird der als Restparameter uebergebene Text geschrieben.<II>ex>II</write_to_window Tod wieder mal gestorben<II>fileinfo>II<util.windows.tf<II><I>
/set help___013115108=<I>user_got_idle>I<<II>type>II<hook<II>info>II<Hook der beim Idle-Werden des Nutzers aufgerufen wird<II>fileinfo>II<worldconnect.tf<II><I>
/set help___246645790=<I>h_abbrev>I<<II>type>II<hook<II>mak>II<tokenize<II>list>II<abbreviations<II>info>II<Dieser Send-Hook faengt die Abkuerzungen ab und ersetzt sie wie bei /def_abbrev beschrieben.<II>fileinfo>II<util.abbrev.tf<II><I>
/set help___1738193332=<I>createlist>I<<II>type>II<comm<II>info>II<Erstellt eine leere Liste. Diese Liste wird in der globalen Variable mit dem angegebenen Namen gehalten. Eine evtl. vorhandene Liste mit dem gleichen Namen wird geloescht.<II>syn>II</createlist listenname<II>see>II</createnewlist<II>fileinfo>II<lists.tf<II><I>
/set help___016095046=<I>mg_properties.tf>I<<II>type>II<fileinfo<II>mak>II<echo_hit_points, set_points, kkwer<II>list>II<props, finger_props<II>info>II<Auslesen der Spielerproperties mittels catch-trigger und Liste<II>req>II<properties.tf(1.12) lists.tf util.tf util.hooks.tf util.trigger.tf util.sfunc.tf<II>comm>II<check_props, check_punkte, check_info, check_finger, updateplayer<II>trig>II<t_lpmp<II>cfg>II<cfg_mud_hit_points_echo_text, cfg_mud_hit_points_echo_attr, cfg_mud_do_echo_hit_points<II>version>II<mg_properties.tf,v 1.50 2003/09/13 08:48:45 thufhnik (Mesirii@mg.mud.de)<II>var>II<mud_properties, p_m_lp, p_m_mp, p_update_time, p_blind, p_deaf, p_block<II>fileinfo>II<mg_properties.tf<II><I>
/set help___034296854=<I>sperren>I<<II>type>II<see<II>info>II<Wegstuecken koennen temporaer gesperrt werden. Das kann von Hand mittels /disable erfolgen, oder wenn bei der Ausfuehrung eines Weges ein Fehler auftrat.<II>see>II<disable, enable, verify<II>fileinfo>II<way.tf<II><I>
/set help___392488524=<I>split_list>I<<II>type>II<mak<II>mak>II</createlist, /getdvalueof, /addhtolist<II>info>II<Die angegebenen Schluessel werden aus der als ersten Parameter angegebenen Lister geloescht und mit ihren Werten in die Liste 'split_list' eingetragen.@{N}Die Schluessel duerfen keine Leerzeichen enthalten.<II>syn>II</split_list listenname schluessel1 [schluessel2 ...]<II>var>II<%split_list, %value<II>fileinfo>II<lists.tf<II><I>
/set help___022115109=<I>mud_show_exits_command>I<<II>type>II<var<II>info>II<Kommando zur Anzeige der Ausgaenge.<II>fileinfo>II<warok<II><I>mud_show_short_command>I<<II>type>II<var<II>info>II<Kommando zur Anzeige der p_short.<II>fileinfo>II<warok<II><I>
/set help___2017453644=<I>hshowlist>I<<II>type>II<comm<II>mak>II</hforEach<II>info>II<Zeigt die angegebene ?Hashliste in einem lesbaren Format an. Sublisten werden eingerueckt.<II>syn>II</hshowlist listenname<II>fileinfo>II<lists.tf<II><I>
/set help___086097115=<I>result the assorted array in %amsort_base, the optional second array in %amsort_base2.>I<<II>type>II<misc<II>var>II<%amsort_base = Sortierfeld, %amsort_func = Vergleichsfunktion, %amsort_base2 ggf. Zweitfeld, %value<II>fileinfo>II<lists.tf<II><I>
/set help___032236060=<I>maharet>I<<II>type>II<cfg<II>info>II<Liste der fuer maharet gespeicherten Variablen<II>fileinfo>II<warok<II><I>
/set help___012101110=<I>default long>I<<II>type>II<misc<II>info>II<Variable, die bestimmt, wie die Knoten dargestellt werden sollen<II>ex>II<wert   Beispiel@{N}short  mesi@{N}long   mesi Haus Mesirii (Ebene)@{N}geb    mesi (Ebene)@{N}info   mesi Haus Mesirii<II>fileinfo>II<way.tf<II><I>deklinations>I<<II>type>II<list<II>info>II<Enthaelt die fuer die Zuordnung "dekliniertes Wort" -> Nominativ.<II>see>II</add_deklination<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___016114105=<I>herkunftsanzeige>I<<II>type>II<see<II>info>II<Die Herkunftsanzeige zeigt an, aus welcher Detailbeschreibung das aktuell zu untersuchende Detail stammt. Dabei wird das Detail entsprechend des angegebenen Stiles hervorgehoben.@{N}Die Herkunftsanzeige kann mit ?/show_origin ein- und ausgeschaltet werden.<II>see>II</show_origin, set_style, /typo, /detail_idee<II>fileinfo>II<untroom.tf<II><I>
/set help___012114102=<I>profile_info>I<<II>type>II<mak<II>info>II<Gibt die gemessenen Zeiten fuer das angegebene, in Zeitmesscode eingebettete Makro aus.<II>syn>II</profile_info makroname<II>see>II<profile_unwrap, profile_wrap<II>fileinfo>II<util.timer.tf<II><I>
/set help___016101116=<I>check_deprecated>I<<II>type>II<mak<II>info>II<Ueberprueft die Liste der veralteten Variablen/Makros und gibt die entsprechenden Fehlermeldungen aus.<II>fileinfo>II<util.tf<II><I>
/set help___012114097=<I>profile_wrap>I<<II>type>II<mak<II>info>II<Kapselt den Body des angegebenen Makros in Zeitmesscode, mit /profile_info kann das Ergebnis abgefragt werten,<II>syn>II</profile_wrap makroname<II>see>II<profile_info, profile_unwrap<II>fileinfo>II<util.timer.tf<II><I>
/set help___014099101=<I>hcount_entries>I<<II>type>II<func<II>var>II<%value<II>see>II</count_entries, hashlist<II>fileinfo>II<lists.tf<II><I>
/set help___012101114=<I>team_history>I<<II>type>II<comm<II>info>II<History von Team-Rufe. Parameter gibt die gewünschten Zeilen an; alles nach dem Zeilenparameter ist Matching Pattern (glob-pattern).<II>syn>II</team_history [n] [Pattern]<II>ex>II</team_history 10 {borz|sivok}@{N}gibt alle der letzten 10 Zeilen aus, in denen irgendwo "borz" oder "sivok" vorkommt.<II>fileinfo>II<team.tf<II><I>
/set help___016095117=<I>fr_vorsicht_null>I<<II>type>II<var<II>info>II<steuert, ob eine Fluchtrichtung aus mehr als einem Befehl, das Setzen der Vorsicht beim Fliehen für 10 Sekunden auf 0 aufhebt. Bei Fluchtrichtungen aus nur einem Befehl wird wenn dieses Flag gesetzt ist, trotzdem die Vorsicht auf 0 gesetzt.<II>see>II<testvorsicht, exec_vorsicht<II>fileinfo>II<vorsicht.tf<II><I>
/set help___032466508=<I>mi_list>I<<II>type>II<cfg<II>info>II<Liste der Attribute die aus dem Mud an den Mapper geschickt werden sollen<II>ex>II<mi_list=long npc author short<II>fileinfo>II<mapper.tf<II><I>
/set help___029420422=<I>i18n.tf>I<<II>type>II<fileinfo<II>mak>II<map_locale, add_loc, loc<II>info>II<Internationalisierung<II>req>II<lists.tf<II>cfg>II<user_lang<II>version>II<i18n.tf,v 1.11 2002/12/06 16:17:15 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<i18n.tf<II><I>
/set help___014099102=<I>echo_file_info>I<<II>type>II<mak<II>info>II<Sofern 'load_quiet' nicht gesetzt ist, werden per /user_echo_file_info die Dateiinformationen der Dateivariablen ausgegeben.<II>cfg>II</user_echo_file_info<II>var>II<lokal fi_filename, fi_file<II>fileinfo>II<loading.tf<II><I>
/set help___029177420=<I>addlist>I<<II>type>II<mak<II>list>II<tasten<II>info>II<Intern. Fuegt eine Belegung ohne weitere Ueberpruefung in die Liste ein.<II>syn>II</addlist modus nummer befehl kommentar@{N}alternativ Befehl und Kommentar mit Leerzeichen:@{N}/addlist modus nummer befehl parameter&kommentar text<II>see>II<setkey<II>fileinfo>II<keys.tf<II><I>
/set help___004036246=<I>listen>I<<II>type>II<misc<II>info>II<Die Listenverwaltung bildet den Grundstock fuer alle anderen Makros.@{N}Die Listen bestehen jeweils aus Schluessel-Wert-Paaren, die durch Trennzeichen getrennt in einem grossen String stehen. Der Wert eines Schluessels kann auch wieder eine (Sub)Liste sein.@{N}Achtung: Die Liste 'list' wird fuer interne Zwecke benoetigt und sollte nicht verwendet werden.<II>see>II</createlist, /addtolist, /getvalueof etc.<II>fileinfo>II<lists.tf<II><I>
/set help___033651628=<I>pub_got>I<<II>type>II<mak<II>info>II<Speichert die Zeit bis zum Erhalt der Speise in der Variablen %pub_zbringe. Der Timer wird zurueckgesetzt und es wird eine Ueberwachung der LP/MP eingerichtet (mit /add_to_hook points).@{N}Zur Ueberwachung wird das Makro /pub_count genutzt.@{N}Durch den Zaehler %pub_count wird die Anzahl der Aenderungen unter 2 gezaehlt.<II>var>II<pub_zbringe, pub_count<II>see>II</timer, /add_to_hooks, /pub_count<II>fileinfo>II<uselists.tf<II><I>
/set help___247525548=<I>ext_read>I<<II>type>II<func<II>info>II<Ein erweitertes Read, das einen Praefix als Prompt setzt und einen Standardwert in die Eingabezeile schreibt.<II>syn>II</ext_read praefix [defaultwert]<II>ex>II</ext_read Auswahl 10<II>see>II<prompt<II>fileinfo>II<util.echo.tf<II><I>
/set help___2060919046=<I>watch_var>I<<II>type>II<comm<II>list>II<watch_list, watch_action_list<II>info>II<Mit diesem Makro lassen sich Aenderungen von Variableninhalten ueberwachen. Dazu wird in der Liste ?watch_list fuer jede zu ueberwachende Variable ihr Name und aktueller Inhalt gespeichert. Diese Liste wird dann mittels ?/watch_loop bzw. ?/watch_check_var alle ?%watch_time Sekunden mit den aktuellen Werten verglichen. Wurde eine Veraenderung festgestellt, wird diese ausgegeben und die Liste aktualiesert.@{N}Aufrufmoeglichkeiten:@{N}1. ohne Parameter: Startet bzw. stoppt die Variablenueberwachung.@{N}2. ein Parameter: Falls der Parameter der Name einer globalen Variable ist, wird sie mit ihrem aktuellen Inhalt an die Liste watch_list angehaengt bzw. aus ihr geloescht, falls sie dort schon vorhanden war. Außerdem wird die Variablenueberwachung gestartet, falls dies noch nicht der Fall war.@{N}3. mehr als ein Parameter: Wie bei 2., jedoch wird der restliche Teil der Parameter in der Liste ?watch_action_list eingetragen und ausgefuehrt, falls sich die angegebene Variable aendert.@{N}(Durch "/set watch_active=0" wird uebrigens nach spaetestens %watch_time Sekunden die Ueberwachung komplett beendet.)<II>syn>II</watch_var [Variablenname [Makro]]<II>ex>II</watch_var LP@{N}startet die Ueberwachung der globalen Variable %LP. Nach@{N}/set LP=-200@{N}erscheint nach kurzer Zeit@{N}# watch: %LP=-200@{N}Moechte man die Ueberwachung von %LP beenden, genuegt ein zweiter Aufruf von@{N}/watch_var LP@{N}Moechte man die Veraendung von %LP hervorheben, so laesst sich das z. B. mit@{N}/watch_var LP /echo -aCyellow aktuelle LP: %LP@{N}erreichen. Eine Veraendung von %LP fuehrt dann zu@{N}# watch: %LP=-200@{N}@{Cyellow}aktuelle LP: -200@{n}<II>var>II<%watch_active<II>see>II</watch_loop, %watch_time, %watch_active, watch_list, watch_action_list<II>fileinfo>II<util.debug.tf<II><I>
/set help___011101111=<I>getdvalueof>I<<II>type>II<func<II>info>II<Gibt den ersten gefundenen zum Schluessel passenden Wert zurueck und loescht ggf. das Paar.<II>syn>II</getdvalueof listenname schluessel<II>return>II<erster zum Schluessel passender Wert oder %error bei Fehler als Rueckgabewert und in %value<II>var>II<%value<II>see>II</getvalueof, /deletekeyandvalue<II>fileinfo>II<lists.tf<II><I>remove_hook>I<<II>type>II<mak<II>info>II<Entfernt den angegebenen Hook.<II>syn>II</remove_hook hookname<II>version>II<1.01<II>fileinfo>II<util.hooks.tf<II><I>
/set help___000001063=<I>wo>I<<II>type>II<comm<II>info>II<Erkennt, welcher Knoten der aktuelle Raum ist.<II>syn>II</wo<II>see>II<knoten, knotenaliase<II>fileinfo>II<way.tf<II><I>
/set help___011101112=<I>next_prompt>I<<II>type>II<mak<II>info>II<Da nicht alle Befehle, die ans Mud geschickt werden, einen Prompt generieren, diese aber benoetigt, wird um festzustellen, ob ein Teilweg schon abgelaufen wurde, zaehlt dieses Makro den Promptzaehler eins hoeher und setzt dann den Weg fort.<II>see>II<h_action_prompt, cont_way<II>fileinfo>II<way.tf<II><I>
/set help___012116116=<I>util.echo.tf>I<<II>type>II<fileinfo<II>func>II<ext_read, remove_attributes<II>mak>II<echolist, init_col_echo, col_echo, ifecho, simple_menu, line, format_success_text, highlight, color_line<II>info>II<Echo-Erweiterungen (Spalten, bedingt, Zeilenumbruch)<II>req>II<util.vfunc.tf<II>comm>II<echo2<II>version>II<util.echo.tf,v 1.21 2002/10/09 22:38:12 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<util.echo.tf<II><I>
/set help___000068438=<I>voff>I<<II>type>II<mak<II>mak>II<cont_way<II>info>II<Schaltet 'verify' aus. Danach werden alle Kommandos ohne Ueberpruefung ausgefuehrt.<II>var>II<verify<II>see>II<wegeingabe, von<II>fileinfo>II<way.tf<II><I>
/set help___261626524=<I>next_det>I<<II>type>II<misc<II>mak>II</do_show_origin<II>list>II<detlist<II>info>II<Sucht das naechste Detail aus den Listen, veranlasst die Anzeige der Herkunft des Details und gib '/unt detail' zum Bestaetigen an das tf.@{N}Dabei wird das /unt um eine maximale Zeit verzoegert (einstellbar, Default ist eine Sekunde).<II>var>II<%akt_det, %last_parent,<II>see>II</unt, /show_origin, /set_delay<II>fileinfo>II<untroom.tf<II><I>
/set help___2093150744=<I>stack_pop>I<<II>type>II<mak<II>info>II<Holt eine/viele Variable aus dem Stack. Wenn Variablenname(n) uebergeben werden, wird der Wert in dieser Variablen gespeichert.<II>return>II<der Inhalt der letzten Variablen<II>ex>II</stack_pop @{N} /stack_pop test @{N} /stack_pop test test2<II>see>II<stack_push, getstack, stack_put<II>fileinfo>II<util.stack.tf<II><I>
/set help___013105101=<I>file_suffixes>I<<II>type>II<var<II>info>II<Wird von /mload benutzt, um eine Datei mit verschiedenen Dateiendungen zu laden. Standardmaessig stehen die Dateiendungen in der Variablen 'file_suffixes'. Wenn das Verzeichnis nicht gegeben ist (also tf suchen soll), dann statt des Verzeichnisses einen Punkt (.) uebergeben.<II>fileinfo>II<loading.tf<II><I>list_required>I<<II>type>II<func<II>info>II<Parst die Liste der benoetigten Files und zeigt farbig an, welche davon schon geladen sind, dabei unterschieden zwischen unbedingt notwendigen Dateien und spaeter benoetigten Dateien.@{N}In der Dateivariablen 'filename_tf_requires' stehen die benoetigten Dateien, dabei sind die unbedingt notwenigen mit einem ! als Praefix markiert.<II>cfg>II<siehe \$(/listvar -s format_attr_*)<II>var>II<fi_filename<II>fileinfo>II<loading.tf<II><I>
/set help___015100112=<I>mud_long_output>I<<II>type>II<misc<II>info>II<Kommando zum Anzeigen aller Bewegungsmeldungen durchs MUD.<II>see>II<way.tf<II>fileinfo>II<warok<II><I>mud_what_output>I<<II>type>II<misc<II>info>II<Ausgabe des Muds bei Fehler.<II>see>II<way.tf<II>fileinfo>II<warok<II><I>
/set help___022099095=<I>def_catch_2regexp_trig>I<<II>type>II<mak<II>info>II<Der Text, der zwischen den zwei angegebenen Regexp-Triggern (einer fuer Start und einer fuer Stop) erscheint, wird inklusive dieser beiden Zeilen in der Variablen %fulldetail gespeichert. Nach dem Ausfuehren des Stop-Triggers wird das Makro, das in der Variablen %nextmakro steht, ausgefuehrt.<II>syn>II</test def_catch_2regexp_trig(regex_start,regex_stop)<II>ex>II<'/test def_catch_2regexp_trig("^Es begann","^Es endete")' speichert alles zwischen und inklusive der Zeilen der beiden Regexps.<II>var>II<%nextmakro, %fulldetail<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, /catch_output, /def_catch_prefix_trig, /def_catch_regexp_trig<II>fileinfo>II<util.trigger.tf<II><I>
/set help___003710616=<I>asicmp>I<<II>type>II<func<II>info>II<Vergleichsfunktion auf Stringbasis ohne Beruecksichtigung der Gross-/Kleinschreibung. Liefert einen Wert < 0, wenn der Feldwert an 'index1' lexikografisch kleiner ist als an 'index2'. Bei Gleichheit wird 0 zurueckgegeben, ansonste ein positiver Wert.<II>syn>II</asicmp feldname index1 index2<II>return>II<in %value und als Rueckgabewert<II>var>II<%value<II>see>II<ascmp, ancmp, sctrmp<II>fileinfo>II<lists.tf<II><I>
/set help___030757509=<I>erwarte>I<<II>type>II<mak<II>info>II<Traegt einen Grund ein, aus dem ein gewisser Spieler erwartet wird. Ohne Angabe von Parametern werden die anwesenden Erwarteten mit dem zugehoerigen Grund angezeigt. Durch Angabe von - kann ein Spieler wieder aus der Liste geloescht werden.<II>syn>II</erwarte [<name> <grund>|-]<II>ex>II</erwarte olli -<II>fileinfo>II<erwarte.tf<II><I>
/set help___011095116=<I>t_team_auto>I<<II>type>II<trig<II>info>II<Wertet die Team Autofolge Ausgaben fuer Wegesystem und Mapper aus.<II>fileinfo>II<team.tf<II><I>
/set help___253009658=<I>init_var>I<<II>type>II<mak<II>info>II<Initialisiert die uebergebenen Variablen als globale Variablen, wenn sie noch nicht gesetzt sind; wenn sie schon gesetzt sind, bleiben sie unberuehrt.<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___004335247=<I>vdebug>I<<II>type>II<mak<II>info>II<Gibt alle Variablen, die /vdebug als Parameter uebergeben werden, mit Name und Wert auf stderr aus, wenn 'debug' auf 1 gesetzt ist.<II>fileinfo>II<util.debug.tf<II><I>
/set help___011101116=<I>merge_lists>I<<II>type>II<mak<II>func>II<iskey<II>mak>II</getfirstkey, /xaddtolist, /getdvalueof, /deletekeyandvalue<II>info>II<Fuegt zwei Listen zusammen, wobei Schluessel, die in beiden Listen vorkommen, aus der zuerst angegebenen genommen werden. Die Ergebnisliste heisst 'merge_list'.<II>syn>II</merge_lists listenname1 listenname2<II>return>II<Ergebnisliste in %merge_list und per /return<II>var>II<%merge_list, %merge_list2, %value<II>see>II</hmerge_lists<II>fileinfo>II<lists.tf<II><I>self_update>I<<II>type>II<mak<II>info>II<Aktualisiert die angegebenen Variablen durch eine Selbstzuweisung (/test a:=a), damit sie eine Aktualisierung der  Statuszeile hervorrufen<II>syn>II</self_update var1 var2 ...<II>ex>II</self_update a b c<II>see>II</dep_var,/dset,/undep_var<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___077474531=<I>remove_cvs>I<<II>type>II<mak<II>info>II<Entfernt die Zusatztexte vom CVS von den Id Informationen.<II>syn>II</remove_cvs Text von Id<II>fileinfo>II<loading.tf<II><I>
/set help___000067922=<I>unt2>I<<II>type>II<comm<II>list>II<done_detlist<II>info>II<Details koennen damit ein zweites Mal untersucht werden. Sie werden einfach aus der entsprechenden Liste geloescht.<II>syn>II</unt2 detail<II>see>II</unt, /untroom<II>fileinfo>II<untroom.tf<II><I>
/set help___031994892=<I>killall>I<<II>type>II<mak<II>info>II<Killt alle Prozesse, die den uebergebenen Parameter enthalten<II>syn>II</killall [-q] matchtext<II>opt>II<q keine Ausgabe beim Kill<II>ex>II</repeat -10 10 /echo foo%;/killall foo<II>fileinfo>II<util.tf<II><I>
/set help___011101117=<I>reggetvalue>I<<II>type>II<func<II>func>II<convert_regexp<II>info>II<Liefert den ersten Wert zurueck, auf den die regexp passt.<II>syn>II</reggetvalue listenname regexp<II>return>II<erster zur regexp passender Wert als Rueckgabewert und in %value<II>var>II<%value<II>see>II</convert_regexp, regexp<II>fileinfo>II<lists.tf<II><I>
/set help___030030661=<I>delnode>I<<II>type>II<comm<II>mak>II<getnode, getali, delallkeysandvalues, delway<II>list>II<lastpoints<II>info>II<Loescht den Knoten mit all seinen Wegen (mit Abfrage).@{N}Vor dem Loeschen werden die Wegelisten neu geladen, um Inkonsistenzen zu vermeiden.<II>syn>II</delnode [knoten]<II>var>II<lastpoint<II>see>II<addnode, appendnode, knoten<II>fileinfo>II<way.tf<II><I>
/set help___1905762619=<I>check_idle>I<<II>type>II<mak<II>info>II<Testet ob der Nutzer seit %CFG_CONNECT_IDLE_TIME keine Taste mehr gedrueckt hat, setzt das Flag %user_is_idle und ruft den Hook ?user_got_idle auf.@{N}Wenn der Nutzer wieder aktiv wird, und vorher idle war wird das Flag zurueckgesetzt und der Hook ?user_got_active aufgerufen@{N}Haengt zur Zeit am Hook beat_30 (aller 30Sek)<II>fileinfo>II<worldconnect.tf<II><I>
/set help___011114108=<I>create_help>I<<II>type>II<comm<II>mak>II</create_help_filelist, /create_help_file<II>info>II<Erzeugt zu allen Files unterhalb der uebergebenen Verzeichnisse, die mit "*.tf" aufhoeren, die zugehoerige Hilfe. Evtl. vorhandene "i18n"-, "*.def"- oder "*.cfg"-Files werden ebenfalls beruecksichtigt. Alternativ kann auch eine Liste der Files direkt angegeben werden. Ohne Parameter werden alle Verzeichnisse aus %TFPATH durchsucht. Nach Erstellung der Hilfe wird sie gespeichert und noch etwas Statistikkram ausgegeben.@{N}Es wird lediglich die Hilfe erzeugt, Makros aus den entsprechenden Files werden nicht ausgefuehrt! Daher sollte es keine Probleme mit Abhaengigkeiten zwischen Files, sich widersprechenden Makrodefinitionen oder aehnlichen Seiteneffekten geben.@{N}Defaultmaessig wird die Hilfe komplett neu erzeugt. Eine bestehende Hilfe wird also geloescht und nicht erweitert. Will man eine bestehende Hilfe erweitern, so muss /create_help mit der Option '-a' aufgerufen werden.@{N}/create_help kann offline aufgerufen werden.@{N}Das Erzeugen der kompletten Hilfe kann eine ganze Weile dauern. Falls die ganze Geschichte laenger als 10 Sekunden dauert, wird deshalb nach Fertigstellung freundlich gepiepst.<II>syn>II</create_help [-a] [Pfad1/File1 Pfad2/File2 ...]<II>ex>II</create_help mg.mud.de meinkram.tf /usr/local/tf/<II>fileinfo>II<help.tf<II><I>
/set help___034201812=<I>tf_html>I<<II>type>II<var<II>info>II<Pfad zu tf-Hilfe HTML-Seiten.<II>ex>II<tf_html=file://localhost/data/docs/tf/commands/index.html<II>fileinfo>II<help.tf<II><I>
/set help___269214012=<I>pub_init>I<<II>type>II<comm<II>info>II<Mit diesem Makro werden die in einer Kneipe verfuegbaren Speisen und Getraenke erfasst. Falls die Kneipe schon in der Liste %pubs vorhanden ist, wird sie ueberschrieben. Der Name der Kneipe wird in %pubs_name gespeichert. Sie werden temporaer zur Weiterverarbeitung in der Liste %pub_temp_list gespeichert. Nachdem das Menue ausgelesen wurde, wird /init_pub2 fuer Aufraeumungsarbeiten aufgerufen.<II>ex>II</pub_init Kneipenname, z.B. /pub_init Kchaos<II>see>II<settank, gotank, init_pub2, pubs_name<II>fileinfo>II<uselists.tf<II><I>
/set help___029772636=<I>cfg_get>I<<II>type>II<mak<II>info>II<Liefert den Wert der ueber die Config-Hierarchie-Namen bestimmten Variable.<II>syn>II</cfg_get Config-Hierarchie-Namen<II>ex>II</cfg_get USE LOADING<II>fileinfo>II<config.tf<II><I>
/set help___004117678=<I>p_deaf>I<<II>type>II<var<II>info>II<Taub oder nicht taub?<II>fileinfo>II<mg_properties.tf<II><I>
/set help___233371704=<I>add_trip>I<<II>type>II<comm<II>info>II<Temporaerer Ausflug von nem Knoten: Zum Zielraum (z.B. NPC) laufen, dort /add_trip eingeben und schon kommt man per /tgo knoten in den Zielraum@{N}Loeschen per /add_trip direkt am Knoten oder /add_trip Knotenname<II>see>II<tgo<II>fileinfo>II<way.tf<II><I>
/set help___021099095=<I>def_catch_output_trig>I<<II>type>II<mak<II>info>II<Definiert den Trigger, der das Abfangen der Ausgaben des Muds vornimmt. Das Ergebnis wird in der Variablen %fulldetail gespeichert, wobei die Zeilenumbrueche durch @@@{}{N} gebildet werden. Damit ist eine Nutzung mit /echo2 moeglich. Die Ausgabe des Muds wird unterdrueckt.<II>ex>II</set nextmakro=/do_next%;@{N}/set fulldetail=%;@{N}/def_catch_output_trig%;@{N}/catch_output 2%;@{N}unt decke%;unt boden%;<II>var>II<fulldetail<II>see>II</catch_output, (alte Namen: /def_psave_trig, /def_psave3_trig)<II>fileinfo>II<util.trigger.tf<II><I>def_catch_regexp_trig>I<<II>type>II<mak<II>info>II<Ein Makro, das einen Regexp-Trigger definiert, dessen aufeinanderfolgende Zeilen in der Variablen %fulldetail gespeichert werden. Dabei wird der Text vom Mud unterdrueckt. Nach einer gegebenen Zeit wird das Grabben beendet und das Makro, welches in der Variablen %nextmakro steht, aufgerufen.<II>syn>II</def_catch_regexp_trig Sekunden Regexp<II>ex>II</def_catch_regexp_trig 5 ^Du siehst:@{N}Faengt waehrend der folgenden 5 Sekunden alle Textzeilen ab, die mit 'Du siehst:' beginnen, und speichert sie in der Variablen %fulldetail.<II>var>II<%nextmakro, %fulldetail<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, d/ef_catch_2regexp_trig, /catch_output, /def_catch_prefix_trig<II>fileinfo>II<util.trigger.tf<II><I>def_catch_prefix_trig>I<<II>type>II<mak<II>info>II<Ein Makro, das den Text, in dem die angegebene Regexp auftaucht, fuer eine bestimmte Zeit (Parameter) in der Variablen %fulldetail speichert und nach Ablauf der Zeit das Makro in der Variablen %nextmakro ausfuehrt. Dabei wird nur der Text in der Variablen gespeichert, der nicht von der Regexp abgedeckt wird (PL und PR). Der Text wird gegaggt.<II>syn>II</def_catch_prefix_trig Sekunden Regexp<II>ex>II<'/def_catch_prefix_trig 4 Jemand sagt:' speichert dessen Text fuer 4 Sekunden in der Variablen %fulldetail.<II>var>II<%nextmakro, %fulldetail<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, /def_catch_2regexp_trig, /catch_output,  /def_catch_regexp_trig<II>fileinfo>II<util.trigger.tf<II><I>def_catch_broken_trig>I<<II>type>II<trig<II>info>II<Faengt einen Text des Muds ab, von dem man nur Anfang und Ende kennen muss und der ueber mehrere Zeilen verteilt sein kann, und laesst den Gesamttext per /trigger nochmal ablaufen, so dass man diesen wie eine Zeile vom Mud betrachten kann.<II>syn>II</test def_catch_broken_trig("Starttext","Endtext")<II>ex>II</test def_catch_broken_trig("Der Haendler meint","Muenzen zahlen")<II>fileinfo>II<util.trigger.tf<II><I>cfg_connect_idle_time>I<<II>type>II<cfg<II>info>II<Zeit ab der man als idle angesehen wird<II>fileinfo>II<worldconnect.tf<II><I>
/set help___2121212275=<I>send_idee>I<<II>type>II<comm<II>info>II<Schickt die Liste mit fehlenden Details ab. Immer dran denken, ich vergesse es immer.<II>see>II<herkunftsanzeige, /detail_idee, /show_idee<II>fileinfo>II<untroom.tf<II><I>
/set help___015100119=<I>add_to_window_r>I<<II>type>II<comm<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Regexp-Trigger geschrieben, aber trotzdem noch im normalen Fenster angezeigt.<II>ex>II</add_to_window_r Tod \\[Tod:.*<II>fileinfo>II<util.windows.tf<II><I>add_to_window_g>I<<II>type>II<comm<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Global-Trigger geschrieben, aber trotzdem noch im normalen Fenster angezeigt.<II>ex>II</add_to_window_g Tod *[Tod:*<II>fileinfo>II<util.windows.tf<II><I>
/set help___032250570=<I>makesub>I<<II>type>II<mak<II>info>II<Substituiert im String Listentrennzeichen durch Sublistentrennzeichen usw.<II>syn>II</makesub string<II>return>II<per /result<II>see>II</getlistvalueof, /addlisttolist, /unmakesub<II>fileinfo>II<lists.tf<II><I>
/set help___1963548959=<I>file_info>I<<II>type>II<func<II>info>II<Liefert die Informationen in den Dateivariablen dateiname_suffix_name.<II>ex>II</test file_info("loading_tf","version")<II>fileinfo>II<loading.tf<II><I>
/set help___588497530=<I>loading.tf>I<<II>type>II<fileinfo<II>func>II<file_info, list_required<II>mak>II<custom, load_init_config, load_config, load_depend, try_load, remove_cvs, echo_file_info, is_file_loaded<II>changes>II<1.01 In den Hook Kommandos wurden Ueberpruefungen eingebaut, ob die Hooks schon existieren.@{N}/mload ruft jetzt den Hook pre_load vor dem Laden eines Files und loaded nach dem Laden eines Files auf.@{N}1.02 Das Laden von -c (=custom) Dateien wurde aus /mload ausgelagert, so dass alle Funktionen es nutzen koennen (siehe /custom).@{N}1.04 /custom wurde um die Moeglichkeit ergaenzt, -cp als einzigen Parameter zum Laden anzugeben; damit wird and das Mudverzeichnis noch ein Playerverzeichnis zum Laden drangehaengt.@{N}Fehler in myconn (CONNECT) behoben, der mehrfaches Laden der Files zur Folge hatte.<II>info>II<Das Dateisystem beruht auf den Properties eines Spielers.@{N}Es gibt Dateien, die vom Mud und Spieler (in gewissen Grenzen) unabhaengig sind:@{N}?loading.tf, ?help.tf, ?lists.tf, ?untroom.tf, ?way.tf, ?properties.tf@{N}Die Datei ${world_host}/${world_character}.tf (z.B.) mg.mud.de/mesirii.tf ist vom Mud abhaengig und wird beim Connect vom tf entsprechend geladen. Ausserdem wird aus diesem Directory auch die ?customize.tf geladen, die viele Einstellungen enthaelt.@{N}Zu den Dateien bitte die dortigen Hilfeseiten anschauen. Und jetzt viel Spass.<II>req>II<lists.tf util.hooks.tf util.prompts.tf<II>comm>II<mload, reload, purge_reload<II>misc>II<get_filename_file_info<II>version>II<loading.tf,v 1.43 2002/12/06 15:33:54 mh14 (Mesirii@mg.mud.de)<II>hook>II<pre_load, reload<II>var>II<file_suffixes<II>see>II<loading.tf, help.tf, lists.tf, untroom.tf, way.tf, properties.tf, customize.tf, mesirii.tf, chaos.tf, ueben.tf<II>fileinfo>II<loading.tf<II><I>
/set help___692516365=<I>watch_time>I<<II>type>II<var<II>info>II<Legt das Zeitintervall (in Sekunden) fest, in dem die zu ueberwachenden Variablen auf etwaige Veraenderungen geprueft werden.@{N}Sollte insbesondere auf langsamen Rechnern nicht zu klein gewaehlt werden. Der Wert 0 beendet die Ueberwachung.<II>see>II</watch_loop<II>fileinfo>II<util.debug.tf<II><I>
/set help___1874603570=<I>aforeach2>I<<II>type>II<comm<II>func>II<astart, alen, aget<II>info>II<Wie /forEach bzw. /hforEach fuer Listen arbeitet /aforEach2 alle Elemente zweier Felder durch, indem sie als Parameter fuer das uebergebene Makro genutzt werden.<II>syn>II</aforEach2 feldname feldname2 /makroname<II>see>II</aforEach, /asortforEach<II>fileinfo>II<lists.tf<II><I>
/set help___012104101=<I>check_finger>I<<II>type>II<comm<II>info>II<Aktualisiert die Spielereigenschaften (finger)<II>fileinfo>II<mg_properties.tf<II><I>
/set help___011111120=<I>noun_regexp>I<<II>type>II<var<II>info>II<Regexp fuer Substantive.<II>see>II<untroom.tf<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___2092546682=<I>status.tf>I<<II>type>II<fileinfo<II>func>II<status_colors<II>mak>II<status_breite, config_status_static, set_status_var_num, set_status_var_string, set_status_var_flag, set_status_var_count, format_number, format_number3, attr_ordered, attr_ordered_cmp, status_get_quote, status_config_set_attr, status_config_set_attr, status_config_attr<II>info>II<Statuszeile, die ihre Attribute selbst aendern kann<II>req>II<<II>comm>II<config_status<II>misc>II<infodefiniert eine variable fuer die statuszeile sofort (on the fly). die informationen zur darstellung werden aus den konfigurationsvariablen fuer farbe und text geholt (cfg_status_color_varname*, cfg_status_text_varname*)@{n}wenn statt des defaultwerts der variablenname noch einmal angegeben wird, wird die variable per selbstzuweisung aktualisiert<II>version>II<status.tf,v 1.36 2002/12/06 16:17:59 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<status.tf<II><I>
/set help___2103941573=<I>mud_quote>I<<II>type>II<comm<II>info>II<Schickt die Ausgabe des angegeben Mud-Kommandos mit dem angegebenen Praefix wieder ans Mud.<II>syn>II</mud_quote <Praefix> '<Mud-Befehl><II>ex>II</mud_quote sage 'inventar@{N}Der erste Parameter ist das Prefixkommando, und das nach dem ' das Kommando, dessen Ausgabe genutzt werden soll.<II>fileinfo>II<util.quote.tf<II><I>
/set help___014115115=<I>hsavenamedlist>I<<II>type>II<mak<II>info>II<Speichert die Liste, die den Namen %parameter_list_name hat in dem Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</hsavenamedlist paket_prefix<II>see>II</hloadnamedlist, /savenamedlist<II>fileinfo>II<lists.tf<II><I>
/set help___000066880=<I>rush>I<<II>type>II<comm<II>info>II</rush erlaubt es, lange unverzweigte Wege schnell abzulaufen. Es erwartet als Parameter eine Startrichtung und beginnt, in diese Richtung zu laufen. Dabei wird jeweils der Ausgang benutzt, mit dem man weiterkommt und nicht zurueck.@{N}/rush stoppt, wenn es einen Fehler bemerkt (z.B. blockender NPC) und schickt dann ggf. dem Mapper einen Befehl rueckwaerts, damit dieser wieder auf dem aktuellen Knoten steht. Ausserdem wird noch angehalten, wenn eine Verzweigung gefunden wird, oder der Weg in einer Sackgasse endet.@{N}Wenn man dem Mapper auf 'automapping' stellt, wird die Bewegung mitgezeichnet.<II>ex>II</rush n<II>fileinfo>II<way.tf<II><I>
/set help___003646650=<I>aclear>I<<II>type>II<comm<II>mak>II</purge_vars<II>info>II<Loescht die Variablen, die das angegebene Feld ausmachen, und setzt die min/max Indizes neu.<II>syn>II</aclear feldname<II>see>II<alen, astart<II>fileinfo>II<lists.tf<II><I>
/set help___000067407=<I>todo>I<<II>type>II<comm<II>info>II<Merkt sich Details in der Detailliste zum spaeteren Untersuchen. Praktisch wenn man mittendrin noch Details feststellt, die es lohnen, untersucht zu werden.<II>ex>II</todo Ast<II>fileinfo>II<untroom.tf<II><I>
/set help___319457007=<I>team_allow>I<<II>type>II<comm<II>info>II<Schaltet das "ferngesteuerte" Setzen von Angriffsbefehl und Fluchtrichtung durch den Teamleiter ein und aus.@{N}Da dies gefaehrlich sein kann, wird das zugehoerige Flag bei jedem Wechsel des Teamleiters wieder auf 'aus' gestellt.@{N}@{Cbgred}Vorsicht:@{x} Diese "Fernsteuerung" kann sehr gefaehrlich sein (und ist sowieso nur etwas fuer Wurstmetzler). Fuer daraus resultierende Tode oder sonstige Konsequenzen kann keine Haftung uebernommen werden. :^)<II>see>II</team_tab_fl<II>fileinfo>II<team.tf<II><I>
/set help___253909894=<I>kampf.tf>I<<II>type>II<fileinfo<II>info>II<Kampfrunden, Arinutzung, Spellwaffenspells, Kampf-Hooks<II>req>II<lists.tf spells.tf weapon.tf mg_properties.tf ari.tf<II>version>II<kampf.tf,v 1.9 2002/05/16 16:42:45 nieten (Mesirii@mg.mud.de)<II>fileinfo>II<kampf.tf<II><I>
/set help___2069095734=<I>unmakesub>I<<II>type>II<mak<II>info>II<Substituiert im String Sublistentrennzeichen durch Listentrennzeichen usw.<II>syn>II</unmakesub string<II>return>II<per /result<II>see>II</getlistvalueof, /addlisttolist, /makesub<II>fileinfo>II<lists.tf<II><I>
/set help___000007824=<I>klp>I<<II>type>II<mak<II>info>II<Loescht die Prompts der letzten Befehle an das Mud, so dass ein aktueller Einlesetrigger, der die Ausgaben des Muds liest, nur noch die des letzten Befehls bekommt (ueber ?mud_recognize_command).<II>syn>II</klp naechstes Makro mit Parametern<II>var>II<mud_recognize_command<II>see>II<wegeingabe, mud_recognize_command<II>fileinfo>II<way.tf<II><I>
/set help___013100115=<I>addlisttolist>I<<II>type>II<comm<II>mak>II</makesub, /addtolist<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und eine (Sub)Liste am Ende einer Liste an.@{N}In der Subliste werden die Listentrenner um eine Stufe erweitert.<II>syn>II</addlisttolist listenname schluessel subliste (der Inhalt!)<II>ex>II</addlisttolist obst aepfel %apfelsorten<II>see>II</addtolist, /getlistvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___2073957132=<I>loadsaved>I<<II>type>II<comm<II>list>II<${world_character}saved<II>changes>II<Defaultverzeichnis ist nun ${world_host}/${world_character}.<II>info>II<Laedt die in der letzten Sitzung gespeicherten Variablen aus der Datei ${world_character}saved.list im Verzeichnis ${world_host}/${world_character}. Falls diese Datei nicht existiert, wird versucht, sie aus ${world_host} zu laden. (Dieser zweite Versuch wird nur aus Kompatibilitaetsgrunden durchgefuehrt und in zukuenftigen Versionen vermutlich rausfliegen.)<II>see>II</addsave, /saveall<II>fileinfo>II<worldconnect.tf<II><I>
/set help___000066300=<I>quit>I<<II>type>II<over<II>info>II<Ueberschreibt das standardmaessige /quit so, dass die angegebenen Variablen abgespeichert werden. Der Hook quit wird ausserdem ausgefuehrt.<II>see>II<loadsaved, saveall, addsave, lists.mak<II>fileinfo>II<worldconnect.tf<II><I>
/set help___359110620=<I>test_quiet>I<<II>type>II<mak<II>info>II<Fuehrt den uebergebenen String per /test aus, speichert ggf. vorhandene Ausgaben in der Variablen 'output' und gibt per /return das Ergebnis des ausgefuehrten Strings zurueck.<II>ex>II</test_quiet /list -s makroname@{N}In 'output' stehen alle gefundenen Makros oder nichts.@{N}Der Rueckgabewert ist der vom /list.<II>var>II<output<II>see>II</wecho<II>fileinfo>II<util.tf<II><I>
/set help___000546415=<I>wecho>I<<II>type>II<comm<II>info>II<Schaltet ein Echo der zum Mud gesendten Kommandos ein und aus. Falls kein Parameter uebergeben wurde, wird die jeweils andere Einstellung verwendet. Wird '0' bzw. '1' als Parameter uebergeben, wird das Echo unabhaengig von der alten Einstellung. aus- bzw. eingeschaltet. Das Echo wird mit dem in 'wecho_attr' angegebenen Attributen ausgegeben.<II>syn>II</wecho [0|1]<II>var>II<wecho<II>see>II<wecho_attr<II>fileinfo>II<util.tf<II><I>
/set help___246658598=<I>h_action>I<<II>type>II<hook<II>info>II<Hook der den letzten Zeitpunkt speichert, an dem etwas ans Mud geschickt wurde. Wird von /check_idle genutzt.<II>fileinfo>II<util.prompts.tf<II><I>
/set help___015097101=<I>spare_linefeeds>I<<II>type>II<comm<II>info>II<Erlaubt es, mehrzeiligen Text mit Zeilenumbruechen ins tf zu pasten, ohne dass die Zeilenumbrueche als Returns gewertet werden, und diesen Text insgesamt mit einem Prefix versehen ans Mud zu schicken bzw. ihn im TF zu verwenden. Die Zeilenumbrueche werden mit einem SPACE ersetzt.@{N}Bei mehrzeiligen TF-Makros funktioniert das Ganze nicht, da '\' am Zeilenende und Leerzeichen am Zeilenanfang nicht so beruecksichtig werden, wie das eigentlich erwarten wuerde. Stattdessen den Hook ?/quote_multiline verwenden.<II>syn>II</spare_linefeeds [<prefix>] (ESC-q)<II>ex>II</spare_linefeeds sage <Enter druecken>, dann Text pasten und mit Escape-q beenden<II>see>II</my_quote, /quote_multiline<II>fileinfo>II<util.quote.tf<II><I>
/set help___013100118=<I>addlisttosave>I<<II>type>II<comm<II>mak>II</deletekeyandvalue, /addtolist<II>list>II<lists<II>info>II<Speichert die Laenge der angegebenen Liste als Veraenderungsmerkmal.<II>syn>II</addlisttosave listenname<II>see>II</savelist, /loadlist, /savealllists<II>fileinfo>II<lists.tf<II><I>
/set help___033997851=<I>settank>I<<II>type>II<comm<II>list>II<pubs<II>info>II<Dieses Makro dient zum Hinzufuegen und Editieren einer Tanke zu einem Knoten. Es wird ohne Parameter aufgerufen, alle Groessen werden abgefragt.@{N}1. Zuerst wird der Knoten eingegeben. Wenn dieser in der Liste %pubs noch nicht vorhanden ist, wird er hinzugefuegt.@{N}2. Danach wird ein Bezeichner fuer die Tanke abgefragt. Wenn dieser noch nicht vorhanden ist, wird er neu erzeugt, ansonsten editiert@.{N}3. Im folgenden werden die Groessen, die die Tanke bestimmten abgefragt, Lebenspunkte, Magiepunkte, Kosten (Muenzen), Anzahl (bei Kneipe 0), Zeit bis zum Erhalt der Tanke, Zeit bis zum kompletten Auftanken, Art der Tanke (g Getraenk, ag alkoholisches Getraenk, s Speise), Fuellung in % Getraenk, Alk, Speise.@{N}4. Als letztes wird entweder der Name der Tanke (Kneipe) eingegeben oder eine durch vorangestellten _ (Unterstrich) markierte Anzahl von TF- bzw. Mudbefehlen, die zum Tanken ausgefuehrt wird.<II>fileinfo>II<uselists.tf<II><I>
/set help___030179065=<I>dir_tri>I<<II>type>II<mak<II>info>II<Definiert einen Regexp Trigger, der den Weg fortsetzt, wenn er triggert, und zwar mit dem Richtungsbefehl, dessen Px-Nummer als erster Parameter angegeben wird.<II>ex>II<'/dir_tri 1 Das Schild zeigt nach ([A-Za-z]+), ([A-Za-z]+) und ([A-Za-z]+)'. Dann wird die Richtung, die in der ersten Klammerung steht, als erster Wegebefehl ausgefuehrt.<II>fileinfo>II<way.tf<II><I>
/set help___000536794=<I>timer>I<<II>type>II<mak<II>info>II<Ein Timer, der im Sekundenbereich misst, also eher fuer Mud-Probleme gedacht ist. Beim Anlegen des Timers kann ein Trigger definiert werden, der dann den Makro-Body in ?timer_makro ausfuehrt.<II>syn>II</timer count triggertext : Es wird /def -n%count %triggertext t_timer = /timer trigger erzeugt.@{N}/timer remove : Loescht den Timer.@{N}/timer reset : Setzt den Timer zurueck (geht auch fuer Initalisierung ohne trigger).@{N}/timer get : Liefert in %? die vergangene Zeit.@{N}/timer trigger : Fuehrt den Makro-Body in 'timer_makro' aus, wobei %1 die vergangene Zeit enthaelt.@{N}/timer : Reinitialisiert den Timer und liefert die vergangene Zeit in %? oder als Funktionswert zurueck.<II>trig>II<t_timer<II>ex>II<'/timer 2 -t"*faellt zu Boden*" -mglob' wird zu '/def -n2 -t"*faellt zu Boden*" -mglob t_timer = /timer trigger`<II>var>II<timer, timer_makro<II>see>II<timer_makro<II>fileinfo>II<util.timer.tf<II><I>
/set help___011104105=<I>show_origin>I<<II>type>II<comm<II>info>II<Wechselt zwischen den zwei Zustaenden der Variablen 'show_origin', also der Herkunftsanzeige.@{N}Wuerde sich ggf. ein Keybinding im Spielerfile lohnen.<II>var>II<%show_origin<II>see>II</do_show_origin, herkunftsanzeige<II>fileinfo>II<untroom.tf<II><I>
/set help___015105046=<I>util.prompts.tf>I<<II>type>II<fileinfo<II>mak>II<init_action_count, add_action_count, clear_actions, add_prompt_action<II>info>II<Makros zum Nutzen der Prompts, des Muds um Makros auszufuehren<II>req>II<lists.tf util.hooks.tf<II>misc>II<lists promt_action<II>version>II<util.prompts.tf,v 1.11 2003/12/11 10:35:49 mh14 (Mesirii@mg.mud.de)<II>hook>II<h_action<II>fileinfo>II<util.prompts.tf<II><I>util.trigger.tf>I<<II>type>II<fileinfo<II>mak>II<tf_prompt, def_catch_output_trig, catch_ouput, def_catch_regexp_trig, def_catch_2regexp_trig, def_catch_prefix_trig, trig_is_active, trig_purge<II>info>II<verschiedene Trigger, die mehrere Zeilen grabben<II>req>II<<II>trig>II<def_catch_broken_trig, def_catch_num_trig, def_catch_tf_prompt_trig, trig_grab<II>version>II<util.trigger.tf,v 1.24 2002/10/19 17:24:40 thufhnik (Mesirii@mg.mud.de)<II>var>II<trig_purge_timeout<II>fileinfo>II<util.trigger.tf<II><I>util.windows.tf>I<<II>type>II<fileinfo<II>mak>II<get_window_file, windows_run_timestamps, windows_stop_timestamps, window_timestamps<II>info>II<gezieltes Umleiten von Mudausgaben in Dateien und andere Fenster<II>req>II<lists.tf<II>comm>II<add_to_window_r, add_to_window_rc, move_to_window_r, add_to_window_g, move_to_window_g, write_to_window, show_window, remove_window<II>cfg>II<cfg_windows_show_xterm<II>version>II<util.windows.tf,v 1.17 2002/10/18 19:11:40 nieten (Mesirii@mg.mud.de)<II>var>II<window_options<II>fileinfo>II<util.windows.tf<II><I>
/set help___272623180=<I>showlist>I<<II>type>II<comm<II>mak>II</forEach, /showlist2<II>info>II<Zeigt die angegebene Liste in einem lesbaren Format an. Sublisten werden eingerueckt.<II>syn>II</showlist [-s] [-p] [-e] listenname<II>opt>II<-s Sublisten werden rekursiv dargestellt.@{N}-p Die Ausgabe wird mit more seitenweise dargestellt.@{N}-e Die Ausgabe erfolgt auf tferr.<II>fileinfo>II<lists.tf<II><I>
/set help___415101148=<I>nichts_unt>I<<II>type>II<misc<II>info>II<Loescht das aktuelle Detail. Dieser Befehl eignet sich zum Unterbrechen des Untersuchens. Mit /reunt kann das geloeschte Detail wieder geholt werden und mit dem Binding fuer /nichts_unt kann mit dem naechsten Detail fortgefahren werden.@{N}Dafuer sollte auch ein Keybinding in der Spielerdatei existieren.<II>see>II</delete_sub_details, /nichts_unt, /reunt<II>fileinfo>II<untroom.tf<II><I>
/set help___000062997=<I>line>I<<II>type>II<mak<II>info>II<Zeichnet eine Linie ueber den gesamten Bildschirm. Wenn ein Parameter angegeben wurde, wird dieser in der Zeile zentriert.<II>fileinfo>II<util.echo.tf<II><I>
/set help___012112101=<I>updateplayer>I<<II>type>II<comm<II>info>II<Aktualisiert die Spielerinformationen aus dem 'info'-Befehl. Das ist notwendig, um die Einschraenkungen bei den Wegen umzusetzen und um das spielerabhaengige und gildenabhaengige Makrofile zu laden. Bitte ausfuehren, wenn sich an den Properties was aendert.@{N}Der letzte Trigger muss dann updatePlayer2 aufrufen.<II>see>II<properties, einschraenkungen, dateisystem<II>fileinfo>II<mg_properties.tf<II><I>
/set help___004209702=<I>region>I<<II>type>II<mak<II>info>II<Makro das aequivalent zu cat <<EOF ... EOF inner Shell einen Bereich bis zum naechsten Marker (Parameter 2), literal evaluiert und dahinter die Bearbeitung des Makros fortsetzt.@{N}Besonders gut dazu zu gebrauchen, Trigger und Makros in anderen zu definieren, ohne Massen von % und $ zu verschwenden und nen Knoten im Hirn zu bekommen.@{N}Ausserdem wenn im Text dieses Bereichs diese TF Sonderzeichen (%,$) z.B. als Textformatierung genutzt werden.@{N}Die ganze Sache kann auch verschachtelt eingesetzt werden um beliebig tiefe Makrodefinitionshierarchien aufzubaun.@{N}Leider muss das aktuelle Makro als Parameter uebergeben werden, da keine Moeglichkeit besteht dieses innerhalb von /region zu ermitteln.<II>syn>II</return region('%0','MARKER')%;....Makrotext....MARKER<II>ex>II</def x = /return region('%0',EOF')%;/def y=/echo in y 1%;/echo in y 2%;EOF/echo in x<II>fileinfo>II<util.tf<II><I>
/set help___015097105=<I>hxaddlisttolist>I<<II>type>II<comm<II>func>II<hash<II>mak>II</paramparse, /makesub<II>info>II<Fuegt die als Wert (%variable) angebebene Liste unter dem angegebenen Schluessel zur ?Hashliste hinzu. Dabei wird die Liste modifiziert, um als Subliste innerhalb der eigentlichen Liste erhalten zu bleiben. Damit der Schluessel auch Leerzeichen enthalten kann, muessen die Parameter durch '&' getrennt werden.<II>syn>II</hxaddlisttolist listenname&schl ues sel&wertliste<II>var>II<%value<II>see>II</hgetlistvalueof, /addlisttolist, /makesub, /unmakesub, /haddlisttolist<II>fileinfo>II<lists.tf<II><I>
/set help___1358192319=<I>foreachway>I<<II>type>II<mak<II>info>II<Fuehrt fuer alle Wege, die den Parametern entsprechen, das Makro in \%nextmakro aus mit den Wegeknoten als Parameter.<II>ex>II</set nextmakro /echo von %1 zu %2%;@{N}/forEachWay * gilde%;@{N}/addh syn /forEachWay knoten1|* knoten2|*<II>fileinfo>II<way.tf<II><I>
/set help___030182981=<I>disable>I<<II>type>II<comm<II>list>II<disabled<II>info>II<Damit werden Wegstuecke temporaer gesperrt.<II>syn>II</disable Anfangsknoten Endknoten<II>see>II<enable, go, disabled, sperren<II>fileinfo>II<way.tf<II><I>
/set help___000000881=<I>ai>I<<II>type>II<comm<II>info>II<Makro das das uebergebene Attribut mit den zugehoerigen Informationen an das Kommando ai des Mappers schickt<II>fileinfo>II<mapper.tf<II><I>
/set help___1921413222=<I>automapper>I<<II>type>II<cfg<II>info>II<wenn auf 1 werden alle Bewegungen im Mud zum Erzeugen neuer Ausgaenge im Mapper benutzt. Da das aber leicht zu Fehlern fuehrt ist es standardmaessig ausgeschaltet.<II>see>II<walk<II>fileinfo>II<mapper.tf<II><I>
/set help___020100110=<I>find_usages_add_name>I<<II>type>II<mak<II>info>II<Fuegt alles ab dem 3. Parameter der Variablen %find_usage_list hinzu.<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___259241548=<I>loadlist>I<<II>type>II<comm<II>mak>II</addlisttosave, /createlist, /custom, /ifecho<II>info>II<Laedt die angegebene Liste aus der Datei 'listenname.list'. Dabei wird ihre Laenge als Veraenderungserkennung gemerkt. Es koennen die von ?/custom verstandenen Optionen verwendet werden. Falls /loadlist das File nicht laden kann, werden schon existente Listen unberuehrt gelassen, ansonsten wird eine neue Liste intialisiert.@{N}Gibt %error bei Fehler zurueck.<II>syn>II</loadlist [/custom-Optionen] listenname<II>see>II</savelist<II>fileinfo>II<lists.tf<II><I>
/set help___241463948=<I>disabled>I<<II>type>II<mak<II>info>II<Diese Liste enthaelt die temporaer (wird nicht gespeichert) gesperrten Wegstuecke in der Form Anfangsknoten_Endknoten.@{N}Der dazugehoerige Befehl testet, ob die angegebenen Wegstuecken gesperrt sind.<II>syn>II<$(/disabled Knoten1 Knoten2)<II>return>II<ueber /echo - 0 bei nicht gesperrt, ansonsten 1<II>see>II<enable, disable, go, sperren<II>fileinfo>II<way.tf<II><I>
/set help___2055633301=<I>wegmakros>I<<II>type>II<see<II>info>II<In den Wegen koennen ja beliebige Makros enthalten sein. Ein paar nuetzliche sind schon vorhanden.<II>see>II<lwo, npc, von, voff, wait, tri, utri, stop, continue, cw, cond_stop, cond_go, no_cond_go, break_tri, do_tri<II>fileinfo>II<way.tf<II><I>
/set help___029465125=<I>alitype>I<<II>type>II<var<II>fileinfo>II<way.tf<II><I>
/set help___031917446=<I>keys.tf>I<<II>type>II<fileinfo<II>mak>II<addlist, setkey, selectlastmode, delkey, setdesc, getdesc, gettdesc, gettcmd, key_press, keys_set_bindings<II>list>II<tasten<II>tut>II<Hilfe zur Tastenbelegung gibt es mit Esc-0@{N}@{N}Die Funktionen@{N}Esc-0     zeigt die F-Tasten-Belegung im aktuellen Modus an@{N}Esc-<x>   wechselt auf Modus 1-9@{N}Esc-d     schaltet den Display-Modus an/aus. Im Display-Modus@{N}werden nur Befehl und Beschreibung angezeigt.@{N}@{N}/setkey <b> <t> <befehl> <beschreibung>@{N}setzt fuer die Taste F<t> im Modus <b> den Befehl <befehl>@{N}Die Beschreibung wird auf <beschreibung> gesetzt.@{N}Beispiel: /setkey 1 4 /ladestab Stab laden@{N}(wenn Modus 1 aktiv ist (Esc-1), dann bewirkt ein@{N}Druck auf F4, dass "/ladestab" ausgefuehrt wird.@{N}In der Uebersicht (Esc-0) wird "Stab laden" angezeigt.)@{N}bisher nur Befehle aus einem Wort moeglich.@{N}@{N}/delkey <b> <t>@{N}loescht den Befehl fuer die Taste F<t> im Modus <b>@{N}Beispiel: /delkey 1 4@{N}(macht o.g. Beispiel rueckgaengig)@{N}@{N}/setdesc <b> <beschreibung>@{N}setzt die Beschreibung fuer den Modus <b>.@{N}@{N}/set_mode <i>|<desc>@{N}schaltet auf den Modus mit der Nummer i oder mit der@{N}Beschreibung desc um (letzteres noch nicht implementiert!)<II>info>II<@{N}Mehrfach-Tastenbelegungen.@{N}ermoeglicht, die F-Tasten mehrfach zu belegen, und durch einfache Tastenkombinationen zwischen den Belegungen hin- und herzuschalten.<II>req>II<lists.tf<II>misc>II<default -c mudverzeichnis<II>cfg>II<keys_list_location, keys_bindings, keypad_keys<II>version>II<keys.tf,v 1.17 2002/12/06 15:50:31 mh14 (Olli@mg.mud.de)<II>var>II<keys_dmode, keys_edit_mode, tasten_slist<II>see>II<setkey, delkey, setdesc, set_mode<II>fileinfo>II<keys.tf<II><I>
/set help___1383053538=<I>getvalueof>I<<II>type>II<func<II>info>II<Liefert den ersten Wert mit diesem Schluessel zurueck.<II>syn>II</getvalueof listenname schluessel<II>return>II<erster zum Schluessel passender Wert oder %error bei Fehler als Rueckgabewert und in %value<II>ex>II</getvalueof waffen dolch<II>var>II<%value<II>fileinfo>II<lists.tf<II><I>
/set help___015097108=<I>team_info_color>I<<II>type>II<func<II>info>II<Hilfsfunktion, die die Faerbung von Lebens-, Magiepunkten und Vorsicht vornimmt.<II>syn>II</team_info_color wert idx_maxpunkte<II>return>II<String mit Farbe und Wert<II>fileinfo>II<team.tf<II><I>
/set help___000068317=<I>wege>I<<II>type>II<see<II>list>II<disabled, often, often2<II>info>II<Die Wege des Systems werden in einer grossen Liste (?ways) gespeichert. Sie werden durch Anfangs- und Endknoten und gewisse Einschraenkungen definiert. Die Eingabe der Wege kann direkt im Mud erfolgen. Es ist also nicht notwendig, die Listen von Hand zu bearbeiten (und auch nicht zu empfehlen!!!). Die Eingabe der Wege erfolgt einfach durch das einmalige Ablaufen des Weges. Wenn Sonderbewegungsbefehle entsprechend beruecksichtigt wurden, sind danach beide Wege (Hin- und Rueckweg) verfuegbar. Das Abspeichern eines Weges erfolgt mit /end (siehe dort).@{N}Es gibt mehere Kommandos zum Verwalten der Wege, die alle dieselbe Syntax haben:@{N}/kommando anfangsknoten|* endknoten|* @{B}(* * ist unzulaessig)@{n}@{N}ACHTUNG: Die Editierkommandos speichern die Aenderungen sofort ab!<II>comm>II<showway, editway, delway<II>fileinfo>II<way.tf<II><I>
/set help___004021910=<I>knoten>I<<II>type>II<see<II>list>II<lastpoints, nodealias, ways, toidx, fromidx, often, often2, tanken /addh see wege, tanken, spezialknoten, portale, knotenaliase<II>info>II<Die Knoten des Wegesystems halten dieses zusammen. Zwischen ihnen verlaufen die Wege. Die Knoten werden als Raeume erkannt, sie sind Anfangs-, Zwischen- und Zielpunkte jedes berechneten Weges. Die Knoten werden in allen Wegelisten abgespeichert.@{N}Fuer die Knoten gelten bestimmte Namenskonventionen:@{N}In den Knotennamen sollten nur Buchstaben, Zahlen und Unterstriche stehen.@{N}Kneipe: Kname, Laden: Lname, Portale tname, Seherhaeuser: ein paar Buchstaben des Namens des Sehers (kleingeschrieben)@{N}Es gibt ein paar reservierte Namen: tport, laden, kneipe.@{N}Bitte haltet Euch an die Konventionen, sie sind sehr wichtig.@{N}Fuer jeden Knoten kann mit /setali ein Aliasname vergeben werden, der dann ganz normal genutzt werden kann.@{N}Jeder der Knoten kann mittels /wo als Raum im Mud erkannt werden. Mit /lp kann man auch Knoten per Hand setzen, das sollte aber nicht noetig sein. Die Anzeigevariable fuer die Knoten lautet %showpoint. Diese zeigt auch die ggf. vorhandenen Aliase korrekt an.<II>comm>II<shownode, setali, appendnode, addnode, delnode, wo<II>var>II<showpoint, lastpoint<II>fileinfo>II<way.tf<II><I>
/set help___021115116=<I>set_status_var_string>I<<II>type>II<mak<II>syn>II</set_status_var_string varname defaultwert|varname breite text1 text2 text3 ...<II>ex>II</set_status_var_string p_align p_align 3 heilig gut nett neutral frech boese satanisch<II>fileinfo>II<status.tf<II><I>
/set help___029180501=<I>addsave>I<<II>type>II<comm<II>list>II<${world_character}tosave<II>info>II<Fuegt die als Parameter angegebene Variable zu einer Liste hinzu, damit sie spaeter mit abgespeichert wird.<II>var>II<tosave, _temp<II>see>II<loadsaved, saveall<II>fileinfo>II<worldconnect.tf<II><I>
/set help___014105110=<I>window_options>I<<II>type>II<var<II>info>II<Mit dieser Variable koennen zusaetzliche Parameter an xterm bzw. cmd uebergebene werden. Dazu muss sie vor dem Aufruf von ?/show_window gesetzt werden.<II>ex>II<-bg black -fg white<II>fileinfo>II<util.windows.tf<II><I>
/set help___000468623=<I>debug>I<<II>type>II<mak<II>info>II<Macht nur ein /echo der Parameter, wenn die Variable 'debug' auf 1 gesetzt ist.<II>var>II<debug<II>fileinfo>II<util.debug.tf<II><I>
/set help___000525235=<I>props>I<<II>type>II<list<II>info>II<Liste der Regexp-Pattern die zum Auslesen der "info" Ausgabe genutzt werden<II>fileinfo>II<mg_properties.tf<II><I>
/set help___017109099=<I>remove_from_cache>I<<II>type>II<mak<II>info>II<Entfernt alle Wege aus dem Cache, die den angegebenen Knoten oder Teilweg enthalten.<II>ex>II<'/remove_from_cache knotenname' oder '/remove_from_cache knoten1 knoten2'.<II>see>II<cache, clear_cache, show_cache<II>fileinfo>II<way.tf<II><I>
/set help___015118107=<I>movement_marker>I<<II>type>II<var<II>fileinfo>II<way.tf<II><I>
/set help___000000887=<I>ao>I<<II>type>II<comm<II>list>II<often<II>info>II<fuegt den zuletzt gegangenen Weg zur Liste der fest gespeicherten Wege hinzu. Dabei wird die Dimension des Weges mit abgefragt.<II>see>II<dimensionen<II>fileinfo>II<way.tf<II><I>
/set help___011101121=<I>keypad_keys>I<<II>type>II<cfg<II>info>II<Belegungen für Keypad@{N}0-9,+,-,*,/ sind fuer den Nummernblock mit Makros belegbar@{N}/addh update /keys_set_keypad<II>fileinfo>II<keys.tf<II><I>
/set help___033610245=<I>profile>I<<II>type>II<mak<II>info>II<Fuehrt ein Makro bzw. ein Stueck Code so oft aus wie angegeben und bestimmt die Zeit in Millisekunden, die dafuer notwendig war<II>syn>II</profile count makro or code piece<II>ex>II</profile 1000 /addtolist test_list testkey testvalue@{N}/profile 100 /x@{N}/profile 1000 /test strcat("abc","def")<II>see>II<profile_wrap<II>fileinfo>II<util.timer.tf<II><I>
/set help___014097108=<I>make_html_file>I<<II>type>II<comm<II>func>II<tfio<II>info>II<Erzeugt ein HTML-Hilfefile aus dem uebergebenen Hilfeeintrag, moeglichst eine Makrodatei, aber auch ein einzelnes Kommando ist moeglich. An den uebergebenen Namen wird ein .html angehaengt. Es werden auch die in der Hilfebeschreibung referenzierten im selben File definierten Makros mit auf die Seite gepackt. Ein '+' vor dem Namen erzeugt eine Entwicklerversion (ausfuehrlicher).<II>syn>II</make_html_file [+]macro(datei)<II>comm>II<hilfe_html<II>var>II<%html_eval_list, %html_full,<II>fileinfo>II<help.tf<II><I>
/set help___014105116=<I>find_in_tfpath>I<<II>type>II<mak<II>info>II<Sucht das uebergebene File im TFPATH<II>syn>II<find_in_tfpath [verz/]filename<II>ex>II<find_in_tfpath way.tf<II>fileinfo>II<util.tf<II><I>
/set help___269809731=<I>ret_vars>I<<II>type>II<mak<II>info>II<Gibt alle uebergebenen Variablen als String zurueck der diese ueber ein /test %? wieder als lokale Variablen setzt<II>syn>II</return ret_vars('var1',...,'varN')<II>ex>II</let a=5%;/let c=3%;/return ret_vars('a','c')@{N}dann /test %?%;/echo %a %c -> 5 3<II>fileinfo>II<util.tf<II><I>
/set help___034345350=<I>sprintf>I<<II>type>II<func<II>info>II<Ersetzt die nummerierten #i im uebergebenen String durch die i-ten Parameter, die sprintf uebergeben wurden.<II>syn>II</test sprintf("String",parameters,...)<II>return>II<String mit Ersetzungen<II>ex>II</test sprintf("#1 Bytes von #2 gelesen",100,"test.txt")<II>fileinfo>II<util.sfunc.tf<II><I>
/set help___014097109=<I>make_help_html>I<<II>type>II<comm<II>mak>II</tokenize, /make_html_file<II>info>II<Erzeugt alle Hilfe-Datein als HTML in den Verzeichnissen '%makdir/help/global' fuer den Normaluser und '%makdir/help/expert' fuer den Programmierer<II>var>II<%makdir<II>fileinfo>II<help.tf<II><I>
/set help___160437836=<I>savehrlist>I<<II>type>II<comm<II>mak>II</savehrsublist, /custom<II>info>II<Speichert die angegebene Liste in menschenlesbarer Form. Die Datei heisst 'listenname.hr.list'. Es koennen die von ?/custom verstandenen Optionen verwendet werden.@{N}Achtung, /savehrlist verwendet regmatch(), d.h. %P1 etc. aendern ihre Werte!@{N}Falls beim Speichern ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</savehrlist [/custom-Optionen] listenname<II>var>II<%temp_list, %temp_handle, regmatch-Variablen<II>see>II</savelist, tfio, /custom<II>fileinfo>II<lists.tf<II><I>
/set help___000057532=<I>beat>I<<II>type>II<mak<II>info>II<Fuer wiederkehrende Aufgaben aehnlich eines cron-Jobs wird festgelegt, alle wieviel (n) Sekunden sie ausgefuehrt werden (Parameter), dann kann der Hook 'beat_n' mit den entsprechenden Makros gefuellt werden, die zu diesem Zeitpunkt ausgefuehrt werden sollen.@{N}Gesteuert wird das ganze durch die Variablen 'do_beat', die alle Beats anhalten kann (0) oder wieder laufen lassen (1), und durch 'do_beat_n', die das ebenso fuer die einzelnen Beats steuert.@{N}In der Variablen 'beat_pid_n' steht die pid des letzten repeats des beat.<II>syn>II</beat repeat_sek run_now(1|0)<II>ex>II<Aller 10 Sekunden ein Beep /beat 10 1%;/add_to_hook beat_10 /echo Beep<II>var>II<do_beat, do_beat_n, beat_pid_n<II>see>II<hooks,repeat<II>fileinfo>II<util.repeat.tf<II><I>
/set help___000060731=<I>gobk>I<<II>type>II<comm<II>info>II<Geht bis zum letzten bekannten Knoten zurueck, sofern ab diesem nur Richtungsbefehle verwendet wurden.<II>see>II<go, wegeingabe<II>fileinfo>II<way.tf<II><I>
/set help___013097105=<I>mapper_prefix>I<<II>type>II<cfg<II>info>II<Praefix der Eingaben markiert, die auch an den Mapper geschickt werden sollen<II>fileinfo>II<mapper.tf<II><I>
/set help___015111105=<I>quote_multiline>I<<II>type>II<hook<II>info>II<Dieser Hook ermoeglicht auch mehrzeilige Makros (vor allem wohl /def) mittels Cut&Paste in einem laufenden TF. Dazu muss die erste Zeile mit ":/" anfangen und mit "\" aufhoeren. Danach werden diese und alle weiteren Zeilen solange in einem Puffer aneinandergehaengt, bis eine Zeile nicht mehr mit "\" aufhoert. Anschliessend wird der im Puffer stehende Code ausgefuehrt.@{N}Das Verfahren sieht dann in den meisten Faellen so aus:@{N}- Makrodefinition (mit Maus) markieren@{N}- Ins TF-Fenster wechseln.@{N}- ':' tippen, dann pasten (ueblicherweise mittlere Maustaste)@{N}Anmerkung: Beginnt eine Folgezeile mit "/", so wird sie als TF-Makro aufgefasst und direkt ausgefuehrt; sie landet also nicht im Zwischenpuffer.@{N}Wer fuer den Beginn eines mehrzeiligen Makros ein anderes Zeichen als ':' bevorzugt, kann dies vor dem Laden von 'util.quote.tf' (ggf. neu laden) in %quote_multiline_start schreiben.<II>var>II<%quote_multiline_start<II>fileinfo>II<util.quote.tf<II><I>
/set help___013097099=<I>hasortforeach>I<<II>type>II<comm<II>func>II<astart, alen<II>mak>II</aclear, /hforEach, /aput, /asortForEach2, /asortForEach3<II>info>II<Erfuellt dieselbe Funktion wie /hforEach fuer Hashlisten, nur dass die Elemente sortiert bearbeitet werden. Dabei kann in der Variablen %sort_alg (moeglichst als lokale Var) der Sortieralgorithmus eingestellt werden ('asort' oder 'amsort'), sowie in der Variablen %comp_func die Vergleichsfunktion ('asicmp', 'ascmp', 'ancmp').<II>syn>II</hasortForEach listenname k[v] /makroname<II>var>II<%sort_alg, %comp_func<II>see>II</hforEach, asort, amsort, asicmp, ascmp, ancmp, /asortForEach<II>fileinfo>II<lists.tf<II><I>
/set help___000516925=<I>pause>I<<II>type>II<mak<II>info>II<Hilfsmakro das das laestige Aufsplitten eines Makros in Teilstuecke die mit Pausen voneinander getrennt werden sollen (wait) erledigt@{N}Dabei muss der Makroname (%0), die Pausenzeit und die Parameter des Makros angegeben werden (damit diese von dem aufgeteilten Teilen weiter genutzt werden koennen, ggf. koennen noch Namen von lokalen Variablen angegeben werden, die ebenfalls weitergereicht werden sollen<II>syn>II</return pause('%0',time,'%*'[,'localvarname1',...,'localvarnameN']) (time: Sekunden oder hh:mm:ss, ohne ')<II>ex>II<@{N}/def test_pause = \@{N}/let a=teststring%;\@{N}/echo Start Test%;\@{N}/return pause('%0',3,'\%*')<II>fileinfo>II<util.tf<II><I>
/set help___263952837=<I>my_quote>I<<II>type>II<comm<II>info>II<Erlaubt es, mehrzeiligen Text mit Zeilenumbruechen ins tf zu pasten, so dass jede Zeile mit dem Praefix ans Mud gesendet wird. Beenden mit ESC-q.<II>syn>II</my_quote [<prefix>] (ESC-q)<II>ex>II</my_quote sage <Enter druecken>, dann Text pasten und mit Escape-q beenden<II>see>II</spare_linefeeds, /quote_multiline<II>fileinfo>II<util.quote.tf<II><I>
/set help___028108095=<I>do_highlight_untroom_actions>I<<II>type>II<cfg<II>info>II<Einschalten des Hervorhebens besonderer Worte (Aktionen) aus %highlight_untroom_actions im Ausgabetext.<II>see>II<do_highlight_untroom_actions, untroom_highlight_action_attr<II>fileinfo>II<untroom.tf<II><I>
/set help___034961286=<I>util.tf>I<<II>type>II<fileinfo<II>func>II<vlines<II>mak>II<setos, is_win, showchars, artikel_entfernen, test_quiet, nop, min, max, lazym, lazyf, _read, shread, killall, kill_process, region, pause, ifdef, ifdo, deprecated, check_deprecated, returns, ret_vars, find_in_tfpath<II>list>II<${world_character}tosave, ${world_character}saved, tosave<II>changes>II<0.00 /echo2 zur Ausgabe von Newlines mit einem /echo.@{N}1.00 /completion und Stack (/push, /pop).@{N}/timer zum Zeitmessen im Sekundenbereich.@{N}1.01 /myread fuer Keyboardeingaben von asynchronen Makros.@{N}/tokenize fuer das Aufspalten von Strings.@{N}1.02 /shread als funktionierenden Workaround fuer das Read in asynchronen Makros.@{N}1.04 Fuer /shread ist jetzt auch ein Binary fuer Windows vorhanden, deshalb musste auch der Dateiname der Ergebnisdatei auf 8+3 angepasst werten.@{N}Hilfsfunktionen fuer die Nutzung world-lokaler Variablen hinzugefuegt (siehe ?world_local).@{N}Die Trigger zum Auslesen der Mudausgabe eines oder mehrerer Kommandos wurden in 'util.tf' verschoben (siehe /catch_output).@{N}1.05 Die Funktionen zum Umleiten von Mudausgaben in andere Fenster sowie die Ersetzung von Abkuerzungen in gesendetem Text wurden von der ${world_host}/comm.tf in die util.tf verschoben, da sie nicht mudspezifisch sind.@{N}/wecho etwas erweitert.<II>info>II<make_dos_path<II>req>II<lists.tf<II>comm>II<send_fast, wecho, xtitle, rename_mac, purge_renamed, remove_packet, edit_macros<II>version>II<util.tf,v 1.45 2003/07/25 14:59:22 olm (Mesirii@mg.mud.de)<II>hook>II<CONNECT, DISCONNECT, SIGHUP<II>var>II<echolist, loadall, wecho<II>over>II<dc, quit<II>fileinfo>II<util.tf<II><I>
/set help___269219148=<I>pub_test>I<<II>type>II<comm<II>mak>II<pub_extract<II>info>II<Startet den Test eines ausgewaehlten Getraenks bzw einer ausgewaehlten Speise. Zuerst werden alle Speisen angezeigt.<II>ex>II<"/pub_test [Kneipenname]" Wenn nichts angegeben wird, wird die %pub_temp_list der zuletzt initialisierten Kneipe genommen.<II>see>II<pub_init<II>fileinfo>II<uselists.tf<II><I>
/set help___000489614=<I>ifdef>I<<II>type>II<mak<II>info>II<Conditional def, nur wenn der Ausdruck, der als 1. Parameter uebergeben wird 1 ist wird das /def gemacht<II>syn>II</ifdef expr normal def parameters<II>ex>II</ifdef is_file_loaded("status.tf") sl_lp = /initvar p_lp%; .... @{N}/ifdef p_guild=~"zauberer" -t"bla Hand Eis" zaubi_hand_eis = ....<II>fileinfo>II<util.tf<II><I>
/set help___014111105=<I>do_show_origin>I<<II>type>II<mak<II>mak>II</echo2<II>info>II<Zeigt die Herkunft des Details an. Dies ist mit ?/show_origin auch ausschaltbar.<II>cfg>II<show_origin<II>var>II<%show_origin<II>see>II</show_origin<II>fileinfo>II<untroom.tf<II><I>
/set help___003753569=<I>delkey>I<<II>type>II<mak<II>list>II<tasten<II>info>II<loescht eine eingetragene Tastenbelegung wieder.<II>syn>II</delkey Belegung Taste<II>fileinfo>II<keys.tf<II><I>
/set help___2119714299=<I>set_style>I<<II>type>II<comm<II>info>II<Setzt das Displayattribut der Herkunftsanzeige.<II>syn>II</set_style attribut<II>see>II<attributes, herkunftsanzeige, untroom.tf<II>fileinfo>II<untroom.tf<II><I>
/set help___004350807=<I>unsetw>I<<II>type>II<mak<II>mak>II<getw, listw, setw, echow<II>info>II<Loescht die Variable ${world_name}_%1, die mit /setw auf einen Wert gesetzt wurde.<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___2073891841=<I>loadarray>I<<II>type>II<mak<II>info>II<Laedt ein File (Feldname.ary) Zeile fuer Zeile in ein Feld. Es koennen die von ?/custom verstandenen Optionen verwendet werden.<II>syn>II</loadarray [custom-Optionen] feldname<II>return>II<0 bei Fehler, sonst 1<II>ex>II</loadarray -l help_tips<II>see>II</savearray<II>fileinfo>II<lists.tf<II><I>
/set help___233438244=<I>addpoint>I<<II>type>II<mak<II>info>II<Liest die aktuelle Raumbeschreibung ein, begrenzt sie bis einschliesslich der Ausgaenge und speichert sie in %fulldetail.<II>var>II<%fulldetail, %getpoint_trig<II>fileinfo>II<way.tf<II><I>
/set help___004260012=<I>shread>I<<II>type>II<mak<II>mak>II<sh, load<II>info>II<Ersetzt read, tfread, _read in asynchronen Makros. Es ist ein boeser Workaround, der mit dem Shellscript 'tfread' arbeitet, das in dem Verzeichnis %makdir liegen muss. Ansonsten funktioniert es wie das normale /read. Der gelesene Wert steht ausserdem in 'read_value'.<II>syn>II</shread Prompttext<II>return>II<der eingelesene Wert.<II>hook>II<hresume_shread<II>var>II<read_value, makdir<II>fileinfo>II<util.tf<II><I>
/set help___013111101=<I>count_entries>I<<II>type>II<func<II>func>II<isVar<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>info>II<Liefert die Anzahl der Eintraege in der angegebenen Liste. Falls keine Liste uebergeben wurde, wird %error zurueckgegeben.<II>syn>II</count_entries (liste|listenname)<II>return>II<ueber /result<II>ex>II</let cnt=$(/count_entries demo_list)@{N}/test cnt:=count_entries(demo_list)<II>fileinfo>II<lists.tf<II><I>format_number>I<<II>type>II<mak<II>info>II<formatiert eine grosse Zahl mittels angehaegter k bzw. M und den restlichen vorangehenden Stellen<II>syn>II</status_get_config_name varname [c|t|beliebig] beliebiger suffix<II>ex>II</format_number 1000 -> 1k; /format_number 1000000 -> 1M<II>fileinfo>II<status.tf<II><I>
/set help___004255580=<I>tab_fl>I<<II>type>II<comm<II>info>II<Setzt zum angegebenen Angriffsbefehl automatisch die Fluchtrichtung in entgegengesetzer Richtung, falls moeglich. (Dazu wird die Liste extramoves verwendet.) Falls "vorsicht.tf" geladen ist, wird dazu /fl verwendet.<II>syn>II</tab_fl Richtung<II>ex>II</tab_fl no -> tab no, fluchtrichtung sw<II>fileinfo>II<team.tf<II><I>
/set help___003712833=<I>askway>I<<II>type>II<comm<II>info>II<Damit kann man den Zustand 'askway' umschalten. Wenn askway eingeschaltet ist, wird der Weg berechnet und angezeigt. Dann wird auf eine Eingabe gewartet. Wenn diese (n)ein ist, wird der Weg nicht gegangen, ansonsten (Return) wird der Weg gegangen.<II>var>II<askway<II>see>II<go<II>fileinfo>II<way.tf<II><I>
/set help___032272671=<I>mapinfo>I<<II>type>II<comm<II>info>II<entsprechend des uebergebenen Parameters, holt sich /mapinfo die mudspezifischen Kommandos aus der liste %mapinfo und laesst diese vom Mud ausfuehren. Der Ergebnistext wird von spezifischen Makros geparst, die dann die Werte an den Mapper senden<II>req>II<customize.tf, way.tf<II>var>II<mapper, fulldetail, mapinfo<II>fileinfo>II<mapper.tf<II><I>
/set help___000501594=<I>kkwer>I<<II>type>II<mak<II>info>II<Liest alle Spieler ein, die ein gewisses Kriterium erfuellen (siehe Hilfe im MorgenGrauen zu kkwer. Das Ergebnis wird in die Liste kkwer geschrieben.<II>syn>II</kkwer [kriterium]<II>ex>II</kkwer bei olli<II>fileinfo>II<mg_properties.tf<II><I>
/set help___012117097=<I>purge_reload>I<<II>type>II<comm<II>mak>II<hook_reload, eval_hook<II>info>II<Loescht den Speicher und laedt alle mit bisher geladenen Makrofiles neu.@{N}Alle Variablen werden auch abgespeichert und neu geladen.<II>see>II<mload, purge, load<II>fileinfo>II<loading.tf<II><I>
/set help___270948987=<I>saveways>I<<II>type>II<info<II>info>II<Speichert die Wegelisten (z.B. nach Aenderungen) ab (wegen der Konsistenz).<II>fileinfo>II<way.tf<II><I>
/set help___035287125=<I>wo_raum>I<<II>type>II<comm<II>info>II<Zeigt die Raummeldung an, die das letzte, /wo, /end, /wgo, /addnode verarbeitet hat<II>fileinfo>II<way.tf<II><I>
/set help___015108108=<I>delikeyandvalue>I<<II>type>II<comm<II>info>II<Loescht das Paar (Schluessel und Wert) am Index. Der Index beginnt bei Null!<II>syn>II</delikeyandvalue listenname index<II>return>II<%error bei Misserfolg (Index zu gross) als Rueckgabewert und in %value<II>var>II<%value<II>see>II<index, /deletekeyandvalue, /deleteallkeys<II>fileinfo>II<lists.tf<II><I>
/set help___2141252907=<I>pub_kaufe>I<<II>type>II<comm<II>mak>II<pub_got<II>info>II<Startet das Testen einer gewaehlten Speise bzw. eines Getraenks. Dabei werden die Zeit bis zum Erhalt gestoppt und die aktuellen LP und MP gesichert. Die Weiterverarbeitung erfolgt durch /pub_got nach Erhalt der Tanke.<II>var>II<pub_name, pub_lp, pub_mp<II>see>II<pub_init, pub_test<II>fileinfo>II<uselists.tf<II><I>
/set help___034075798=<I>shorten>I<<II>type>II<mak<II>info>II<Wandelt den uebergebenen Weg aus dem Format 'o%;w%;w%;gehe nach oben%;s%;s%;s%;' in ',o,2w,gehe nach oben,3s' um. Dieses kann mit /walk oder direkt ueber den Sendhook genutzt werden.<II>syn>II</shorten variablenname<II>fileinfo>II<way.tf<II><I>
/set help___003886913=<I>go_way>I<<II>type>II<mak<II>mak>II<go_way3, gobk<II>info>II<Erstellt aus der Abfolge der Knoten den eigentlichen Weg, testet ggf. ueber 'askway', ob man den Weg gehen will, geht zum letzten bekannten Knotenpunkt und startet von dort aus das Ablaufen des Weges. Vorher wird noch der Ultrakurzmodus  mittels ?mud_shortest_output eingeschaltet und vor dem letzten Befehl im Weg der Kurzmodus (?mud_short_output) eingeschaltet.<II>var>II<askway, min_way, real_way, temp_way, min_steps, fulldetail, verify<II>fileinfo>II<way.tf<II><I>
/set help___030844219=<I>getdesc>I<<II>type>II<mak<II>info>II<liefert die Beschreibung eines Modus zurueck.<II>syn>II</getdesc Modus<II>return>II<Beschreibung<II>fileinfo>II<keys.tf<II><I>
/set help___012104116=<I>check_punkte>I<<II>type>II<comm<II>info>II<Aktualisiert die Spielereigenschaften (punkte)<II>fileinfo>II<mg_properties.tf<II><I>
/set help___011120109=<I>expand_comm>I<<II>type>II<mak<II>info>II<Liefert den Wert, der in der Liste 'comm_abbr' zum Parameter steht, ansonsten den Parameter selbst.<II>fileinfo>II<way.tf<II><I>
/set help___000000110=<I>n>I<<II>type>II<comm<II>info>II<Wiederholt den als Restparameter uebergebenen String Parameter1-mal. Dabei ist es egal, ob es sich um Mud- oder tf-Kommandos handelt. Der Zaehler von /n (Variable n) kann auch im Code genutzt werden.<II>ex>II</n 5 nimm alles aus leiche %n (oder besser /n 5 nl %n)<II>fileinfo>II<util.repeat.tf<II><I>
/set help___019109116=<I>format_success_text>I<<II>type>II<mak<II>info>II<Formats the given Text according to the Variables CFG_GUI_FORMAT_ATTR_*.<II>cfg>II<CFG_GUI_FORMAT_ATTR_*<II>ex>II</format_success_text success Done -> formatted text done (for /echo -p) according to the CFG_GUI_FORMAT_ATTR_SUCCESS<II>fileinfo>II<util.echo.tf<II><I>
/set help___013111108=<I>vorsicht_null>I<<II>type>II<var<II>info>II<steuert, ob die Vorsicht beim Fliehen für 10 Sekunden auf 0 gesetzt wird.<II>see>II<testvorsicht, exec_vorsicht<II>fileinfo>II<vorsicht.tf<II><I>
/set help___011104111=<I>show_window>I<<II>type>II<comm<II>info>II<Zeigt das als Parameter angebegene Fenster an (falls es geschlossen wurde). In der Variable ?%window_options koennen zusaetzliche Parameter fuer xterm bzw. cmd uebergeben werden.<II>ex>II</show_window Tod<II>fileinfo>II<util.windows.tf<II><I>
/set help___015101101=<I>hgetlistvalueof>I<<II>type>II<comm<II>mak>II</hgetvalueof, /unmakesub<II>info>II<Liefert den Wert des angegebenen Schluessels als Liste zurueck. D.h. wenn er vorher mit /haddlisttolist hinzugefuegt wurde, ist es notwendig, dies rueckgaengig zu machen. Die Ergebnisliste ist eine normale Liste. Sie kann mit@{N}/set listenname=%value@{N}oder@{N}/set listenname=$[hgetlistvalueof(...)]@{N}gesichert werden.<II>syn>II</hgetlistvalueof listenname schluessel<II>return>II<in %value und per /return<II>ex>II<Die Zeilen@{N}@{}   /hgetlistvalueof waffen_list schwerter@{N}@{}   /set schwerter_list=%value@{N}und@{N}@{}   /set schwerter_list=$[hgetlistvalueof("waffen_list", "schwerter")]@{N}speichern beide die Subliste 'schwerter' der Hashliste 'waffen_list' in der Variablen %schwerter_list.<II>var>II<%value<II>see>II</hgetvalueof, /getlistvalueof, /haddlisttolist, /hxaddlisttolist<II>fileinfo>II<lists.tf<II><I>
/set help___012102109=<I>cfg_var_name>I<<II>type>II<mak<II>info>II<Liefert einen Variablennamen fuer die angegebenen Config-Hierarchie-Namen.<II>syn>II</cfg_var_name Config-Hierarchie-Namen<II>return>II<Variablenname CFG_* (alles grossgeschrieben)<II>see>II<cfg_var_name, cfg_list_name<II>fileinfo>II<config.tf<II><I>
/set help___011102097=<I>cfg_echogag>I<<II>type>II<mak<II>info>II<Gibt je nach CFG_ECHO_GAG_LEVEL den uebergebenen String farbig, normal oder gar nicht aus.<II>syn>II</cfg_echogag configname %*<II>ex>II</set CFG_MG_ZAUBERER_ZSCHILD_ECHO_ATTR=Cblue@{N}/cfg_echogag MG_ZAUBERER_ZSCHILD Zauberschild<II>fileinfo>II<config.tf<II><I>
/set help___011102104=<I>tf_vorsicht>I<<II>type>II<var<II>info>II<Variable, die anzeigt, ob TF die Steuerung der Flucht komplett uebernimmt, oder ob auf die Trigger aus dem Mud geachtet wird.<II>fileinfo>II<vorsicht.tf<II><I>
/set help___011104112=<I>check_props>I<<II>type>II<comm<II>info>II<Aktualisiert die Spielereigenschaften (info)<II>fileinfo>II<mg_properties.tf<II><I>
/set help___075615045=<I>renamenode>I<<II>type>II<comm<II>list>II<lastpoints, ways, fromidx, toidx, often, disabled, tanken, often2<II>info>II<Benennt den angegebenen Knoten um.<II>syn>II</renamenode knoten neuername<II>fileinfo>II<way.tf<II><I>
/set help___020097108=<I>create_help_filelist>I<<II>type>II<comm<II>info>II<Erzeugt in help_tffiles eine Liste aller Files unterhalb der uebergebenen Verzeichnisse, mit ".tf" aufhoeren. Zugehoerige i18n-, def- und cfg-Files werden ebenfalls in die Liste aufgenommen.<II>syn>II</create_help_filelist Pfad1 [Pfad2 ...]<II>ex>II</create_help_filelist %TFPATH<II>see>II</create_help<II>fileinfo>II<help.tf<II><I>
/set help___692512680=<I>watch_loop>I<<II>type>II<mak<II>mak>II</watch_check_var<II>list>II<watch_list<II>info>II<Falls ?%watch_active und %watch_time beide nicht 0 sind, ruft fuer jede in ?watch_list aufgefuehrte Variable ?/watch_check_var auf. Danach wird %watch_list aktualisiert. Anschliessend ruft /watch_loop sich mit einer Verzoegerung von %watch_time Sekunden selber wieder auf.<II>var>II<%watch_active, %watch_time<II>fileinfo>II<util.debug.tf<II><I>
/set help___028095099=<I>cfg_mud_hit_points_echo_text>I<<II>type>II<cfg<II>info>II<Ausgabetext fuer Hitpointausgabe<II>fileinfo>II<mg_properties.tf<II><I>cfg_mud_hit_points_echo_attr>I<<II>type>II<cfg<II>info>II<Farbe fuer Hitpointausgabe<II>fileinfo>II<weapon2.tf<II><I>
/set help___2026806467=<I>inv_check>I<<II>type>II<mak<II>info>II<Setzt einige Variablen (inv_*) je nachdem, ob gewisse Dinge im Inventory vorhanden sind. Nach Beendigung der Pruefung wird der Hook inventory_update ausgefuehrt.<II>syn>II</inv_check<II>ex>II</inv_check<II>fileinfo>II<inventory.tf<II><I>
/set help___015116101=<I>getdlistvalueof>I<<II>type>II<comm<II>mak>II</getdvalueof, /makelistofvalue, /unmakesub<II>info>II<Holt die Subliste, die dem Schluessel zugeordnet ist, aus der Liste und loescht sie.<II>syn>II</getdlistvalueof listenname schluessel<II>return>II<Subliste, die dem Schluessel zugeordnet ist oder %error bei Misserfolg als Rueckgabewert und in %value<II>var>II<%value<II>see>II</getlistvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___277571372=<I>try_load>I<<II>type>II<mak<II>syn>II</try_load (dir|.) file possible_suffix_list<II>ex>II</try_load ~/makros loading .tf .mak<II>fileinfo>II<loading.tf<II><I>
/set help___016110103=<I>einschraenkungen>I<<II>type>II<see<II>info>II<Die Einschraenkungen fuer die Wege sind wie folgt anzugeben:@{N}all - keine Einschraenkungen.@{N}spielername - nur derjenige kann diesen Weg benutzen.@{N}property:wert - diejenigen koennen den Weg benutzen, deren Properties dem angegebenn Wert entsprechen. Dabei reichen die zur Identifikation notwendigen Buchstaben (z.B. lev:10 fuer Level > 10); bei numerischen Properties wird angenommen, dass der Wert der Property groesser als der angegebene sein muss. Ansonsten muessen die Wertangaben mit dem Wert der Property mindestens den Anfangsbuchstaben gemeinsam haben. Also aufpassen mit den Wertangaben.@{N}logischer Ausdruck mit Properties: Dieser wird einfach ausgewertet, alsoalle Properties ausschreiben und bei der Konstruktion aufpassen.<II>ex>II<'lev:10 (level>10)' oder '((p_guild=~"chaos")&(p_guild_level>6))' usw.<II>see>II<properties, wege, mud_properties<II>fileinfo>II<way.tf<II><I>
/set help___017110109=<I>window_timestamps>I<<II>type>II<mak<II>info>II<Funktion die an eine Beat-Hook gehaengt wird um Timestamps in alle Logs zu schreiben, das geschieht nur wenn man eine aktive world hat und die Variable windows_run_timestamps auf 1 steht.<II>see>II<windows_run_timestamps<II>fileinfo>II<util.windows.tf<II><I>
/set help___274887613=<I>sreplace>I<<II>type>II<mak<II>see>II<substitution<II>fileinfo>II<lists.tf<II><I>
/set help___015095099=<I>tf_min_vorsicht>I<<II>type>II<var<II>info>II<der Wert der im Mud als Vorsicht gesetzt wird, wenn TF die Steuerung der Flucht komplett! uebernimmt<II>fileinfo>II<vorsicht.tf<II><I>
/set help___011117099=<I>pub_extract>I<<II>type>II<mak<II>info>II<Extrahiert aus den uebergebenen Parametern die Variablen %pub_kosten, %pub_art und %pub_name.<II>fileinfo>II<uselists.tf<II><I>
/set help___015101105=<I>user_got_active>I<<II>type>II<hook<II>info>II<Hook der beim Aktiv-Werden des Nutzers aufgerufen wird<II>fileinfo>II<worldconnect.tf<II><I>
/set help___004469445=<I>xtitle>I<<II>type>II<comm<II>info>II<Setzt den Titel des xterms.<II>fileinfo>II<util.tf<II><I>
/set help___012110101=<I>undef_abbrev>I<<II>type>II<comm<II>info>II<Loescht eine Abkuerzung<II>ex>II</undef_abbrev freunde<II>fileinfo>II<util.abbrev.tf<II><I>
/set help___2141278428=<I>pub_count>I<<II>type>II<mak<II>info>II<Dieses Makro ueberwacht die Veraenderung der LP/MP. Wenn die Steigerung zweimal (in %pub_count) oder oefter weniger als 2 LP/MP betraegt, wird der Test der Tanke mittels /pub_done beendet.@{N}Die Zeit des Volltankens werden in %pub_ztanken gespeichert und die erhaltenen LP/MP in %pub_temp_lp bzw. %pub_temp_mp.<II>var>II<p_m_mp, p_m_lp, pub_count, pub_ztanken, pub_temp_lp, pub_temp_mp<II>see>II</pub_done, /pub_got, /pub_kaufe, /pub_test, /pub_init<II>fileinfo>II<uselists.tf<II><I>
/set help___017109110=<I>comparelastpoints>I<<II>type>II<comm<II>info>II<Vergleicht die Raumbeschreibungen in der Liste und zeigt Knoten mit denselben Raumbeschreibungen an.<II>fileinfo>II<way.tf<II><I>
/set help___014101100=<I>keys_edit_mode>I<<II>type>II<var<II>info>II<Flag fuer Editiermodus (Anzeigen aktuelle Belegung, Eingabe neues Kommando & Beschreibung)<II>fileinfo>II<keys.tf<II><I>selectlastmode>I<<II>type>II<mak<II>info>II<Intern. Waehlt die letzte Belegung, in der Tasten eingetragen sind.<II>syn>II</selectlastmode<II>fileinfo>II<keys.tf<II><I>
/set help___276351605=<I>tokenize>I<<II>type>II<mak<II>info>II<Spaltet Strings entsprechend der angegebenen Begrenzer auf.<II>syn>II<$[tokenize("begrenzer z.b. space Komma usw.","string")]<II>return>II<%T0 anzahl der aufspaltungen@{N}%Ti ite aufspaltung<II>version>II<1.01<II>fileinfo>II<util.sfunc.tf<II><I>
/set help___1821146082=<I>def_abbrev>I<<II>type>II<comm<II>info>II<Definiert eine Abkuerzung, indem sie sie in die Liste ?abbreviations eintraegt. Danach wird jeder Text, der ^abkuerzung enthaelt und ans Mud geschickt werden soll, vervielfaeltigt und jeweils ein Eintrag der Abkuerzung eingetragen.<II>ex>II</def_abbrev freunde mesirii strohalm@{N}Damit wird aus 'teile ^freunde mit test'@{N}-> 'teile mesirii mit test' und@{N}-> 'teile strohalm mit test'@{N}Pausen koennen mit '/def_abbrev zauber *3 schutz hand' eingestellt werden (3 Sekunden) oder mit 'zaubere ^3zauber' beim Ausfuehren angegeben werden. Dabei sind die Pausen beim Ausfuehren vorrangig. Dank Strohalm sind jetzt durch _ statt Leerzeichen getrennte Worte in den Abkuerzungen moeglich; diese werden bei der Umsetzung wieder durch Leerzeichen ersetzt.<II>fileinfo>II<util.abbrev.tf<II><I>
/set help___000007899=<I>loc>I<<II>type>II<mak<II>list>II<i18n<II>info>II<Lokalisiert einen übergebenen String, dazu wird in der Liste i18n, der String gesucht und dann die Uebersetzung fuer die aktuelle Locale (in LANG) zurueckgegeben, falls die aktuelle Locale mit der Basislocale uebereinstimmt, wird nicht gesucht.<II>syn>II</test loc("locale des Strings","String") oder /loc locale String<II>return>II<per /result<II>ex>II</test loc("de","Das ist ein Text") : bei LANG=en "This is a text"@{N}/loc de Das ist ein Test<II>see>II<add_loc, LANG<II>fileinfo>II<i18n.tf<II><I>
/set help___1353587124=<I>haddtolist>I<<II>type>II<comm<II>func>II<hash<II>info>II<Fuegt ein Schluessel-Wert-Paar zu einer ?Hashliste hinzu. Dabei darf der Schluessel keine Leerzeichen enthalten.<II>syn>II</haddtolist listenname schluessel wert<II>var>II<%value<II>see>II</hxaddtolist<II>fileinfo>II<lists.tf<II><I>
/set help___034078529=<I>showway>I<<II>type>II<comm<II>info>II<Zeigt Wege an.<II>syn>II<'/showway * knoten' zeigt alle Wege an, die zum Knoten hinfuehren.@{N}'/showway knoten *' zeigt alle Wege an, die vom Knoten wegfuehren.@{N}'/showway knoten1 knoten2' zeigt den Weg zwischen den Knoten an.<II>see>II<wege editieren, editway, delway<II>fileinfo>II<way.tf<II><I>
/set help___1913392889=<I>break_tri>I<<II>type>II<mak<II>info>II<Testet, ob einer der Befehle, die nach dem /break_tri und vor dem naechsten /voff kommen, dem Triggertext (regexp) entspricht, und bricht dann den Weg ab; ansonsten wird er fortgesetzt.<II>syn>II</break_tri triggertext%;befehle%;/voff%;<II>ex>II</break_tri (Ohne Seil kommst Du hier nicht lang)%;kletter nach unten%;/voff%;<II>see>II<wegeingabe, utri, regexp, tri, do_tri, voff<II>fileinfo>II<way.tf<II><I>
/set help___003828164=<I>fi_add>I<<II>type>II<mak<II>info>II<Haengt Parameter an Variable %fi_list an.<II>var>II<%fi_list<II>fileinfo>II<help.tf<II><I>
/set help___015116105=<I>get_window_file>I<<II>type>II<mak<II>info>II<liefert den Dateinamen fuer das Logging dieses windows zurueck<II>fileinfo>II<util.windows.tf<II><I>
/set help___014101101=<I>reggetidxofkey>I<<II>type>II<func<II>func>II<count_entries, isVar<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>info>II<Liefert den Index des ersten Schluessels zurueck, auf den die regexp passt.@{N}Die Liste kann sowohl direkt als auch ueber ihren Namen angegeben werden (siehe Beispiel).<II>syn>II</reggetidxofkey (liste|listenname) regexp<II>return>II<Index des ersten zur regexp passenden Schluessels oder %error als Rueckgabewert und in %value<II>ex>II<Sowohl@{N}@{}  /test index:=reggetidxofkey("skills_list",".* miserabel(st)?%")@{N}als auch@{N}@{}  /test index:=reggetidxofkey(skills_list,".* miserabel(st)?")@{N}liefern den gleichen Wert.<II>var>II<%value<II>see>II<regexp, /getidxofkey, /getikey, /getivalue, /reggetidxofvalue<II>fileinfo>II<lists.tf<II><I>
/set help___1867638348=<I>addtolist>I<<II>type>II<comm<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und einen Wert an das Ende einer Liste an.<II>syn>II</addtolist listenname schluessel wert<II>see>II</addbtolist, /xaddtolist, /uaddtolist, /getvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___014101102=<I>team_show_info>I<<II>type>II<comm<II>func>II<team_info_color<II>param>II<leader, name, gilde, lv, level, glv, lp, mlp, kp, mp, mkp, vors, v, vs, gr, ar, tr, fr, a, tab, af, autofolge, angriffsbefehl, tabtext, fluchtrichtung, fl<II>info>II<Listet die angegebenen Attribute fuer alle Teammitglieder auf (aus team info). Lebens-, Magiepunkte und Vorsicht werden eingefaerbt.<II>syn>II</team_show_info attribut [attribut] ...<II>fileinfo>II<team.tf<II><I>
/set help___000000118=<I>v>I<<II>type>II<comm<II>info>II<setzt die Variable %p_whimpie auf den angegebenen Parameter und setzt die Vorsicht im MUD. Falls die Vorsicht groesser als Null ist, wird sofort ein Test durchgefuehrt.<II>fileinfo>II<vorsicht.tf<II><I>
/set help___264052340=<I>t_vorsicht>I<<II>type>II<trig<II>info>II<Trigger, der auf die Reaktion der Vorsicht im Mud anspringt und neben einer Ausgabe das Makro /testvorsicht ausfuehrt.<II>fileinfo>II<vorsicht.tf<II><I>
/set help___036677953=<I>~addway>I<<II>type>II<mak<II>list>II<ways<II>info>II<Fuegt einen !kompletten Weg zur Liste ?ways hinzu.<II>see>II<~getway, ways<II>fileinfo>II<way.tf<II><I>
/set help___2098665012=<I>sort_most>I<<II>type>II<mak<II>list>II<most<II>info>II<Damit wird die Most-Liste sortiert. Die Eintraege haben einen Zaehler, wie haeufig sie in den Texten auftreten, und nach dieser Haeufigkeit werden sie sortiert.<II>see>II<most, /save_most<II>fileinfo>II<untroom.tf<II><I>
/set help___000493728=<I>index>I<<II>type>II<misc<II>func>II<geti, getidxofkey, getidxofvalue, reggetidxofkey, reggetidxofvalue, delikeyandvalue, getikey, getivalue<II>info>II<Beim Arbeiten mit Listen und Indizes ist zu beachten, dass die Zaehlung des Index bei Null beginnt!<II>fileinfo>II<lists.tf<II><I>
/set help___014101103=<I>team_autofolge>I<<II>type>II<comm<II>info>II<Schaltet Autofolge um. Default Kurz-Makroname: @{B}/af@{x}.<II>fileinfo>II<team.tf<II><I>
/set help___324320409=<I>no_cond_go>I<<II>type>II<mak<II>info>II<Setzt den mit /cond_go gesetzten Befehl zurueck.<II>fileinfo>II<way.tf<II><I>
/set help___014101097=<I>getshortestway>I<<II>type>II<mak<II>info>II<Liefert den kuerzesten Weg aus der Liste (from|to)l_w.<II>return>II<value=kuerzester Weg oder -1, wenn keine Wege mehr vorhanden sind oder sie eine Laenge >1000 haben.<II>var>II<len, maxlen, (~ = from|to) ~templ_w, ~len, ~maxlen, ~l_w<II>fileinfo>II<way.tf<II><I>
/set help___2093150692=<I>stack_put>I<<II>type>II<mak<II>info>II<Speichert die uebergebene (globale) Variable auf dem Stack in der angegebenen Position. Die Position muss innerhalb des Stackpointers liegen.<II>ex>II</stack_put 1 test oder /stack_put test 1<II>see>II<getstack, stack_push, stack_pop<II>fileinfo>II<util.stack.tf<II><I>
/set help___000007444=<I>end>I<<II>type>II<comm<II>list>II<ways, fromidx, toidx<II>info>II<Beendet die Wegeingabe. Wenn der aktuelle Raum als Knoten erkannt wird, wird er sofort als Endknoten benutzt, ansonsten muss einer eingeben werden. Dann speichert es den Weg ab. Dabei wird gefragt, ob das mit Defaultwerten (s)chnell, mit vorherigem (e)ditieren oder (n)icht geschehen soll. (Nach Aenderunen in tf geht das direkte Editieren nicht mehr, der Weg muss erst mit (s)chnell gespeichert werden und dann mit /editway editiert werden.)@{N}Fuer das Editieren bitte dort nachsehen.@{N}Die Wege werden @{B}sofort@{N} auf die Platte gespeichert.@{N}Falls der Knoten neu ist, wird seine Beschreibung auch erfasst. Dabei wird die ggf. angegebene Zeilenzahl fuer die Speicherung benutzt, ansonsten die Variable ?addlines<II>syn>II</end [endknoten [zeilenzahl]]<II>see>II<wege editieren, einschraenkungen<II>fileinfo>II<way.tf<II><I>
/set help___014101105=<I>restricttoexit>I<<II>type>II<mak<II>info>II<Begrenzt die Raumbeschreibung, die in %fulldetail steht, auf bis einschliesslich der Ausgaenge. Die Variable %room_npcs wird auf den Rest gesetzt.<II>var>II<mud_exits_output<II>fileinfo>II<way.tf<II><I>
/set help___014105121=<I>killlongerways>I<<II>type>II<mak<II>info>II<Loescht die Wege, die laenger als die angegebene Variable (from|to)maxlen sind aus der Liste (from|to)temp_list.<II>syn>II<killlongerways (from|to)<II>var>II<maxlen, (~ = from|to) ~maxlen, ~temp_list<II>fileinfo>II<way.tf<II><I>
/set help___011110101=<I>init_mapper>I<<II>type>II<comm<II>func>II<addworld, connect, fg<II>info>II<initialisiert eine Verbindung zur Mapper Application. Es wird eine World namens mapper angelegt und verbunden. Ausserdem wird die Variable mapper auf 1 gesetzt. Der Standardport ist 2000, Standardhost ist localhost<II>syn>II</init_mapper [port [host]]<II>ex>II</init_mapper 4711<II>var>II<mapper, automapper<II>see>II<mapper_host, mapper_port<II>fileinfo>II<mapper.tf<II><I>
/set help___023119115=<I>windows_stop_timestamps>I<<II>type>II<mak<II>info>II<Setzt die Variable windows_run_timestamps auf 0<II>fileinfo>II<util.windows.tf<II><I>
/set help___013101100=<I>help_keywords>I<<II>type>II<list<II>info>II<Enthaelt die moeglichen Schluesselworte fuer die Hilfebefehle.<II>ex>II<mak(key) 1 Makros:(value, 0|1|2 Detailstufe, Ueberschrift)<II>fileinfo>II<help.tf<II><I>
/set help___017109116=<I>remove_attributes>I<<II>type>II<func<II>info>II<Loescht im uebergebenen String alle Attributsdefinitionen. Nuetzlich fuer Ausgabe in Logfiles oder in den Prompt.<II>syn>II</info (error|success|warning|failure|fatal) Text<II>return>II<String ohne Attributsanweisungen<II>ex>II<Die Zeile@{N}/echo -p @@{Ccyan}$[remove_attributes("nicht @@{Cred}rot")]@{N}erzeugt als Ausgabe@{N}@{Ccyan}nicht rot@{n}<II>fileinfo>II<util.echo.tf<II><I>
/set help___030849861=<I>getnode>I<<II>type>II<mak<II>info>II<Liefert den Knotennamen zum Alias; wenn kein Alias vorhanden ist, wird der Parameter zurueckgegeben.<II>fileinfo>II<way.tf<II><I>
/set help___240852801=<I>cont_way>I<<II>type>II<mak<II>mak>II<go_way3<II>info>II<Geht den unterbrochenen Weg weiter. MUSS von eigenen Makros ausgefuehrt werden, nachdem sie ihre Funktion erfuellt haben.<II>var>II<go_way3_param<II>see>II<continue, wegeingabe<II>fileinfo>II<way.tf<II><I>
/set help___013101101=<I>remove_packet>I<<II>type>II<comm<II>mak>II</purge_renamed<II>info>II<Dieses Makro hilft beim vollstaendigen Entfernen aller Makros, Trigger, Hooks, Variablen eines Pakets. Es werden mittels /purge alle Makros, Trigger und Hooks geloescht, die mit dem angegeben Praefix (ein '_' wird dahinter ergaenzt) beginnen. Ausserdem wird das Makro /remove_<Praefix> geloescht. Desweiteren werden alle mit ?/rename_mac erstellten Kopien dieser Makros geloescht, sofern beim Aufruf von /rename_mac das entsprechende Praefix mit uebergeben wurde. Schliesslich werden noch alle mit dem Praefix beginnende Variablen geloescht. Ausser dem Praefix koennen noch Makro- und/oder Variablennamen uebergeben werden, die dann ebenfalls mit /purge bzw. /unset geloescht werden.<II>syn>II</remove_packet praefix [weitere Makro-/Variablennamen]<II>ex>II<Der Aufruf von@{N}/remove_packet comm rufe last_partner@{N}loescht alle Makros, Trigger, Hooks und Variablen, die mit "comm_" beginnen, sowie das Makro /rufe, die Variable %last_partner und /remove_comm.@{N}Wurde vorher mit@{N}/rename_mac tmh comm_tm_hist comm@{N}das Makro /comm_tm_hist kopiert, so loescht das obige /remove_packet auch /tmh.<II>see>II</purge_renamed, /rename_mac<II>fileinfo>II<util.tf<II><I>
/set help___016109111=<I>remove_from_hook>I<<II>type>II<mak<II>info>II<Entfernt aus dem angegebenen Hook vorher hinzugefuegte Anweisungen. Dazu muss der String exakt uebereinstimmen.<II>syn>II</remove_from_hook hookname anweisungen<II>ex>II</add_to_hook testhook /echo %*@{N}/remove_from_hook /echo %*<II>fileinfo>II<util.hooks.tf<II><I>
/set help___014097115=<I>haddlisttolist>I<<II>type>II<mak<II>mak>II</haddtolist, /makesub<II>info>II<Fuegt die als Wert (%variable) angebebene Liste unter dem angegebenen Schluessel zur ?Hashliste hinzu. Dabei wird die Liste modifiziert, um als Subliste innerhalb der eigentlichen Liste erhalten zu bleiben.<II>syn>II</haddlisttolist listenname schluessel wertliste<II>ex>II<@{N}/createlist schwerter_liste@{N}...@{N}/haddlisttolist waffen_liste schwerter %schwerter_liste<II>var>II<%value<II>see>II</hgetlistvalueof, /addlisttolist, /makesub, /unmakesub, /hxaddlisttolist<II>fileinfo>II<lists.tf<II><I>uaddlisttolist>I<<II>type>II<comm<II>mak>II</unmakesub, /uaddtolist<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und eine (Sub)Liste am Ende einer Liste an, nachdem alle anderen Vorkommen dieses Schluessels geloescht wurden.@{N}In der Subliste werden die Listentrenner um eine Stufe erhoeht.<II>syn>II</uaddlisttolist listenname schluessel subliste (der Inhalt!)<II>ex>II</uaddlisttolist obst aepfel %apfelsorten<II>see>II</addlisttolist, /uaddtolist, /getlistvalueof<II>fileinfo>II<lists.tf<II><I>xaddlisttolist>I<<II>type>II<comm<II>mak>II</paramparse, /makesub<II>info>II<Fuegt einen Schluessel und eine (Sub)Liste am Ende einer Liste an. Dabei kann der Schluessel Leerzeichen enthalten. Die einzelnen Parameter muessen durch das Trennzeichen kaufmaennisches UND ('&') getrennt sein.@{N}In der Subliste werden die Listentrenner um eine Stufe erweitert.<II>syn>II</xaddlisttolist listenname&schluessel&subliste (der Inhalt!)<II>ex>II</xaddlisttolist rezepte&ohne Fleisch&%puddings<II>see>II</xaddtolist, /addlisttolist, /getlistvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___013101102=<I>team_get_info>I<<II>type>II<comm<II>param>II<leader, name, gilde, lv, level, glv, lp, mlp, kp, mp, mkp, vors, v, vs, gr, ar, tr, fr, a, tab, af, autofolge, angriffsbefehl, tabtext, fluchtrichtung, fl<II>info>II<Listet das angebene Attribute das angegebene Teammitglied auf (aus team info). Lebens-, Magiepunkte und Vorsicht werden eingefaerbt.<II>syn>II</team_get_info name attribut<II>fileinfo>II<team.tf<II><I>
/set help___032937795=<I>p_block>I<<II>type>II<var<II>info>II<ZusatzMP sind was feines :)<II>fileinfo>II<mg_properties.tf<II><I>
/set help___1926297320=<I>cond_stop>I<<II>type>II<mak<II>mak>II<cont_way<II>info>II<Wenn die Bedingung erfuellt ist, wird an der Stelle der Weg angehalten und kann dann mit /continue fortgesetzt werden.<II>syn>II</cond_stop bedingung<II>ex>II</cond_stop 1==0 oder /cond_stop party (true, wenn party gesetzt und ungleich 0)<II>fileinfo>II<way.tf<II><I>
/set help___011114120=<I>free_regexp>I<<II>type>II<misc<II>info>II<Falls die Erweiterung 'REGCOMP' vorhanden ist, wird die uebergebene Regexp wieder freigegeben.<II>syn>II</free_regexp glob_pattern<II>ex>II</free_regexp RE_REGEXP_*<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___030023460=<I>del_unt>I<<II>type>II<mak<II>info>II<Verzoegert und fuehrt das '/unt detail' fuer den Raum aus. Vor der Raumbeschreibung wird durch /echo eine Leerzeile erzeugt.<II>fileinfo>II<untroom.tf<II><I>
/set help___013101103=<I>keys_bindings>I<<II>type>II<cfg<II>info>II<Taste mit Keycodes fuer Keybindings:@{N}0-9,+,-,*,/ sind fuer den Nummernblock@{N}f1-f12 fuer die Funktionstasten@{N}esc0-esc9 fuer die Ebenen<II>update>II</keys_set_bindings<II>fileinfo>II<keys.tf<II><I>
/set help___000463512=<I>ascmp>I<<II>type>II<func<II>info>II<Vergleichsfunktion auf Stringbasis (d.h. '112' < '65'). Liefert einen Wert < 0, wenn der Feldwert an 'index1' lexikografisch kleiner ist als an 'index2'. Bei Gleichheit wird 0 zurueckgegeben, ansonsten ein positiver Wert.<II>syn>II</ascmp feldname index1 index2<II>return>II<in %value und als Rueckgabewert<II>var>II<%value<II>see>II<asicmp, ancmp, strcmp<II>fileinfo>II<lists.tf<II><I>
/set help___2114483795=<I>t_whimpie>I<<II>type>II<trig<II>info>II<Trigger, der die Vorsicht und Fluchtrichtung vom Teddy abfaengt und auf Uebereinstimmung mit den im TF gespeicherten Werten ueberprueft. Falls Sie nicht uebereinstimmen, werden sie auf die gespeicherten Werte zurueckgesetzt. (Es soll ja NPCs geben, die sowas tun.)<II>var>II<p_whimpie, p_escape<II>fileinfo>II<vorsicht.tf<II><I>
/set help___026100095=<I>cfg_mud_do_echo_hit_points>I<<II>type>II<cfg<II>info>II<Steuert die Ausgabe der Hitpoints<II>update>II</add_hit_points_to_hook<II>fileinfo>II<mg_properties.tf<II><I>
/set help___272606434=<I>shorten2>I<<II>type>II<mak<II>mak>II<shorten<II>info>II<Uebergibt den uebergebenen Weg ueber die Variable %shorten an /shorten und liefert dessen Ergebnis zurueck.<II>fileinfo>II<way.tf<II><I>
/set help___014097118=<I>haddlisttosave>I<<II>type>II<comm<II>mak>II</deletekeyandvalue, /addtolist<II>info>II<Verwaltet die aktuell geladenen Hashlisten in einer eigenen Liste, damit sie bei Aenderungen durch /saveall oder /savealllists gespeichert werden.<II>syn>II</haddlisttosave listenname<II>see>II</hsavelist, /hloadlist, /hashliste, /saveall<II>fileinfo>II<lists.tf<II><I>
/set help___2108328778=<I>nodes_geb>I<<II>type>II<comm<II>info>II<Sucht in den Knoteninfomationen alle Knoten, die im angegebenen Gebiet liegen.<II>fileinfo>II<way.tf<II><I>
/set help___1919993388=<I>default ,>I<<II>type>II<misc<II>info>II<Trennzeichen fuer das /walk == ?speedwalk<II>see>II<walk<II>fileinfo>II<way.tf<II><I>
/set help___013101105=<I>def_save_trig>I<<II>type>II<trig<II>info>II<Trigger fuer Grabben des Mud-Outputs.<II>cfg>II<untroom_hide_mud_output<II>fileinfo>II<untroom.tf<II><I>getpoint_trig>I<<II>type>II<var<II>info>II<Die Nummer des Triggers, der beim Grabben der Raumbeschreibung von ?/getpoint verwendet wird.@{N}Durch "-E(!trig_is_active(getpoint_trig))" lassen sich andere Trigger fuer die Zeit des Grabbens abschalten.<II>see>II</getpoint<II>fileinfo>II<way.tf<II><I>
/set help___000059484=<I>dset>I<<II>type>II<mak<II>info>II<Setzt die angegebene Variable auf den Wert, arbeitet genau wie /set nur dass abhaengige Variablen aktualisiert werden (d.h. per Selbstzuweisung /test a:=a) so dass die Statuszeile sie aktualisiert anzeigt. Wichtig ist das, wenn die Attribute (status_attr_varname) oder Anzeige (status_var|func_varname sich aus aus der hier gesetzten Variablen ergeben. Das passiert aber nur, wenn sich der Wert wirklich geaendert hat!<II>syn>II</dset varname[[=| ]value]<II>ex>II</dset a=10@{N}/dset a (Zeigt wie /set an)<II>see>II<dep_var, undep_var<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___017100103=<I>add_to_hook_begin>I<<II>type>II<mak<II>mak>II<hook_%hookname<II>changes>II<1.01 testet, ob hook existiert<II>info>II<Fuegt dem angegebenen Hook Anweisungen als erste Anweisungen an. Dabei sollte die letzte nicht mit '%;' abgeschlossen werden. Im Hook kann auf die Makroparameter Bezug genommen werden.<II>syn>II</add_to_hook_begin hookname anweisungen<II>version>II<1.01<II>ex>II</add_to_hook_begin reload /mload %param<II>fileinfo>II<util.hooks.tf<II><I>
/set help___2050749556=<I>add_portal>I<<II>type>II<comm<II>info>II<Fuegt ein Morgengrauen Portal zu den Wegen hinzu<II>syn>II</add_portal knoten portalnummer<II>ex>II</add_portal tiger 3<II>fileinfo>II<warok<II><I>
/set help___2127457279=<I>savearray>I<<II>type>II<mak<II>info>II<Speichert das angegebene Feld in das File 'Feldname.ary'. Fuer den Speicherort koennend die bekannten /mload Optionen angegeben werden (siehe /custom).<II>syn>II</savearray [custom-Optionen] feldname<II>ex>II</savearray -l help_tips<II>see>II</loadarray<II>fileinfo>II<lists.tf<II><I>
/set help___249005504=<I>hforeach>I<<II>type>II<mak<II>mak>II</forEach<II>info>II<Wie /forEach fuer normale Listen, arbeitet /hforEach eine ?Hashliste durch. Dabei ist jedoch nicht wie bei /forEach eine Reihenfolge garantiert. Die Schluessel und/oder Werte werden dem angegebenen Makro als Parameter uebergeben.<II>syn>II</hforEach listenname k[v] /makroname<II>ex>II</hforeach demo_list k /echo Schluessel:@{N}wuerde nacheinander alle Schluessel von 'demo_list' ausgeben.<II>var>II<%value<II>see>II</forEach<II>fileinfo>II<lists.tf<II><I>
/set help___017100105=<I>add_prompt_action>I<<II>type>II<mak<II>fileinfo>II<util.prompts.tf<II><I>
/set help___013097115=<I>savenamedlist>I<<II>type>II<comm<II>info>II<Speichert die Liste, die den Namen %parameter_list_name hat in dem Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die der Parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</savenamedlist paket_prefix<II>ex>II<Nach@{N}@{}  /set waffen_list_name=waffen@{N}@{}  /set waffen_list_location=ausruestung@{N}wuerde@{N}@{}  /savenamedlist waffen@{N}die Liste 'waffen' im File 'ausruestung/waffen.list' speichern.<II>see>II</loadnamedlist, /savelist<II>fileinfo>II<lists.tf<II><I>
/set help___2139695519=<I>reggetkey>I<<II>type>II<func<II>func>II<convert_regexp<II>info>II<Es wird der erste Schluessel geliefert, auf den die uebergebene regexp passt.<II>syn>II</reggetkey listenname regexp<II>return>II<erster zur Regexp passender Schluessel als Rueckgabewert und in %value<II>var>II<%value<II>see>II</convert_regexp, /getkeyofvalue, regexp, /reggetvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___013103115=<I>hgetentrylist>I<<II>type>II<mak<II>func>II<hash<II>mak>II</createlist, /getdvalueof, /xaddtolist<II>info>II<Liefert eine (normale) Liste zurueck, in der alle Eintraege mit dem angegebenen Schluessel gesammelt sind.<II>syn>II</hgetentrylist listenname schluessel<II>return>II<in %value und pre /return eine normale Liste der Eintraege und Werte<II>var>II<%value, %hvalue<II>fileinfo>II<lists.tf<II><I>
/set help___013097116=<I>make_dos_path>I<<II>type>II<info<II>info>II<konvertiert einen CygWin Path in einen Dos Pfad<II>fileinfo>II<util.tf<II><I>
/set help___016100101=<I>mud_exits_regexp>I<<II>type>II<var<II>info>II<Eine Regexp um die Himmelsrichtungen aus %P2 zu holen.<II>fileinfo>II<warok<II><I>
/set help___013095109=<I>p_update_time>I<<II>type>II<var<II>info>II<Zeit der letzten Ueberpruefung der Punkte.<II>fileinfo>II<mg_properties.tf<II><I>
/set help___016100095=<I>add_to_window_rc>I<<II>type>II<comm<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Regexp-Trigger geschrieben, aber trotzdem noch im normalen Fenster angezeigt und zwar wird der gematchte Text mit den als 2. Parameter angegebenen Attributen eingefaerbt.<II>ex>II</add_to_window_rc Tod Cblack \\[Tod:.*<II>fileinfo>II<util.windows.tf<II><I>
/set help___012109116=<I>hmerge_lists>I<<II>type>II<mak<II>mak>II</hcopyList, /hforeEach, /hmerge_lists2<II>info>II<Fuegt zwei Hashlisten zusammen, wobei Schluessel, die in beiden Listen vorkommen, aus der zuerst angegebenen genommen werden. Die Ergebnisliste heisst 'hmerge_list'.<II>syn>II</hmerge_lists listenname1 listenname2<II>return>II<Ergebnisliste %hmerge_list<II>var>II<%merge_lists, %value<II>fileinfo>II<lists.tf<II><I>
/set help___2071306502=<I>undep_var>I<<II>type>II<mak<II>info>II<Loescht Variablen aus der Liste der abhaengigen Variablen der zuerst angegebenen Variablen<II>syn>II</undep_var varname depending_var<II>ex>II</undep_var a b<II>see>II</dep_var, /dset<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___251501955=<I>paramparse>I<<II>type>II<func<II>info>II<Erlaubt einen anderen Parameterseparator als das Leerzeichen. Dabei werden /paramparse als Parameter1 der Separator, als Parameter2 die gewuenschte Position (1,2,3,... oder -1,-2,-3,...) und als Rest die Parameter uebergeben.@{N}Achtung, /paramparse verwendet regmatch(), d.h. %P1 etc. aendern ihre Werte!<II>syn>II</paramparse Separator [-](1,2,3.,.) Parameter<II>return>II<ueber /return<II>ex>II<Nach@{N}@{}  /set a=$[paramparse("&",3,"Das hier&ist aber& ein bloe&des Beispiel")]@{N}@{}  /set b=$(/paramparse & -3 Das hier&ist aber& ein bloe&des Beispiel)@{N}haette %a den Wert " ein bloe" und %b "ist aber".<II>see>II<substitution, regexp<II>fileinfo>II<lists.tf<II><I>
/set help___004212524=<I>reload>I<<II>type>II<comm<II>mak>II<eval_hook<II>info>II<Laedt alle Makrodateien neu, ohne vorher den Speicher zu loeschen.<II>fileinfo>II<loading.tf<II><I>
/set help___016100097=<I>mud_typo_command>I<<II>type>II<var<II>info>II<Kommando zum Absetzen eines typos.<II>see>II<untroom.tf<II>fileinfo>II<untroom_actions.tf<II><I>mud_look_command>I<<II>type>II<var<II>info>II<Kommando zum Anschauen des Raumes.<II>see>II<way.tf, untroom.tf<II>fileinfo>II<warok<II><I>
/set help___2026031663=<I>inputtypo>I<<II>type>II<comm<II>info>II<Mit diesem Kommando wird ein Typo in der letzten Herkunftsanzeige gemeldet. Dazu wird der vorbereitete Text in die Kommandozeile geschrieben.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II<herkunftsanzeige<II>fileinfo>II<untroom.tf<II><I>
/set help___020108108=<I>hdelallkeysandvalues>I<<II>type>II<comm<II>mak>II</hdeletekeyandvalue<II>info>II<Loescht alle Schluesseleintraege dieses Schluessels in der angegebenen ?Hashliste.<II>syn>II</hdelallkeysandvalues listenname schluessel<II>fileinfo>II<lists.tf<II><I>
/set help___004362630=<I>way.tf>I<<II>type>II<fileinfo<II>mak>II<~addway, ~getway, lp2, sort_idx_list, initfind, find5, find6, testcon, killlongerways, getshortestway, count_steps, show_dimension, go_way, cont_way, klp, lwo, npc, von, voff, cw, wait, cond_go, no_cond_go, stop, cond_stop, go_way3, tri, dir_tri, do_wait_tri, do_tri, break_tri, next_prompt, utri, bug_way, disabled, show_cache, clear_cache, remove_from_cache, create_way, allowed, getali, getnode, expand_comm, addpoint, restricttoexit, getpoint, shorten2, shorten, loadways, foreachway, nodes_search<II>tut>II<Detaillierte Bedienungsanleitung: siehe auch ?wege.@{N}Siehe auch ?wegeingabe.@{N}Wenn man sich mit Kommandos durch die Gegend bewegt, die in der Liste xtramoves stehen (es sind schon die meisten Richtungskommandos drin), wird der Hin- und Rueckweg mitgeloggt. _Wenn_ man den Weg zurueckgehen koennen will, oder den Weg (ohne editieren) abspeichern will, dann muss man die wegespezifischen Sachen (Spezialkommandos) extra eingeben. Dazu einfach die Taste "0"  auf dem Ziffernblock druecken oder selber "/vorwaerts" eintippen.@{N}Es kommt dann: /vorwaerts - dahinter einfach den Befehl eintragen, der dann sofort ausgefuehrt wird und ggf. (bei komplexen Sachen) kommt danach noch ein /rueckwaerts (eventuell mit Vorgabe). Wenn im Weg bei /rueckwaerts oder /vorwaerts nichts kommen soll, dann einfach Enter druecken.@{N}Wenn man einen Weg speichern will, tippt man einfach an dem Punkt, wo er enden soll, "/end Name" ein und dann wird der Weg von letztem Punkt zu Name gespeichert; Wenn der Endpunkt schon bekannt ist, reicht auch /end. Noch ein paar Fragen beantworten ... fertig.@{N}In den Wegen koennen auch noch witzige Makros enthalten sein (siehe ?wegmakros).@{N}Zum Wegebearbeiten exisiteren folgende Kommandos:@{N}Mit "/delway" kann man einen Weg aus der Wegeliste loeschen. Es erfolgt eine Abfrage und die Wegeliste wird abgespeichert!!!@{N}Mit "/showway from to" kann man sich einen Weg from -> to anzeigen lassen (als Wildcard ist einmal * erlaubt, also alle Wege von/zu einem Punkt).@{N}Mit "/editway" kann man Wege nachtraeglich editieren.@{N}Knotenkommandos: siehe auch ?knoten@{N}"/shownode name" oder "/shownode *" zeigt die Beschreibungen fuer den Knoten oder eine Liste aller Knoten an.@{N}"/addnode [name]" ersetzt alle vorhandenen Beschreibungen fuer den aktuellen oder angegebenen Knoten durch die aktuelle Raumbeschreibung.@{N}"/appendnode [name]" fuegt die Raumbeschreibung der Liste hinzu.@{N}"/delnode [name]" loescht den Knoten und alle Wege, die zu ihm hin- oder von ihm wegfuehren.@{N}"/wo" stellt den aktuellen Knoten fest und zeigt ihn an.@{N}"/setali" vergibt Aliase fuer Knotennamen (die etwas laenger sein koennen).@{N}<II>changes>II<1.01 Das Problem mit dem tfread()/read() wurde durch /myread in ?util.tf geloest. Deshalb wurde bug_way zweigeteilt. Falls irgendwo noch das Problem mit dem read() auftritt, bitte Mail an mich.@{N}1.02 Es wird jetzt /shread in den Makros verwendet, das sollte keine Probleme mehr machen.@{N}Die /speedwalk-Syntak wird per Makro und Send-Hook unterstuetzt /walk.@{N}1.03 /walk und /h_move unterstuetzen jetzt den Mapper ?mapper.tf (<a href="map/Mapper.html">siehe auch dort</a>).@{N}1.03 Neues Makro /cond_stop fuer bedingtes Anhalten auf Wegen, einige nicht customizable Fehler rausgenommen.@{N}1.04 * Fehlermeldungen von /go erweitert.@{N}* Ausgabe der durchlaufenen Knoten und bei /wo.@{N}* Prefix-Makros fuer jeden Wegebefehl eines Bereiches (/cond_go).@{N}* Einbindung von Mapper in /h_move, /wo, bzw. bei /go.@{N}* Bei der Nutzung von verify (/von, /npc) in den Wegen ist jetzt bei einem Hindernis sowohl /c[ontinue] (weiterlaufen, nachdem Hindernis beseitigt ist) als auch /back (zurueck zum letzten passierten Knoten) moeglich.@{N}* /addway zum direkten Hinzufuegen eines Weges.@{N}* Wegen der Konsistenz der Listen werden die Wegelisten vor jeder Veraenderung neu geladen und danach wieder gespeichert.@{N}* Fehler in /renamenode (hoffentlich) behoben ,)@{N}1.05 * /gof erlaubt jetzt auch die Angabe des Startknotens (also kein /wo vorher).@{N}* Der Inhalt der Variable %after_go wird jetzt nach dem Ablaufen eines Weges mittels /go ausgefuehrt.@{N}* /para fuer Stroh in /wpara umbenannt.@{N}* Einbindung der Parawelt des Mappers in /wpara und /nopara.@{N}* Neues sehr hilfreiches makro /rush zum schnellen Ablaufen langer, unverzweigter Wege.@{N}1.06 (3.11.99) /shownode arbeitet jetzt auch mit Wildcards.@{N}1.07 (13.12.99) /go ist in /_go umbenannt worden, damit eigene Kreationen das /go ersetzen koennen. Kandidaten dafuer sind '/gof start ziel' oder '/wgo ziel' (testet den Startknoten) (z.B. /def go = /wgo %*%;).@{N}/break_tri bricht einen Weg ab, wenn ein Triggertext anschlaegt.@{N}/do_tri fuehrt einen Befehl aus und fuehrt den Weg dann fort, wenn der Trigger anschlaegt.@{N}1.07 (05.01.00) * /shownode, /nodes_geb und /nodes_info zeigen jetzt auch Aliase richtig an.@{N}* /goto und /gobk optimieren jetzt den Weg (n%;s%; raus), bevor der weg vom letzten Knoten wiederholt bzw. zum letzten Knoten zurueckgegangen wird.@{N}* An den Grenzen der Teilwege gibt es eine Optimierung (n%;s%; raus).<II>info>II<addway, saveways<II>req>II<!lists.tf util.sfunc.tf util.prompts.tf util.hooks.tf util.trigger.tf(1.18) util.vfunc(1.21)<II>misc>II<default long, default ,, cache<II>comm>II<lp, wayindex, askway, gof, ago, wgo, bgo, go, noport, port, wpara, nopara, testway, continue, disable, enable, showways, ao, setali, weg, walk, vorwaerts, addnode, appendnode, delnode, wo_raum, goto, wo, addallpoints, shownode, comparelastpoints, gobk, add_trip, tgo, end, reverseway, splitway, editway, showway, delway, renamenode, rush, delnodeinfo, addnodeinfo, nodes_geb, nodes_info<II>cfg>II<wo_show_bug, cfg_way_go_show_condition, cfg_way_go_show_text<II>version>II<way.tf,v 1.49 2003/08/20 12:53:06 nieten (Mesirii@mg.mud.de)<II>hook>II<h_move<II>var>II<alitype, movement_marker, after_go, getpoint_trig<II>see>II<ways, knoten, wege, portale, dimensionen, wegmakros, sperren, einschraenkungen, knotenaliase, wegeingabe, editieren<II>fileinfo>II<way.tf<II><I>
/set help___014111114=<I>format_number3>I<<II>type>II<mak<II>info>II<Formatiert eine Zahl so, dass sie auch auf 3 Stellen erkennbar ist, z.b. 999=999 9999=9k9 99999=99k 999999=M99<II>fileinfo>II<status.tf<II><I>
/set help___004034458=<I>mapper>I<<II>type>II<var<II>info>II<wenn auf 1 wird der mapper mit Kommandos (Ausgaenge erstellen, Infos hinzufuegen, bewegen) versorgt<II>fileinfo>II<mapper.tf<II><I>
/set help___029170907=<I>add_loc>I<<II>type>II<mak<II>list>II<i18n, add_loc (temporaer)<II>info>II<Fügt neue Lokalisierungsstrings hinzu<II>syn>II</test add_loc("base_string","base_locale","string","locale","string2","locale2")<II>ex>II</test add_loc("Deutscher Text","de","German Text","en")<II>see>II<loc<II>fileinfo>II<i18n.tf<II><I>
/set help___030117108=<I>cfg_status_color_mp_block_flag>I<<II>type>II<cfg<II>info>II<MP-Hinterlegung wenn Block voll/leer ist<II>dtype>II<flag<II>fileinfo>II<mg_properties_status.tf<II><I>
/set help___003716079=<I>asshow>I<<II>type>II<comm<II>func>II<astart, alen<II>mak>II</aget<II>info>II<Zeigt nur die Werte an, die das angegebene Feld ausmachen.<II>syn>II</asshow feldname<II>return>II<Werte mit /result<II>see>II</ashow<II>fileinfo>II<lists.tf<II><I>
/set help___000008359=<I>tgo>I<<II>type>II<comm<II>info>II<Wenn temporaere Ausfluege fuer den aktuellen oder Zielknoten eingetragen sind, dann werden diese beruecksichtigt!<II>see>II<add_trip<II>fileinfo>II<way.tf<II><I>
/set help___012117112=<I>mud_show_npc>I<<II>type>II<var<II>info>II<Kommando zum Anzeigen aller NPCs (auch im Dunkeln).<II>see>II<way.tf, npc, bug_way<II>fileinfo>II<warok<II><I>
/set help___000065476=<I>port>I<<II>type>II<comm<II>info>II<Schaltet die Portale ein. Loescht die Liste zwischengespeicherter Wege.<II>var>II<portals<II>see>II<portale, dimensionen, para, nopara, noport<II>fileinfo>II<way.tf<II><I>
/set help___000008484=<I>unt>I<<II>type>II<comm<II>info>II<Dieser Befehl untersucht das angegebene Detail und verarbeitet die Ausgaben des Muds entsprechend. Es werden alle Substantive herausgesucht und diese durch die entsprechenden Listen geschickt. Ausserdem wird das naechste Detail herausgesucht und angeboten.@{N}Es wird @{B}unt detail im raum@{n} benutzt!<II>syn>II</unt detail<II>see>II</untroom, /unt2<II>fileinfo>II<untroom.tf<II><I>
/set help___021118116=<I>remove_region_details>I<<II>type>II<comm<II>info>II<Entfernt Standarddetails für eine Region<II>syn>II</remove_region_detail region<II>ex>II</remove_region_detail ark<II>see>II<add_region_details<II>fileinfo>II<untroom.tf<II><I>
/set help___258219972=<I>mapshort>I<<II>type>II<mak<II>mak>II<restricttoexit,<II>info>II<das Makro parst die Short, die als Ergebnis von /mapinfo erhalten wird<II>req>II<way.tf<II>var>II<mapper<II>fileinfo>II<mapper.tf<II><I>
/set help___000056968=<I>addh>I<<II>type>II<mak<II>list>II<help, helpindex, addh_sublist, help_keywords<II>info>II<Ermoeglicht es, neue Eintraege in das Hilfesystem einzufuegen. Dazu werden zuerst die gewuenschten Rubriken gefuellt und danach alle in die Hilfe eingetragen. Bei den Texten koennen alle von /echo -p bekannten Formatierungen benutzt werden und ausserdem noch @@@{}{N} fuer Zeilenumbrueche.@{N}Die erlaubten Schluesselworte stehen in %help_keywords.@{N}Ein aelterer Eintrag zum gleichen Stichwort wird ggf. ueberschrieben.@{N}(Mit @@{} am Zeilenanfang koennen uebrigens fuehrende Leerzeichen erzeugt werden.)<II>syn>II</addh [locale->en|de]info|syn|var|list|return|mak|comm|ex|see|dtype Text mit Formatierungen@{N}und zum Schluss: /addh eintrag<II>see>II</help, /echo, /echo2<II>fileinfo>II<help.tf<II><I>
/set help___793896524=<I>xaddtolist>I<<II>type>II<comm<II>mak>II</paramparse<II>info>II<Fuegt einen Schluessel, in dem auch Leerzeichen enthalten sein koennen, und einen Wert, die durch ein kaufmaennisches UND ('&') getrennt sind, am Ende einer Liste ein. Schluessel oder Wert duerfen allerdings nicht mit einem Leerzeichen enden.<II>syn>II</xaddtolist listenname&schluessel&wert<II>ex>II</xaddtolist fruechte&faule Birnen&8 Stueck<II>see>II</addtolist, /xaddbtolist, /xuaddtolist<II>fileinfo>II<lists.tf<II><I>
/set help___2004072012=<I>hloadlist>I<<II>type>II<comm<II>mak>II</custom, /ifecho, /haddlisttosave<II>info>II<Analog zu /loadlist fuer normale Listen werden mit /hloadlist ?Hashlisten geladen. Die Dateien heissen 'listenname.hlist'. Es koennen alle von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Laden ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</hloadlist [/custom-Optionen] listenname<II>var>II<%load_dir<II>see>II</hsavelist, /loadlist, /custom, Hashliste<II>fileinfo>II<lists.tf<II><I>
/set help___011120115=<I>hxaddtolist>I<<II>type>II<comm<II>func>II<hash<II>mak>II</paramparse<II>info>II<Fuegt ein Schluessel-Wert-Paar zu einer ?Hashliste hinzu. Dabei kann der Schluessel auch mehrteilig sein, Trennung der Parameter durch '&'.<II>syn>II</hxaddtolist listenname&schl ues sel&wert<II>var>II<%value<II>see>II</haddtolist<II>fileinfo>II<lists.tf<II><I>
/set help___258096889=<I>sieben_tri>I<<II>type>II<mak<II>info>II<Wegemakro fuer Siebensprung, der Parameter ist die Nummer der genutzten Richtung 1,2 oder 3<II>see>II<wegmakros, vorwaerts<II>fileinfo>II<sieben<II><I>
/set help___000008550=<I>von>I<<II>type>II<mak<II>mak>II<klp, cont_way<II>info>II<Schaltet 'verify' ein, d.h. bis /voff kommt wird, jeder Befehl auf Erfolg getestet. Wenn einer nicht erfolgreich ist, wird das mit der entsprechenden Fehlermeldung angezeigt. Mit dem Parameter 2 reagiert es so wie /npc. Nach dem kritischem Abschnitt muss verify mit /voff wieder ausgeschaltet werden.<II>syn>II</von [2]<II>ex>II<fuer einen Weg: n%;/von%;zu testender Schritt%;/voff%;s%;<II>var>II<verify<II>see>II<wegeingabe, von, voff<II>fileinfo>II<way.tf<II><I>
/set help___012115099=<I>hsortforeach>I<<II>type>II<mak<II>info>II<Hat die gleiche Funktionalitaet wie /hforEach (also fuer Hashlisten), die Werte werden aber alphabetisch sortiert bearbeitet.<II>syn>II</hsortForEach listenname k[v] /makroname<II>var>II<%value<II>see>II</hforEach<II>fileinfo>II<lists.tf<II><I>asortforeach>I<<II>type>II<comm<II>func>II<astart, alen<II>mak>II</aclear, /forEach, /aforEach, /asortForEach2, /asortForEach3<II>info>II<Erfuellt dieselbe Funktion wie ?/forEach fuer Listen, nur dass die Elemente sortiert bearbeitet werden. Dabei kann in der Variablen %sort_alg (moeglichst als lokale Variable) der Sortieralgorithmus eingestellt werden ('asort' oder 'amsort'), sowie in der Variablen %comp_func die Vergleichsfunktion ('asicmp', 'ascmp', 'ancmp').<II>syn>II</asortForEach listenname k[v] /makroname<II>var>II<%sort_alg, %comp_func<II>see>II</forEach, /asort, /amsort, asicmp, ascmp, ancmp<II>fileinfo>II<lists.tf<II><I>
/set help___012102115=<I>cfg_get_dest>I<<II>type>II<mak<II>ex>II</cfg_get_dest USE -> nix@{N}/cfg_get_dest STATUS MUD HITPOINTS -> -c@{N}/cfg_get_dest COMM MUD PLAYER TELL_FROM -> -c -p<II>fileinfo>II<config.tf<II><I>
/set help___011100102=<I>addnodeinfo>I<<II>type>II<comm<II>list>II<nodeinfo<II>info>II<Fuegt der Liste mit den Knoteninfos (nodeinfo) den angebebenen Knoten sowie ein Gebiet und einen Infostring hinzu. Die Bedienung erfolgt interaktiv.<II>fileinfo>II<way.tf<II><I>
/set help___000008551=<I>wgo>I<<II>type>II<comm<II>info>II<Testet ob er den aktuellen Raum kennt. Wenn ja, wird der Weg gegangen (via /_go), und wenn nicht, gibt es eine Fehlermeldung.<II>see>II<go, wo<II>fileinfo>II<way.tf<II><I>
/set help___2042331467=<I>key_press>I<<II>type>II<mak<II>info>II<Funktion die bei Tastendruck aufgerufen wird, wenn Display Modus (%keys_dmode) eingeschaltet ist wird die Belegung dargestellt, ansonsten der Befehl ausgefuehrt<II>syn>II</key_press belegung key<II>see>II<keys_dmode<II>fileinfo>II<keys.tf<II><I>
/set help___013111115=<I>loadnamedlist>I<<II>type>II<comm<II>info>II<Laedt die Liste, die den Namen %parameter_list_name hat und in den Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die der Parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</loadnamedlist paket_prefix<II>ex>II<Nach@{N}@{}  /set waffen_list_name=waffen@{N}@{}  /set waffen_list_location=ausruestung@{N}wuerde@{N}@{}  /loadnamedlist waffen@{N}die Liste `waffen` laden, welche im File 'ausruestung/waffen.list' gespeichert ist.<II>see>II</savenamedlist, /loadlist<II>fileinfo>II<lists.tf<II><I>sort_idx_list>I<<II>type>II<mak<II>info>II<Sortiert eine Wegknotensubliste nach der Laenge der Teilwege.<II>syn>II</sort_idx_list subliste<II>var>II<stemp_list<II>fileinfo>II<way.tf<II><I>
/set help___003691972=<I>amsort>I<<II>type>II<comm<II>mak>II</aclear, /amsort1<II>see>II</amsort1, asicmp, ascmp, ancmp<II>fileinfo>II<lists.tf<II><I>
/set help___012117115=<I>mud_darkness>I<<II>type>II<var<II>info>II<Die Ausgabe des Muds, wenn es dunkel ist. Wird gebraucht, um festzustellen, dass man den Raum gewechselt hat.<II>fileinfo>II<warok<II><I>
/set help___028095111=<I>cfg_mud_weapon2_no_container>I<<II>type>II<cfg<II>info>II<Welche Waffen sollen/können nicht in den Container gesteckt werden, Liste der Kürzel durch Leerzeichen getrennt<II>fileinfo>II<weapon2.tf<II><I>
/set help___2140448564=<I>reconnect>I<<II>type>II<comm<II>info>II<Beendet die Verbindung zur aktuellen Welt und baut sofort eine neue auf.<II>syn>II</reconnect [world]<II>fileinfo>II<worldconnect.tf<II><I>
/set help___588507572=<I>loadhrlist>I<<II>type>II<comm<II>mak>II</addlisttosave, /createlist, /custom, /ifecho<II>info>II<Laedt die angegebene Liste aus der Datei 'listenname.hr.list'. Dabei wird ihre Laenge als Veraenderungserkennung gemerkt. Es koennen alle von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Laden ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</loadhrlist [/custom-Optionen] listenname<II>see>II</savehrlist, /loadlist, /savelist<II>fileinfo>II<lists.tf<II><I>
/set help___000060879=<I>goto>I<<II>type>II<comm<II>info>II<Erkennt aus der Langbeschreibung, die das Kommando produziert das als erster Parameter übergeben wird den Zielraum (wenn bekannt) und geht dorthin. Der zweite Parameter wird zur Identifikation der Zeile vor der Raumbeschreibung gebraucht.<II>fileinfo>II<way.tf<II><I>
/set help___013111117=<I>config_status>I<<II>type>II<comm<II>info>II<Einfache Statuszeilendefinition, die fast direkt so angegeben wird, wie sie spaeter aussehen soll. Dabei wird fast alles direkt uebernommen, nur die angegebenen Variablen werden entweder aus vorgefertigten, mitgelieferten Modulen entnommen oder (vorher) on the fly erzeugt; wenn beides nicht moeglich ist, wird die Variable direkt uebernommen. Die Aenderungen sind sofort sichtbar.<II>syn>II</config_status Statuszeilendefinition<II>ex>II</config_status __LP:{lp}_MP:{p_mp:6}__abc__!!!__ABC__{a}_{@world}_{insert:1}@{N}* Alle __ werden direkt umgesetzt, auch die Strings, nur die Variablen in {} erhalten eine besondere Behandlung.@{N}* Wenn ein Makro (Modul) namens sl_%{varname} vorhanden ist, wird dieses ausgefuehrt, um z.B. Attribute, Breiten, Trigger, Standardwerte zu definieren, und sein Ergebnis in die Statuszeile integriert.@{N}* Wenn eine Variable status_line_%{varname} vorhanden ist, wird angenommen, dass die Variablen bereits per /set_status_var_(num|string) definiert wurde und die status_line_%{varname} wird in die Statuszeile integriert.@{N}* Ansonsten wird die Variable direkt unter ihrem Namen in die Statuszeile eingetragen, ohne besondere Formatierung und Laengenangaben.@{N}* wenn eine Laengenangabe mit : angegeben wird, ueberschreibt diese die Laengenangabe in dem Makro oder dem schon definierten Statuszeileneintrag<II>see>II<set_status_var_num, set_status_var_string, status_colors<II>fileinfo>II<status.tf<II><I>
/set help___012115108=<I>user_is_idle>I<<II>type>II<var<II>info>II<Variable, die anzeigt, ob der Nutzer gerade als Idle angesehen wird<II>fileinfo>II<worldconnect.tf<II><I>
/set help___022111116=<I>windows_run_timestamps>I<<II>type>II<mak<II>info>II<Erzeugt den Hook um aller windows_timestamp_interval einen Zeitstempel in jedes Log zu schreiben<II>see>II<windows_stop_timestamps<II>fileinfo>II<util.windows.tf<II><I>
/set help___247789132=<I>hashlist>I<<II>type>II<comm<II>mak>II</getfirstkey, /getfirstvalue, /haddtolist, /deletekeyandvalue<II>info>II<Wandelt eine normale Liste in eine ?Hashliste mit dem gleiche Namen um.<II>syn>II</hashlist listenname<II>var>II<%value<II>see>II<Hashliste<II>fileinfo>II<lists.tf<II><I>
/set help___029474636=<I>allowed>I<<II>type>II<mak<II>info>II<Testet, ob die aktuellen Properties erlauben, diesen Weg zu gehen.<II>return>II<ueber /echo. 1 bei Erfolg und 0 bei Misserfolg.<II>see>II<einschraenkungen<II>fileinfo>II<way.tf<II><I>
/set help___014108115=<I>hloadnamedlist>I<<II>type>II<mak<II>info>II<Laedt die Liste, die den Namen %parameter_list_name hat und in den Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</hloadnamedlist paket_prefix<II>see>II</hsavenamedlist, /loadnamedlist<II>fileinfo>II<lists.tf<II><I>
/set help___013108110=<I>clear_actions>I<<II>type>II<mak<II>info>II<Da es immer wieder mal passiert, dass die Zaehlung durcheinanderkommt, werden hiermit die Liste 'prompt_action' geloescht und die Variablen auf denselben Wert (action_count) gesetzt.<II>fileinfo>II<util.prompts.tf<II><I>
/set help___030847073=<I>getikey>I<<II>type>II<func<II>mak>II</geti<II>info>II<Liefert den Schluessel mit dem angegebenen Index zurueck. Der Index beginnt bei Null!<II>syn>II</getikey listenname index<II>return>II<Schluessel am Index, %error bei Misserfolg als Rueckgabewert und in %value<II>var>II<%value<II>see>II<index, /getivalue, /getidxofkey<II>fileinfo>II<lists.tf<II><I>
/set help___033530885=<I>portale>I<<II>type>II<see<II>info>II<Da die Portale in einem Wegesystem eine grosse Zeitersparnis bringen, werden sie auch extra behandelt. Es gibt einen Befehl zum Ein- und Ausschalten der Portale.@{N}Ausserdem gibt es einen Spezialknoten namens 'tport' (bzw. %portal_node), der das naechstgelegene Portal bezeichnet, und von dem aus nur die Portale funktionieren.<II>comm>II<port, noport<II>var>II<portals<II>see>II<Spezialknoten, Wege<II>fileinfo>II<way.tf<II><I>
/set help___033989947=<I>setdesc>I<<II>type>II<mak<II>info>II<legt eine Beschreibung fuer einen der neun Modi fest.<II>syn>II</setdesc Modus Beschreibung<II>fileinfo>II<keys.tf<II><I>
/set help___658910715=<I>map_locale>I<<II>type>II<mak<II>info>II<mappt die verschiedenen Auspraegungen einer locale (z.B. deutsch, german, de_DE, de_AU usw) auf eine locale. Dazu wird entweder bei de_DE nur der erste Teil genommen, bei german usw. sollte eine Variable locale_german mit de gesetzt sein.<II>syn>II</map_locale localebez<II>return>II<per result, Ziellocale oder Parameter<II>ex>II</test map_locale("german"), /map_locale %%LANG<II>see>II<add_loc, loc<II>fileinfo>II<i18n.tf<II><I>
/set help___034175366=<I>team.tf>I<<II>type>II<fileinfo<II>func>II<team_info_color, team_pad<II>info>II<Enthaelt Team-Makros fuer Aufnahme von Mitgliedern (s. team_auto_aufnahme), Autofolge-Toggle, Trigger zum Mitschreiben von Team-Autofolge Meldungen fuers Wegesystem und Mapper, Team Angriff Countdown, externe Team-History, kompakten "team info"-Befehl<II>req>II<way.tf util(1.38)<II>comm>II<team_angriff, team_history, tab_fl, team_autofolge, team_get_info, team_show_info, team_info, ti, team_allow, team_tab_fl<II>misc>II<dtyp flag<II>trig>II<t_team_auto<II>version>II<team.tf,v 1.13 2002/11/19 17:20:11 nieten (Mesirii@mg.mud.de)<II>var>II<cfg_mud_team_color1, cfg_mud_team_infocolor, team_auto_aufname<II>see>II</team_angriff, /team_history, /tab_fl, /team_autofolge, /team_auto_aufnahme, /team_info, /team_allow<II>fileinfo>II<team.tf<II><I>
/set help___004253656=<I>t_lpmp>I<<II>type>II<trig<II>info>II<Faengt die LP/MP-Meldung ab, setzt die Properties p_lp und p_mp und die Differenz p_m_lp und p_m_mp und ruft dann den Hook points auf.<II>var>II<p_mp, p_lp, p_m_lp, p_m_mp<II>fileinfo>II<mg_properties.tf<II><I>
/set help___003860949=<I>h_move>I<<II>type>II<hook<II>mak>II<vorwaerts<II>list>II<xtramoves<II>changes>II<1.03 unterstuetzt die Mapper Application (siehe ?walk).@{N}1.04 Einbindung des Mappers (?mapper.tf). Die Befehle, die ans Mud gesandt werden, bekommt auch der Mapper, sofern (%mapper==1). Wenn (%automapper==1) werden dem Mapper zuvor die Befehle zum Erzeugen der Ausgaenge uebermittelt.<II>info>II<Ueberprueft alle Eingaben auf Richtungsbefehle und speichert diese ab.Wenn die Wegaufzeichnung eingeschaltet wurde, werden _alle_ Eingaben abgespeichert. Natuerlich wird auch der Rueckweg gleich mit erzeugt.<II>version>II<1.04<II>hook>II<SEND<II>var>II<weg, wegeingabe<II>see>II<wege, hooks<II>fileinfo>II<way.tf<II><I>
/set help___031106523=<I>properties>I<<II>type>II<see<II>info>II<Die Properties enthalten alle moeglichen Werte des Spielers. Man kann sie sich am besten mit /who[ami] oder /who is name anzeigen lassen.@{N}Sie werden bei den Einschraenkungen der Wege verwandt und um spieler- bzw. gildenspezifische Makrodateien zu laden.<II>comm>II<whoami, who<II>see>II<wege, dateisystem, mud_properties<II>fileinfo>II<properties.tf<II><I>
/set help___000058584=<I>defh>I<<II>type>II<mak<II>info>II<Erzeugt Makros, die mit den Parametern '-h' und '-?' ihren entsprechenden Hilfetext darstellen. Das sollten @{B}alle interaktiven Makros@{n} sein.<II>see>II</def, /help<II>fileinfo>II<help.tf<II><I>
/set help___011117115=<I>xuaddtolist>I<<II>type>II<comm<II>mak>II</paramparse, /delallkeysandvalues<II>info>II<Fuegt einen Schluessel, in dem auch Leerzeichen enthalten sein koennen, und einen Wert, die durch ein kaufmaennisches UND ('&') getrennt sind, am Ende einer Liste ein, nachdem alle bisherigen Vorkommen des Schluessels geloescht wurden. Schluessel oder Wert duerfen allerdings nicht mit einem Leerzeichen enden oder beginnen.<II>syn>II</xuaddtolist listenname&schluessel&wert<II>ex>II</xuaddtolist fruechte&faule Birnen&8 Stueck<II>see>II</uaddtolist, /xaddtolist, /xaddbtolist<II>fileinfo>II<lists.tf<II><I>
/set help___1982313157=<I>hashliste>I<<II>type>II<misc<II>info>II<Hashlisten basieren darauf, dass tf-Variablen beliebig zur Laufzeit erzeugt werden koennen. Fuer jeden Schluessel in der Liste wird der Hashwert (siehe /hash) gebildet und dieser an eine Variable mit dem Namen der Liste angehaengt (z.B. 'weapons___329874923'). In dieser Variablen wird nun eine normale Liste aller Schluessel-Wert-Paare gespeichert, deren Schluessel denselben Hashcode erzeugen. Der Zugriff auf die TF-Variablen ist um ein Vielfaches schneller als die Arbeit mit riesigen Strings.<II>fileinfo>II<lists.tf<II><I>
/set help___030003009=<I>bug_way>I<<II>type>II<mak<II>mak>II<disable, vorwaerts<II>info>II<Wird ausgefuehrt, falls bei der ueberprueften Wegausfuehrung ein Fehler aufgetreten ist.@{N}Wenn verify=1 ist, wird gefragt, ob der Weg zwischen dem letzten und dem naechsten Knoten temporaer gesperrt werden soll. Es wird versucht, den Rueckweg zum letzten bekannten Knoten zu berechnen. Dieser kann dann mit /back zurueckgegangen werden. Ansonsten muss das Hindernis beseitigt werden und dann kann mit /c[ontinue] der Weg fortgesetzt werden.@{N}Ist verify==2, dann wird nur das Monster geknuddelt, das im Weg steht, und nach der Beseitigung ;) wird mit /c[ontinue] weitergegangen.<II>version>II<1.01<II>var>II<verify, fulldetail, real_way, temp_way, go_way3_param, online<II>fileinfo>II<way.tf<II><I>
/set help___000008559=<I>who>I<<II>type>II<comm<II>info>II<Zeigt entsprechend der Parameter die Properties an.@{N}'/who am i' zeigt die eigenen Properties an.@{N}'/who is name' zeigt die Properties des Spielers an.<II>syn>II</who [am i|is name]<II>fileinfo>II<properties.tf<II><I>
/set help___004122000=<I>p_m_lp>I<<II>type>II<var<II>info>II<Letze Aenderung der Lebenspunkte.<II>fileinfo>II<mg_properties.tf<II><I>
/set help___000008035=<I>npc>I<<II>type>II<mak<II>mak>II<klp<II>info>II<Testet, ob ein NPC im Weg steht. Wenn ja, haelt es an. Mit /continue geht es dann weiter. Da es 'verify' einschaltet, muss nach dem kritischen Befehl das verify mit /voff wieder ausgeschaltet werden.<II>var>II<verify<II>see>II<wegeingabe, von, voff<II>fileinfo>II<way.tf<II><I>
/set help___000007975=<I>lwo>I<<II>type>II<mak<II>info>II<Wartet, bis der richtige Raum errreicht ist, und macht dann /wo.<II>see>II<wegeingabe<II>fileinfo>II<way.tf<II><I>
/set help___014101111=<I>getnextvalueof>I<<II>type>II<func<II>info>II<Liefert bei aufeinanderfolgenden Aufrufen die verschiedenen Werte, die zu einem Schluessel in der Liste gespeichert sind.<II>syn>II</getnextvalueof listenname schluessel<II>return>II<der Wert zu diesem Schluessel oder %error, wenn keine (mehr) vorhanden sind, als Rueckgabewert und in %value<II>var>II<%value, %getnextvalueof, %getnextvalueof_off<II>fileinfo>II<lists.tf<II><I>getlistvalueof>I<<II>type>II<comm<II>mak>II</getvalueof, /makelistofvalue, /unmakesub<II>info>II<Holt die Subliste, die dem Schluessel zugeordnet ist, aus der Liste.<II>syn>II</getlistvalueof listenname schluessel<II>return>II<Subliste, die Schluessel zugeordnet ist, oder %error bei Misserfolg als Rueckgabewert und in %value<II>var>II<%value<II>see>II</getvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___015095118=<I>bs_teilemit_von>I<<II>type>II<cfg<II>info>II<Ausgabe der empfangenen Mitteilungen<II>fileinfo>II<crypt.tf<II><I>
/set help___014101112=<I>help_show_tips>I<<II>type>II<mak<II>info>II<Wenn Idle werden Tips aus der Datei lang/help_tips.ary auf der Statuszeile angezeigt. Wird vom Hook user_got_idle aufgerufen!<II>see>II</lauf, arrays, CFG_CONNECT_IDLE_TIME, user_got_idle<II>fileinfo>II<help.tf<II><I>
/set help___012110115=<I>knotenaliase>I<<II>type>II<see<II>info>II<Fuer die Wegknotennamen, die beim Erstellen der Wege vergeben wurden, koennen im Nachhinein Aliase vergeben werden, je nach persoenlichem Geschmack. Deshalb bitte die Knotennamen eindeutig und verstaendlich vergeben, damit auch ein anderer was damit anfangen kann.@{N}Intern wird trotzdem mit den Knotennamen gearbeitet ;)<II>see>II</setali, Knoten<II>fileinfo>II<way.tf<II><I>
/set help___014114097=<I>profile_unwrap>I<<II>type>II<mak<II>info>II<Stellt das Makro wieder her, dass in den Zeitmesscode eingebettet war, gibt ausserdem die gemessenen Zeiten aus<II>syn>II</profile_unwrap makroname<II>see>II<profile_info, profile_wrap<II>fileinfo>II<util.timer.tf<II><I>
/set help___2051663436=<I>addbtolist>I<<II>type>II<comm<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und einen Wert am Anfang einer Liste ein.<II>syn>II</addbtolist listenname schluessel wert<II>see>II</addtolist, /xaddbtolist, /getvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___836585147=<I>keys_dmode>I<<II>type>II<var<II>info>II<Flag fuer Display Mode (Anzeigen der Tastenbelegung bei Tastendruck, statt Ausfuehrung)<II>syn>II<0 aus 1 ein<II>fileinfo>II<keys.tf<II><I>
/set help___015116118=<I>watch_check_var>I<<II>type>II<mak<II>list>II<watch_list, watch_action_list<II>info>II<Ueberprueft, ob die als erster Parameter uebergebene Variable als Wert die uebrigen Parameter enthaelt. Ist dies nicht der Fall, wird eine entsprechende Meldung ausgegeben. Taucht die Variable in ?watch_action_list auf, so wird dann ausserdem das ihr zugewiesen Makro ausgefuehrt. In jedem Fall wird das Paar Variablename/aktueller Wert an die Liste watch_tmp_list angehaengt.<II>syn>II</watch_check_var Variablenname Wert<II>fileinfo>II<util.debug.tf<II><I>
/set help___1919993392=<I>default 0>I<<II>type>II<misc<II>info>II<Standardwert fuer die Anzahl der Zeilen, die beim Abspeichern einer Knotenbeschreibung genutzt werden sollen. Kann durch Parameter fuer /end, /replacenode und /addnode ueberschrieben werden. Bei einem Wert von 0 werden alle Zeilen benutzt (siehe ?mud_exits_output).<II>fileinfo>II<warok<II><I>
/set help___246821827=<I>getstack>I<<II>type>II<mak<II>info>II<Holt von der angegebenen Position eine Variable aus dem Stack. Wenn ein Variablenname uebergeben wird, wird der Wert in dieser Variablen gespeichert. Die Position muss innerhalb des Stackpointers liegen.<II>return>II<der Inhalt der Variablen<II>ex>II</getstack 1 test oder /getstack test 3 oder /getstack 2<II>see>II<stack_put, stack_push, stack_pop<II>fileinfo>II<util.stack.tf<II><I>
/set help___000504531=<I>lists>I<<II>type>II<list<II>info>II<Ist eine Liste, die die geladenen Listen und deren Laenge beim Laden enthaelt. Die Laenge wird dann mit der aktuellen Laenge verglichen, um etwaige Veraenderungen feststellen zu koennen.<II>see>II</savealllists, /addlisttosave, /loadlist, /loadhrlist<II>fileinfo>II<lists.tf<II><I>
/set help___000000911=<I>cw>I<<II>type>II<mak<II>mak>II<cont_way<II>info>II<Fuehrt seinen Parameter aus und setzt dann den Weg fort.<II>syn>II</cw Befehl<II>fileinfo>II<way.tf<II><I>
/set help___000061199=<I>ifdo>I<<II>type>II<mak<II>info>II<Conditional def, nur wenn der Ausdruck, der als 1. Parameter uebergeben wird 1 ist, wird der rest ausgefuehrt<II>syn>II</ifdo expr tf-code<II>ex>II</ifdo !islist(comm_ebenen_list)\@{N}/createlist comm_ebenen_list@{N}/addtolist comm_ebenen_list team Cblue Cyellow<II>fileinfo>II<util.tf<II><I>
/set help___1768073690=<I>completion>I<<II>type>II<comm<II>info>II<Vervollstaendigt den bisher eingegebenen Text automatisch. Dabei werden die Vorschlaege kontextsensitiv ermittelt. Wenn ein % vorher steht, werden Variablen, bei / werden Makronamen, bei ? einer der Knoten des Wegesystems, bei @ einer der anwesenden Spieler, bei & ein Item aus dem Invetory und ansonsten Text aus dem Mud (?completion_recall_count (default 200 Zeilen zurueck) verwendet. Durch mehrmaliges Druecken der Taste werden alle Moeglichkeiten durchgespielt.<II>adapt>II<completion_recall_count, mud_set_line_count, mud_inventory, mud_short_who<II>var>II<completion_list, completion_line, last_completion, completion_recall_count, mud_set_line_count, mud_invetory, mud_short_who<II>fileinfo>II<util.completion.tf<II><I>
/set help___1936030230=<I>editieren>I<<II>type>II<see<II>info>II<Beim Editieren von Wegen wird nach folgenden Angaben gefragt:@{N}Weg selbst, kann editiert werden, muss danach aber ausfuehrbar sein ;)@{N}Gueltigkeitsbereich: ue(b)erall, nur (n)ormalwelt, nur (p)arawelt (0-9).Parawelt.@{N}Einschraenkungen: all-keine, der Rest siehe Einschraenkungen.@{N}Laenge des Weges: = Gewicht beim Berechnen, also bei langwierigen Wegen hochsetzen.<II>see>II<einschraenkungen, dimension, editway, showway, delway<II>fileinfo>II<way.tf<II><I>
/set help___013101111=<I>reggetvalueof>I<<II>type>II<func<II>func>II<convert_regexp<II>info>II<Wie /getvalueof nur, dass der Schluessel als regexp angegeben wird (ohne Klammern rundherum).@{N}Die regexp kann am Anfang und/oder Ende mit '^' bzw. '$' verankert werden. Um zu verhindern, dass ein abschliessendes '$' als Endekennzeichen aufgefasst wird, muss dieses verdoppelt werden. ('$' muss natuerlich ggf. mit '\' maskiert werden.)<II>syn>II</reggetvalueof listenname Schluessel (als regexp)<II>return>II<Erster zum Schluessel passender Wert als Rueckgabewert und in %value, %error bei Misserfolg.<II>ex>II<Die regexp von@{N}@{}  /reggetvalueof fruechte [a-z]*nue?sse?@{N}wuerde auf "walnuss", "haselnuesse" und "nussknacker" passen. Sollen nur Nussarten gefunden werden, muesste man@{N}@{}  /reggetvalueof fruechte [a-z]*nue?sse?\$@{N}verwenden.@{N}@{}  /reggetvalueof waehrungen ^(US|us)-\\\$\$@{N}wuerde nur den Wert der Schluessel "US-$" oder "us-$" zurueckgeben.<II>var>II<%value<II>see>II</convert_regexp, /getvalueof, regexp, /reggetkey<II>fileinfo>II<lists.tf<II><I>remove_window>I<<II>type>II<comm<II>info>II<Loescht alle Trigger fuer das angegeben Fenster und schliesst das zugehoerige File<II>fileinfo>II<util.windows.tf<II><I>
/set help___246818107=<I>gettdesc>I<<II>type>II<mak<II>info>II<liefert die Beschreibung fuer eine Tastenbelegung zurueck.<II>syn>II</gettdesc Modus Taste<II>return>II<Beschreibung<II>fileinfo>II<keys.tf<II><I>
/set help___014116116=<I>util.abbrev.tf>I<<II>type>II<fileinfo<II>list>II<abbreviations<II>info>II<Abkuerzungen, die in multiple Mud-Kommandos expandiert werden<II>req>II<lists.tf util.sfuncs.tf<II>comm>II<def_abbrev, undef_abbrev<II>version>II<util.abbrev.tf,v 1.8 2001/11/27 21:34:06 mh14 (Mesirii@mg.mud.de)<II>hook>II<h_abbrev<II>fileinfo>II<util.abbrev.tf<II><I>util.repeat.tf>I<<II>type>II<fileinfo<II>mak>II<countdown, beat, repeat_once<II>info>II<Countdown,Heartbeats,Kommando-Counter<II>req>II<util.hooks.tf<II>comm>II<n, n2<II>version>II<util.repeat.tf,v 1.9 2002/09/10 14:45:23 thufhnik (Mesirii@mg.mud.de)<II>fileinfo>II<util.repeat.tf<II><I>
/set help___000001033=<I>ti>I<<II>type>II<comm<II>info>II<Siehe ?/team_info.<II>fileinfo>II<team.tf<II><I>
/set help___004122008=<I>p_m_mp>I<<II>type>II<var<II>info>II<Letze Aenderung der Magiepunkte.<II>fileinfo>II<mg_properties.tf<II><I>
/set help___000007582=<I>gof>I<<II>type>II<comm<II>info>II<Damit es nicht immer so muehselig ist, erst /wo und dann /go zu benutzen, habe ich den Befehl /gof hinzugefuegt, dessen erster Parameter der Ausgangsknoten ist.<II>ex>II</gof start ziel<II>see>II<go, wo<II>fileinfo>II<way.tf<II><I>
/set help___000504535=<I>listw>I<<II>type>II<mak<II>mak>II<setw, unsetw, echow, getw<II>info>II<Listet alle Variablen auf, die lokal fuer diese Welt gesetzt sind.<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___026100111=<I>cfg_mud_weapon2_auto_input>I<<II>type>II<cfg<II>info>II<Unbekannte Waffen werden beim Zuecken in der Eingabezeile angeboten<II>fileinfo>II<weapon2.tf<II><I>
/set help___000001034=<I>ub>I<<II>type>II<misc<II>info>II<Untersucht den Boden.<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___018115116=<I>keys_list_location>I<<II>type>II<cfg<II>fileinfo>II<keys.tf<II><I>
/set help___000001036=<I>ud>I<<II>type>II<misc<II>info>II<Untersucht die Decke.<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___000000976=<I>lp>I<<II>type>II<comm<II>info>II<Setzt den aktuellen Knoten. Dabei wird nicht geprueft, ob dieser Knoten schon existiert. Das kann genutzt werden, wenn /wo versagt, oder wenn man von diesem neuen Knoten aus eine Weg erstellen will.(Dann aber nach dem /lp /appendnode aufrufen.)@{N}Der Puffer fuer die Wegaufzeichnung wird geloescht!!<II>var>II<showpoint, lastpoint<II>see>II<wo, knoten<II>fileinfo>II<way.tf<II><I>
/set help___013116114=<I>status_colors>I<<II>type>II<func<II>info>II<Funktion, die in status_var_xxx vor der eigentlichen Variablen aufgefuehrt werden muss, und die die Statuszeile bei jedem Aufruf (aber max. 1x pro Sekunde) neu setzt und damit die Farben bzw. Attribute an die Werte aller Variablen anpassen kann.<II>ex>II</def status_color_a=/return (a<10)?"Cgreen":"Cred"@{N}/set status_field=a:10:$[status_color_a()]@{N}oder@{N}/set status_var_a=status_colors(a)@{N}Statuszeile@{N}/set status_field=a:10:$[(a<10)?"Cgreen":"Cred"]@{N}Basisstatuszeile, oder einmal /status_colors aufrufen@{N}/set status_fields=a:10<II>fileinfo>II<status.tf<II><I>
/set help___1807967155=<I>del_schaue>I<<II>type>II<mak<II>info>II<Verzoegert und fuehrt das '%mud_look_command' fuer den Raum aus. Vor der Raumbeschreibung wird durch /echo eine Leerzeile erzeugt.<II>var>II<%mud_look_command<II>see>II<%mud_look_command<II>fileinfo>II<untroom.tf<II><I>
/set help___004034403=<I>mapnpc>I<<II>type>II<mak<II>mak>II<restricttoexit,<II>info>II<das Makro parst die NPCS, die als Ergebnis von /mapinfo erhalten wird<II>req>II<way.tf<II>var>II<mapper<II>fileinfo>II<mapper.tf<II><I>
/set help___011105101=<I>find_usages>I<<II>type>II<mak<II>info>II<Listet alle Verwendungen des angegebenen Strings (Variable, Makroname) in allen Makros, die dem vorgegebenen Suchmuster (fuer list) entsprechen.<II>syn>II</find_usages varname [List Pattern]<II>return>II<per /result und in find_usage_list<II>ex>II</find_usages addtolist *find*@{N}/find_usages wecho_attr<II>fileinfo>II<util.vfunc.tf<II><I>dimensionen>I<<II>type>II<see<II>info>II<Da es neben der Normalwelt auch noch die Parawelt gibt und einige Weg dort nicht und andere nur dort funktionieren, ist die Einschraenkung Dimension mit in das Wegesystem integriert worden. @{N}Gueltige Werte dafuer sind (b)eide (n)ormal (p)arawelt, ([0-9]).Parawelt@{N}Bei der Wegeingabe kann so ein Weg entsprechend gekennzeichnet werden und diese Wege werden dann auch entsprechend beruecksichtigt.<II>var>II<dimension<II>see>II<para, nopara, ao, ways, wegeingabe, editway<II>fileinfo>II<way.tf<II><I>
/set help___238182687=<I>cfg_info>I<<II>type>II<mak<II>info>II<Fuegt in die Configurations-Hierarchie eine neue Variable ein. Dabei wird ueber die Config-Hierarchie-Namen der Platz im Baum angegeben.@{N}Der letzte Parameter ist eine Kurzbeschreibung fuer das Menue (Leerzeichen durch _ ersetzen).@{N}Wenn der vorletzte Parameter grossgeschrieben ist, weist er direkt auf eine zu konfigurierende Variable, sonst auf eine weitere Menuebene.@{N}Wenn hinter der Beschreibung ein ':' (Doppelpunkt) folgt, kann dahinter ein abweichender Variablenname angegeben werden (sonst wird er aus den Config-Hierarchie-Namen gebildet), auch koennen durch Doppelpunkt getrennte Zahlen folgen, die anzeigen, welche Config-Hierarchie-Namen bei der Variablennamensbildung ignoriert werden sollen.<II>syn>II</cfg_info Config-Hierarchie-Namen [name|NAME] Menue_Text:[varname|ignoriere_hierarchieX[:ignoriere_hierarchieY]<II>ex>II</cfg_info use Paketverwaltung@{N}/cfg_info use LOADING Laden_von_Files@{N}/cfg_info all loading SUFFIX Dateiendungen:file_suffixes -> anderer Varname@{N}/cfg_info status mg tanjian Tanjian:2 -> anderer Varname (CFG_STATUS_TANJIAN, 2==MG faellt weg)<II>fileinfo>II<config.tf<II><I>
/set help___003788537=<I>do_tri>I<<II>type>II<mak<II>mak>II<cont_way<II>info>II<Fuehrt den vor der '(' uebergebenen Befehl aus und fuehrt den Weg fort, wenn der Trigger innerhalb der Klammern anspringt.<II>syn>II</do_tri befehl(triggertext)<II>ex>II</do_tri druecke knopf(Der Aufzug kommt an)<II>see>II<wegeingabe, utri, regexp, tri, break_tri<II>fileinfo>II<way.tf<II><I>
/set help___013101117=<I>getidxofvalue>I<<II>type>II<func<II>func>II<count_entries, isVar<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>info>II<Liefert den Index eines Wertes innerhalb einer Liste. Die Zaehlung beginnt bei 0. Das Ergebnis wird zurueckgegeben und in %value gespeichert. Ist der Wert nicht in der Liste, so ist das Ergebnis %error. Ist der Wert mehrmals in der Liste, wird der kleinste passende Index zurueckgegeben.<II>syn>II</getidxofvalue (liste|listenname) wert<II>return>II<Index oder %error als Rueckgabewert und in %value.<II>ex>II<Sowohl@{N}@{}  /test index:=getidxofvalue("skills_list","miserabel")@{N}als auch@{N}@{}  /test index:=getidxofvalue(skills_list,"miserabel")@{N}liefern den gleichen Wert.<II>var>II<%value<II>see>II</getidxofkey<II>fileinfo>II<lists.tf<II><I>getkeyofvalue>I<<II>type>II<func<II>info>II<Liefert zum gegebenen Wert den Schluessel. Wenn der Wert in der Liste nicht eineindeutig ist, wird der erste gefundene Schluessel geliefert.<II>syn>II</getkeyofvalue listenname wert<II>return>II<Schluessel mit diesem Wert, %error bei Misserfolg als Rueckgabewert und in %value<II>var>II<%value<II>see>II</getvalueof<II>fileinfo>II<lists.tf<II><I>getfirstvalue>I<<II>type>II<func<II>mak>II</getfirstkey, /getvalueof<II>info>II<Liefert den ersten Wert der Liste zurueck.<II>syn>II</getfirstvalue listenname<II>return>II<erster Wert der Liste oder %error bei Misserfolg Rueckgabewert und in %value<II>var>II<%value<II>fileinfo>II<lists.tf<II><I>
/set help___2107547361=<I>team_info>I<<II>type>II<comm<II>info>II<Eine kompakte Version des ueblichen "team info". Es werden nur Name, aktuelle LP, aktuelle KP, Vorsicht, Autofolge und - fuer den Teamleiter - Fluchtrichtung und Angriffsbefehl angezeigt.@{N}Per Default ist @{B}/ti@{x} als Kuerzel dafuer definiert, falls beim Laden von "team.info" kein Makro mit diesem Namen existiert.<II>fileinfo>II<team.tf<II><I>
/set help___2065646470=<I>mapper.tf>I<<II>type>II<fileinfo<II>mak>II<getroom2, mapshort, maplong, mapnpc, mapauthor, cmapnpc<II>list>II<mapinfo<II>tut>II<Starten mit /init_mapper und dann bei bedarf /mapexits bzw. /mapinfo aufrufen.<II>info>II<hier sind Befehle enthalten, die die Fernsteuerung des Mappers vom TF aus unterstuetzen. (<a href="map/Mapper.html">siehe auch dort</a>)@{N}Ausserdem sind auch in ?way.tf Anpassungen bei den Send Hooks vorgenommen worden, so dass Bewegung im Mud auch Bewegung auf dem Mapper hervorruft.<II>req>II<!lists.tf way.tf util.trigger.tf(1.22)<II>comm>II<init_mapper, mapinfo, map, ai<II>cfg>II<mi_list, mapper_port, mapper_host, mapper_prefix, automapper, cfg_map_ignore_npcs<II>version>II<mapper.tf,v 1.5 2002/05/03 14:09:25 mh14 (Mesirii@mg.mud.de)<II>hook>II<def_mapper_send<II>var>II<mud_exits_output, mud_exits_regexp, mapper<II>see>II<mapper, automapper, mapinfo, mi, ai<II>fileinfo>II<mapper.tf<II><I>
/set help___031076230=<I>help.tf>I<<II>type>II<fileinfo<II>mak>II<help_show_tips, addh, addh_fileinfo, fi_add0, fi_add, defh, show_help, show_help_html, make_hrefs, create_help_file<II>list>II<help_keywords<II>tut>II<Die Benutzung in den eigenen Files ist ganz einfach:@{N}Diese Schluesselworte koennen verwendet und natuerlich auch erweitert werden:@{N}@{N}info 0 Info:@{N}syn 0 Syntax:@{N}misc 0 Sonstiges:@{N}adapt 1 Anpassen an Mud:@{N}ex 0 Beispiel:@{N}return 1 Rueckgabewert:@{N}see 0 Siehe auch:@{N}comm 0 Kommandos:@{N}mak 1 Makros:@{N}hook 1 Hooks:@{N}trig 1 Trigger:@{N}over 1 TF-Befehle:@{N}func 1 TF-Funktionen:@{N}var 1 Variablen:@{N}list 1 Listen:@{N}fileinfo 0 Datei:@{N}type 2 Typ:@{N}dtype 2 Datentyp:@{N}@{N}@{N}Ein Hilfeeintrag sieht z.B. so aus:@{N}@{N}/addh info \@{N}Holt eine/viele Variable aus dem Stack. Wenn Variablenname(n) uebergeben werden, wird der Wert in dieser Variablen gespeichert.@{N}/addh ex /pop@@@{}{N}\@{N} /pop test@@@{}{N}\@{N} /pop test test2@{N}/addh return der Inhalt der letzten Variablen@{N}/addh see push, getstack, putstack@{N}/addh pop mak@{N}@{N}@{N}Die Hilfe im tf sieht dann so aus:@{N}@{N}@{B}Makros: pop@{n}@{N}@{B}Info:@{n} Holt eine/viele Variable aus dem Stack. Wenn Variablenname(n) uebergeben @{N}werden, wird der Wert in dieser Variablen gespeichert.@{N}@{B}Beispiel:@{n} /pop@{N}/pop test@{N}/pop test test2@{N}@{B}Siehe auch:@{n} push, getstack, putstack@{N}@{B}Datei:@{n} util.tf@{N}@{N}Aus der Hilfe koennen dann auch HTML-Seiten erzeugt werden. Durch eine Angabe am Ende der Files kann eine Zusammenfassung fuer das Makrofile erzeugt werden.@{N}Da die Erzeugung der Hilfeinformationen nur auf Wunsch geschieht, sind die Ladezeiten ansonsten kaum beeinflusst.@{N}Es gibt eine Moeglichkeit, Makros mit /defh zu definieren, so dass sie interaktiv Hilfe liefert. Z.B. zeigt "/showway -?" oder "/showway -h" den Hilfeeintrag an.<II>info>II<Enthaelt die fuer das Hilfesystem notwendigen Befehle. Die Hilfetexte werden in den Listen 'help' und 'helpindex' abgespeichert.<II>req>II<!lists.tf(1.28) util.sfunc.tf util.echo.tf util.hooks.tf<II>comm>II<make_help, hilfe, make_help_html, make_html_file, hilfe_html, create_help, create_help_filelist<II>cfg>II<cfg_help_show_tips, cfg_help_build<II>version>II<help.tf,v 1.30 2002/12/05 10:34:33 mh14 (Mesirii@mg.mud.de)<II>var>II<tf_html<II>see>II</make_help, /create_help, CFG_HELP_BUILD<II>fileinfo>II<help.tf<II><I>
/set help___000531179=<I>setos>I<<II>type>II<mak<II>info>II<Setzt die Variable OS auf das verwendete Betriebssystem (bisher 'win' und 'linux').<II>var>II<OS<II>fileinfo>II<util.tf<II><I>
/set help___271899247=<I>set_flag>I<<II>type>II<mak<II>info>II<Setzt die Variable auf 1 wenn sie bisher nicht definiert oder Null war. Ansonsten wird eine Selbstzuweisung durchgefuehrt.<II>syn>II</set_flag var1<II>ex>II</set_flag a<II>see>II</self_update<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___013116116=<I>util.debug.tf>I<<II>type>II<fileinfo<II>mak>II<debug, vdebug, test_result, watch_loop, watch_check_var<II>list>II<watch_list, watch_action_list<II>info>II<Debug-Funktionen, Variablenueberwachung<II>req>II<lists.tf<II>comm>II<watch_var<II>version>II<util.debug.tf,v 1.8 2002/03/27 01:33:19 mh14 (Mesirii@mg.mud.de)<II>var>II<watch_time, watch_active<II>fileinfo>II<util.debug.tf<II><I>util.hooks.tf>I<<II>type>II<fileinfo<II>mak>II<add_to_hook, add_to_hook_begin, remove_from_hook, remove_hook, eval_hook<II>info>II<Hooks=einfach erweiterbare Makrolisten, die bei bestimmten Gelegenheiten aufgerufen werden koennen<II>req>II<<II>version>II<util.hooks.tf,v 1.9 2002/04/16 12:20:21 mh14 (Mesirii@mg.mud.de)<II>see>II<hooks<II>fileinfo>II<util.hooks.tf<II><I>util.quote.tf>I<<II>type>II<fileinfo<II>info>II<Makros und Hooks zur Unterstuetzung von Copy&Paste.<II>req>II<util.trigger.tf util.echo.tf<II>comm>II<my_quote, spare_linefeeds, mud_quote<II>version>II<util.quote.tf,v 1.7 2003/10/29 23:31:04 nieten (Mesirii@mg.mud.de)<II>hook>II<quote_multiline<II>var>II<%quote_multiline_start<II>fileinfo>II<util.quote.tf<II><I>util.sfunc.tf>I<<II>type>II<fileinfo<II>func>II<sprintf<II>mak>II<tokenize, strnstr, capitalize, hash1, reval<II>info>II<Stringfunktionen, Aufspalten, Hashcode, Sprintf<II>req>II<<II>version>II<util.sfunc.tf,v 1.8 2002/09/08 17:26:37 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<util.sfunc.tf<II><I>util.stack.tf>I<<II>type>II<fileinfo<II>mak>II<stack_push, stack_put, getstack, stack_pop<II>info>II<Diverse Stackfunktionen<II>req>II<<II>version>II<util.stack.tf,v 1.6 2001/11/30 13:44:12 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<util.stack.tf<II><I>util.timer.tf>I<<II>type>II<fileinfo<II>mak>II<timer, mstimer, profile, profile_wrap, profile_unwrap, profile_info<II>info>II<Timer in Sekunden und Millisekunden (patched tf)<II>req>II<<II>version>II<util.timer.tf,v 1.7 2002/03/29 22:28:03 mh14 (Mesirii@mg.mud.de)<II>var>II<timer_makro<II>fileinfo>II<util.timer.tf<II><I>util.vfunc.tf>I<<II>type>II<fileinfo<II>func>II<inner_var<II>mak>II<setw, getw, listw, unsetw, echow, find_usages, find_usages_add_name, init_var, get_param, random_param, dep_var, undep_var, dset, self_update, set_flag, set_var<II>info>II<Variablenfunktionen, isVar, purge_vars, World lokal Variablen<II>req>II<<II>misc>II<compile_regexp, free_regexp<II>version>II<util.vfunc.tf,v 1.26 2004/01/22 07:00:10 thufhnik (Mesirii@mg.mud.de)<II>see>II<world_local<II>fileinfo>II<util.vfunc.tf<II><I>status_breite>I<<II>type>II<mak<II>info>II<Liefert den Platz der in der aktuell eingestellten Statuszeile verbraucht wird.<II>fileinfo>II<status.tf<II><I>
/set help___014111120=<I>convert_regexp>I<<II>type>II<func<II>info>II<Konvertiert eine uebergebene regexp so, dass mit ihr innerhalb von Listen gesucht werden kann. Der erste Parameter gibt an, ob die regexp auf einen Schluessel ('k') oder einen Wert ('v') passen soll. Die regexp kann am Anfang und/oder Ende mit '^' bzw. '$' verankert werden. Um zu verhindern, dass ein abschliessendes '$' als Endekennzeichen aufgefasst wird, muss dieses verdoppelt werden. ('$' muss natuerlich ggf. mit '\' maskiert werden.)<II>syn>II</convert_regexp (k|v) regexp<II>return>II<die konvertierte regexp als Rueckgabewert mit /result<II>ex>II</let reg=$[convert_regexp("k", "^(K|k)ette")]@{N}wuerde in %reg eine regexp speichern, die auf alle Schluessel passt, welche mit "Kette" oder "kette" beginnen. Durch@{N}@{}  /let reg=$(/convert_regexp v ([uU]s-|kanadische )\\\$\$@{N}wuerde ein regexp erzeugt, die auf alle Werte passt, welche mit "kanadische $", "us-$" oder "Us-$" enden.<II>see>II</reggetkey, /reggetvalue, /reggetvalueof, regexp<II>fileinfo>II<lists.tf<II><I>compile_regexp>I<<II>type>II<misc<II>info>II<Falls die Erweiterung 'REGCOMP' vorhanden ist, wird die uebergebene Variable, die eine regexp enthaelt, vorkompiliert.<II>syn>II</compile_regexp glob_pattern<II>ex>II</compile_regexp way_regexp_*<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___000067304=<I>stop>I<<II>type>II<mak<II>info>II<Haelt den Weg an. Er kann dann mit /continue fortgesetzt werden. Es wird der Kurzmodus (?mud_short_output) eingestellt und eine Meldung ausgegeben.<II>fileinfo>II<way.tf<II><I>
/set help___016100112=<I>mud_short_output>I<<II>type>II<misc<II>info>II<Kommando zum Anzeigen nur kurzer Bewegungsmeldungen durchs MUD.<II>see>II<way.tf<II>fileinfo>II<warok<II><I>mud_exits_output>I<<II>type>II<var<II>info>II<Die Art, wie Ausgaenge der Raeume angegeben werden (als regexp), so dass in P2 alle Ausgaenge stehen.<II>fileinfo>II<warok<II><I>
/set help___1770265067=<I>color_line>I<<II>type>II<mak<II>info>II<Faerbt die ganze Zeile entsprechend des glob Triggers und der als ersten Parameter uebergebenen Attribute ein<II>ex>II</color_line BCwhite \* MPA<II>fileinfo>II<util.echo.tf<II><I>
/set help___000471978=<I>echo2>I<<II>type>II<comm<II>info>II<Erweitert die Funktionalitaet des '-p'-Parameters von /echo um das Attribut '@@@{}{N}', welches einen Zeilenumbruch hervorruft.<II>see>II<echo, attributes<II>fileinfo>II<util.echo.tf<II><I>
/set help___045105103=<I>result anzahl der eintraege als rueckgabewert>I<<II>type>II<misc<II>info>II<Liefert die Anzahl der Schluessel in der angegebenen ?Hashliste zurueck.<II>syn>II</hcount_entries listenname<II>fileinfo>II<lists.tf<II><I>
/set help___003790565=<I>custom>I<<II>type>II<mak<II>info>II<Wertet den '-c'-Parameter der Speicher- und Ladekommandos aus und gibt das entsprechende offset directory zurueck. Ggf. muss noch das Basis-Makro Directory davorgehaengt werden (bei Speicherkommandos).<II>syn>II<-m bedeutet multiple Files der Filename ist dann ein Pattern z.B. *.tf, es wird dann die Variable load_multi auf 1 gesetzt@{N}-a erzeugt absolute Pfade, dh. vor den offset wird noch %makdir gehaengt@{N}-c nimmt ${world_host} als Offset oder, wenn ${world_host} nicht gesetzt ist, dann %default_world_host.@{N}-cp nimmt ${world_host} als Offset oder, wenn ${world_host} nicht gesetzt ist, dann %default_world_host und als zweiten Offset ${world_character} bzw. %default_world_character.@{N}-coffset nimmt offset als Offset ,)<II>version>II<1.02<II>opt>II<-U wenn CFG_USE_FILE (z.b. CFG_USE_LOADING) existiert und 0 ist wird das File nicht geladen, sonst ja@{N}-Etf-expr wenn die TF-Expression true ist, wird das File geladen sonst nicht@{N}-p[char] Character@{N}-g[gilde] Gilde@{N}-c[host] Host (Mud)@{N}-l[lang] Mudsprache (Language)@{N}-L[lang] Nutzersprache (Language)@{N}-q quiet (ohne Meldungen)@{N}-vvarname Inhalt der Variablen (z.b. -vp_guild -> gildenbez.)@{N}-ddirname dirname uebernommen (z.b. -dnpcs -> npcs.)<II>ex>II<'-cmg.mud.de' liefert 'mg.mud.de/' als Offset fuer mudspezifische Dateien und@{N}'-c -p' liefert bei mir 'mg.mud.de/mesirii/'@{N}'-Ep_sub_guild=~"Abwehr" laedt das File nur wenn der Zaubererzweig "Abwehr" ist<II>fileinfo>II<loading.tf<II><I>
/set help___1978024796=<I>h_send_fl>I<<II>type>II<hook<II>info>II<Hook der statt /fl no%;s%;w%;/go home%; auch fl no%;s%;w%;/go home%; erlaubt<II>fileinfo>II<vorsicht.tf<II><I>
/set help___233368012=<I>add_most>I<<II>type>II<comm<II>list>II<most<II>info>II<Fuegt das aktuelle Detail zu der Liste der zu uebergehenden Worte hinzu. Das naechste Detail wird dann zum Untersuchen angeboten.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II</reunt, /typo, /nichts, /nichts_unt, most<II>fileinfo>II<untroom.tf<II><I>
/set help___030625360=<I>fi_add0>I<<II>type>II<mak<II>mak>II</forEach, /addh, f/i_add<II>info>II<Hilfsmakro, das die einzelnen Teillisten oder Subtopics eines Eintrags in die Hilfeliste schreibt.<II>var>II<%temp_list, %fi_list, %help_list, %help_keywords<II>fileinfo>II<help.tf<II><I>
/set help___1998256523=<I>capitalize>I<<II>type>II<mak<II>info>II<Liefert den uebergebenen Text mit Grossbuchstaben am Anfang zurueck.<II>fileinfo>II<util.sfunc.tf<II><I>
/set help___222028179=<I>set_points>I<<II>type>II<mak<II>info>II<Aktualisiert Lebenspunkte und Magiepunkte und berechnet die Differenz zum letzten Stand, ausserdem wird p_update_time gesetzt. Wird zum Hook points standardmaessig hinzugefügt.<II>fileinfo>II<mg_properties.tf<II><I>
/set help___003754305=<I>delway>I<<II>type>II<comm<II>info>II<Loescht Wege (mit jeweiliger Abfrage).<II>syn>II<'/delway * knoten' loescht alle Wege an, die zum Knoten hinfuehren.@{N}'/delway knoten *' loescht alle Wege an, die vom Knoten wegfuehren.@{N}'/delway knoten1 knoten2 loescht' den Weg zwischen den Knoten an.<II>see>II<wege editieren, showway, editway<II>fileinfo>II<way.tf<II><I>
/set help___020095111=<I>set_status_var_count>I<<II>type>II<mak<II>info>II<Setzen von Statuszeilendefinitionsmodulen on the fly fuer Variablen die aufsteigende numerische Werte enthalten (0..max oder min..0..max)<II>syn>II</set_status_var_count varname (default|varname) breite max [min]<II>ex>II</set_status_var count p_align p_align 1 3 -3<II>fileinfo>II<status.tf<II><I>
/set help___240703087=<I>col_echo>I<<II>type>II<mak<II>info>II<Gibt solange Text in laut /init_col_echo gestalteten Zeilen aus, bis es ohne Parameter aufgerufen wird. Der Text wird spaltenweise formatiert. Wenn Text zu lang ist, ragt er bis auf die naechsten Spalten ueber.<II>syn>II</col_echo Text oder kein Parameter zum Beenden<II>fileinfo>II<util.echo.tf<II><I>
/set help___000060233=<I>geti>I<<II>type>II<func<II>info>II<Liefert den Teil der Liste zurueck, der am Index beginnt. Diese Funktion ist zum internen Gebrauch bestimmt. Der Index beginnt bei Null!<II>syn>II</geti listenname index<II>return>II<Liste ab Index als Rueckgabewert und in %value oder %error, falls index zu gross ist<II>var>II<%value<II>see>II<index, /getikey, /getivalue, /delikeyandvalue<II>fileinfo>II<lists.tf<II><I>
/set help___2105795276=<I>tf_prompt>I<<II>type>II<mak<II>info>II<Zum Erkennen, ob das Mud eine Reihe von Kommandos ausgefuehrt hat, wird das Kommando in %mud_custom_prompt an das Mud geschickt. Dabei kann der Parameter %1 zur Identifizierung benutzt werden. In der Variablen %mud_custom_prompt_response ist die Antwort des Muds enthalten. Dabei wird derselbe Parameter %1 zur Identifizierung genutzt. Nachdem das Kommando ans Mud geschickt wurde, wird der entsprechende Trigger definiert, der als Aktion den als Parameter %2 uebergebenen Text ausfuehrt.<II>syn>II</test tf_prompt(Identifikationstext,Aktion)<II>ex>II</test tf_prompt("Das ist ein Test","/echo Test erfolgreich")<II>fileinfo>II<util.trigger.tf<II><I>
/set help___016100117=<I>add_action_count>I<<II>type>II<mak<II>info>II<Erhoeht den Zaehler fuer die ans Mud geschickten Befehle. Ist vor allem fuer SEND-Hooks notwendig, die die Daten per /send ans Mud schicken, und ueberall sonst, wo /send benutzt wird.<II>syn>II</add_catchup_action Zahl der Kommandos<II>fileinfo>II<util.prompts.tf<II><I>
/set help___021114109=<I>mud_recognize_command>I<<II>type>II<var<II>info>II<Ein Kommando, dessen Ausgabe tf erkennen kann, welches nicht auffaellig ist und auch keine Aktionen im Mud erzeugt.<II>see>II<mud_recognize_output, way.tf<II>fileinfo>II<warok<II><I>
/set help___000500910=<I>lazyf>I<<II>type>II<mak<II>info>II<Lazy Call im Funktionskontext. Es wird erst gecheckt ob die Funktion existiert, bevor sie mit ihren Parametern ausgefuehrt wird. Falls sie nicht existiert, wird mit /debug eine Fehlermeldung erzeugt.<II>syn>II</test lazyf("makroname",parameter..)<II>ex>II</test lazyf("foo",bar) -> /test foo(bar) oder Not Found foo<II>fileinfo>II<util.tf<II><I>
/set help___552831517=<I>trig_purge>I<<II>type>II<mak<II>info>II<removes the triggers defined with trig_grab, whose number was returned by trig_grab<II>syn>II</trig_purge number returned by trig_grab<II>fileinfo>II<util.trigger.tf<II><I>
/set help___018103101=<I>trig_purge_timeout>I<<II>type>II<var<II>info>II<Time to purge alle Triggers defined by a call of trig_grab<II>fileinfo>II<util.trigger.tf<II><I>
/set help___012100116=<I>addallpoints>I<<II>type>II<comm<II>info>II<Fuegt fuer alle Knoten des Wegesystems eine Erkennung hinzug (mit Abfrage).<II>fileinfo>II<way.tf<II><I>
/set help___267554405=<I>show_cache>I<<II>type>II<mak<II>info>II<Zeigt den Inhalt des Wegecaches sortiert an.<II>see>II<cache, remove_from_cache, clear_cache<II>fileinfo>II<way.tf<II><I>
/set help___234442599=<I>after_go>I<<II>type>II<var<II>info>II<die Variable %after_go kann beliebige Kommandos (Mud oder tf) enthalten, die nach erfolgreichem Ablaufen eines Weges ausgefuehrt werden. Der Trenner fuer tf sollte aber escaped werden.<II>ex>II</set after_go /echo Jetzt bin ich fertig\%;tanze\%;@{N}/go ziel@{N}Jetzt bin ich fertig@{N}Du tanzt.<II>see>II<go<II>fileinfo>II<way.tf<II><I>
/set help___253012500=<I>initfind>I<<II>type>II<mak<II>list>II<froml_w, tol_w, froml_k, tol_k<II>info>II<Initialisiert die Listen fuer das Wegberechnen.<II>var>II<nofrom, noto, fromlen, tolen, frommaxlen, tomaxlen<II>fileinfo>II<way.tf<II><I>
/set help___004389393=<I>whoami>I<<II>type>II<comm<II>info>II<Zeigt die eigenen Properties an.<II>comm>II<who<II>see>II<properties<II>fileinfo>II<properties.tf<II><I>
/set help___270943820=<I>savelist>I<<II>type>II<comm<II>mak>II</deletekeyandvalue, /getvalueof, /custom, /addtolist, /deletekeyandvalue, /ifecho<II>info>II<Speichert die angegebene Liste ab. Die Datei heisst 'listenname.list'. Eine ggf. vorhandene Aenderungsmarkierung wird geloescht. Es koennen die von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Speichern ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</savelist [/custom-Optionen] listenname<II>var>II<%temp_handle, %value<II>see>II</savehrlist, tfio, /custom<II>fileinfo>II<lists.tf<II><I>
/set help___019097108=<I>delallkeysandvalues>I<<II>type>II<comm<II>mak>II</deletekeyandvalue<II>info>II<Loscht alle Paare Schluessel-Wert.<II>syn>II</delallkeysandvalues listenname schluessel<II>return>II<%error bei Misserfolg (Schluessel nicht gefunden) als Rueckgabewert und in %value<II>var>II<%value<II>see>II</deletekeyandvalue, /delikeyandvalue, /getdvalueof, /getdlistvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___2114020285=<I>showchars>I<<II>type>II<mak<II>info>II<Zeigt die Dezimal, Hexcodes und die Character der Zeichen von 20 bis 127 an.<II>fileinfo>II<util.tf<II><I>
/set help___011100111=<I>add_to_hook>I<<II>type>II<mak<II>mak>II<hook_%hookname<II>changes>II<1.01 testet, ob hook existiert<II>info>II<Fuegt zu dem angegebenen Hook Anweisungen hinzu. Dabei sollte die letzte nicht mit '%;' abgeschlossen werden. Im Hook kann auf die Makroparameter Bezug genommen werden.<II>syn>II</add_to_hook hookname anweisungen<II>version>II<1.01<II>ex>II</add_to_hook reload /mload %param<II>fileinfo>II<util.hooks.tf<II><I>edit_macros>I<<II>type>II<comm<II>info>II<Ein /edit fuer mehrere Makros auf einmal. Der erste Parameter gibt die neue Option (siehe /def) an, der Rest wird als Makroliste bzw. Patternliste aufgefasst. Jedes Makro dieser Liste erhaelt dann die neue Option.@{N}/edit_macros ist vor allem dazu gedacht, einfach konfigurierbare Faerbetrigger zu ermoeglichen, ohne jedesmal auf "/eval /def -a%color ..." zurueckgreifen zu muessen (siehe Beispiel).<II>syn>II</edit_macros <Attribut> Pattern1 [Pattern2 ...]<II>ex>II<Nach@{N}/edit_macros -aCcyan t_team_info_* t_team_af*@{N}wuerden die Texte aller Trigger, auf die das (glob-)Muster t_team_info_* bzw. t_team_af* passt, in cyan ausgegeben.@{N}/eval /edit_macros -a%team_color t_team_info_* t_team_af*@{N}wuerde dazu die Farbe aus der Variablen %team_color nehmen.@{N}/test edit_macros("-p30 -E(flag)", "t_team_af*", "t_team_weg")@{N}ist ein Beispiel fuer eine Option mit Leerzeichen.<II>fileinfo>II<util.tf<II><I>
/set help___020095116=<I>cfg_way_go_show_text>I<<II>type>II<cfg<II>info>II<Der Text der vor der Wegberechnung angezeigt wird um zu sehen welche Bedingungen gesetzt sind, kann Attribute, Makroaufrufe usw. enthalten<II>ex>II<%way_go_show_para %way_go_show_state  %way_go_show_portals %way_go_show_guild<II>fileinfo>II<way.tf<II><I>mud_recognize_output>I<<II>type>II<var<II>info>II<Die Ausgabe von ?mud_recognize_command.<II>see>II<mud_recognize_command, way.tf<II>fileinfo>II<warok<II><I>
/set help___1467486701=<I>find_words>I<<II>type>II<mak<II>list>II<akt_detlist, detlist<II>info>II<Sucht die Substantive aus dem String und speichert sie in den Listen. Wenn sie schon vorhanden waren, werden die alten geloescht.<II>var>II<%fulldetail<II>fileinfo>II<untroom.tf<II><I>
/set help___258323846=<I>lists.tf>I<<II>type>II<fileinfo<II>func>II<paramparse, islist, hcount_entries, aget, alen, astart, ascmp, asicmp, ancmp, reggetvalueof, convert_regexp, reggetkey, reggetkeyofvalue, reggetvalue, getidxofvalue, getidxofkey, reggetidxofvalue, reggetidxofkey, getvalueof, getnextvalueof, count_entries, getdvalueof, geti, getivalue, getikey, getkeyofvalue, iskey, getfirstvalue, getfirstkey, isemptylist<II>mak>II<sreplace, sortforeach, hsortforeach, hforeach, haddlisttolist, hgetentrylist, loadarray, savearray, aswap, amsort1, split_list, merge_lists, umerge_lists2, hmerge_lists, makesub, unmakesub, showlist2, hloadnamedlist, hsavenamedlist<II>list>II<lists<II>changes>II<1.20 Viele Makros geben nun ihr Ergebnis nicht nur in %value, sondern auch als Rueckgabewert zurueck. Die Verwendung von %value sollte soweit wie moeglich vermieden werden, um Seiteneffekte zu vermeiden.<II>info>II<Enthaelt Makros zum Umgang mit (Hash-)Listen, die aus Schluessel-Wert-Paaren bestehen, und Feldern; dabei kann der Wert auch wieder eine Liste sein.<II>req>II<util.tf loading.tf util.echo.tf(1.21)<II>misc>II<eh syn /sreplace (old|\space) (new|\space) string, hashliste, hashlists, result anzahl der eintraege als rueckgabewert, felder, arrays, result das sortierte feld in %amsort_base und das ggf. mitzusortierende zweite feld in %amsort_base2., result the assorted array in %amsort_base, the optional second array in %amsort_base2., index, listen<II>comm>II<hashlist, removehashed, hxaddtolist, haddtolist, haddlisttosave, hcreatelist, hcopylist, hloadlist, hsavelist, hgetvalueof, hdelallkeysandvalues, hdeletekeyandvalue, hgetdvalueof, hgetlistvalueof, hxaddlisttolist, aput, aclear, ashow, asshow, amsort, asort, aforeach, aforeach2, asortforeach, hasortforeach, createlist, createnewlist, xaddbtolist, xaddtolist, xuaddtolist, addtolist, uaddtolist, addbtolist, addlisttolist, uaddlisttolist, xaddlisttolist, foreach, delikeyandvalue, getdlistvalueof, getlistvalueof, deletekeyandvalue, delallkeysandvalues, hshowlist, showlist, listkeys, showshortlist, savehrlist, savelist, loadnamedlist, savenamedlist, loadlist, addlisttosave, savealllists, loadhrlist<II>version>II<lists.tf,v 1.49 2003/01/07 17:03:36 nieten (Mesirii@mg.mud.de)<II>var>II<%value (ganz wichtig)<II>see>II<index, listen<II>fileinfo>II<lists.tf<II><I>
/set help___004123697=<I>nopara>I<<II>type>II<comm<II>info>II<Schaltet die aktuelle Dimension auf Normalwelt um.<II>var>II<dimension<II>see>II<dimensionen, para, ways, editway, portale<II>fileinfo>II<way.tf<II><I>
/set help___247253102=<I>h_send_v>I<<II>type>II<hook<II>info>II<Hook der statt /v 100 auch v 100 erlaubt<II>fileinfo>II<vorsicht.tf<II><I>
/set help___246816090=<I>getroom2>I<<II>type>II<mak<II>mak>II<getroom2<II>info>II<Hilfsmakro fuer mapexits. Hier werden die einzelen Ausgaenge extrahiert und an den Mapper geschickt. Zur Ueberpruefung, ob es ein normaler Ausgang ist, wird die Liste ?comm_abbr benutzt.<II>req>II<customize.tf<II>var>II<mapper, fulldetail<II>fileinfo>II<mapper.tf<II><I>
/set help___015114046=<I>worldconnect.tf>I<<II>type>II<fileinfo<II>mak>II<check_idle<II>info>II<Speichern und Laden von Variablen, Connection mit automatischen Laden von Files<II>req>II<lists.tf util.hooks.tf util.prompts.tf util.tf(1.21)<II>comm>II<reconnect, loadsaved, addsave, saveall<II>cfg>II<cfg_connect_title, cfg_connect_idle_time<II>version>II<worldconnect.tf,v 1.23 2002/12/03 03:46:34 mh14 (Mesirii@mg.mud.de)<II>hook>II<user_got_idle, user_got_active, myconn, mydc<II>var>II<user_is_idle<II>over>II<quit<II>fileinfo>II<worldconnect.tf<II><I>
/set help___014104109=<I>show_help_html>I<<II>type>II<mak<II>mak>II</echo2, /getvalueof<II>list>II<addh_sublist,<II>info>II<Zeigt die einzelnen Rubriken eines Hilfethemas als HTML-Quelltext an. Dabei ist der komplette Eintrag in der Liste 'addh_sublist' enthalten.<II>syn>II</show_help_html 0|1 Hilfeschluesselwort 0|1 Titel<II>fileinfo>II<help.tf<II><I>
/set help___258323323=<I>listkeys>I<<II>type>II<comm<II>mak>II</forEach, /listKeys2<II>info>II<Liefert alle Schluessel der angegebenen Liste als mit Komata getrennte Liste zurueck.<II>return>II<per /result<II>var>II<%listKeys<II>fileinfo>II<lists.tf<II><I>
/set help___003974732=<I>islist>I<<II>type>II<func<II>info>II<Liefert einen Wert ungleich %error zurueck, wenn die uebergebene Variable dem Anschein nach eine Liste ist, also mit "<I@{}>" beginnt und endet.<II>syn>II</isList listenname<II>return>II<%error bei Fehler als Rueckgabewert und in %value.<II>ex>II</if (isList("demo_list") =~ error) ...@{N}oder@{N}/isList demo_list@{N}/if (value =~ error) ...<II>var>II<%value<II>fileinfo>II<lists.tf<II><I>
/set help___000007207=<I>bgo>I<<II>type>II<comm<II>info>II<Geht zum Knoten Startknoten des letzten /go zurueck<II>fileinfo>II<way.tf<II><I>
/set help___000527140=<I>reunt>I<<II>type>II<comm<II>info>II<Damit wird das letzte Detail (z.B. nach /nichts) wieder hergeholt und als /unt detail angezeigt.@{N}Dafuer sollte auch ein Keybinding in der Spielerdatei existieren.<II>see>II</nichts, /nichts_unt, /delete_all_subdetails<II>fileinfo>II<untroom.tf<II><I>
/set help___000500917=<I>lazym>I<<II>type>II<mak<II>info>II<Lazy Call im Makrokontext. Es wird erst gecheckt, ob das Makro existiert, bevor es mit seinen Parametern ausgefuehrt wird. Falls es nicht existiert, wird mit /debug eine Fehlermeldung erzeugt.<II>syn>II</lazym makroname parameters<II>ex>II</lazym foo bar -> /foo bar oder Not Found foo<II>fileinfo>II<util.tf<II><I>
/set help___000008040=<I>nop>I<<II>type>II<mak<II>info>II<Kommando, das nichts tut. Es ist notwendig, weil '%;' als Body eines Makros ein Newline ans Mud sendet.<II>fileinfo>II<util.tf<II><I>
/set help___000463855=<I>ashow>I<<II>type>II<comm<II>info>II<Zeigt alle Variablen an, die das angegebene Feld ausmachen.<II>syn>II</ashow feldname<II>see>II</asshow<II>fileinfo>II<lists.tf<II><I>
/set help___238187093=<I>cfg_save>I<<II>type>II<mak<II>info>II<Speichert die als letzten Parameter uebergebene Variable in dem user_config.cfg-File, das durch die vorhergehenden Config-Hierarchie Namen bestimmt wurde. Dabei werden in dem File die Zeilen ersetzt, in denen die Variable bisher gesetzt wurde, oder halt ans Ende des Files angehaengt.<II>syn>II</cfg_save config hierarchie names varnae<II>ex>II</cfg_save ALL LOADING SUFFIX file_suffixes wird in user_config.cfg gespeichert@{N}/cfg_save MG_MUD_DE COMMAND LOOK wird in mg.mud.de/user_config.cfg gespeichert<II>fileinfo>II<config.tf<II><I>
/set help___017097097=<I>team_auto_aufname>I<<II>type>II<var<II>fileinfo>II<team.tf<II><I>
/set help___000066391=<I>setw>I<<II>type>II<mak<II>mak>II<getw, listw, unsetw, echow<II>info>II<Setzt die Variable ${world_name}_%1 auf den uebergebenen Wert. Nutzung ohne =<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___011115115=<I>isemptylist>I<<II>type>II<func<II>info>II<Funktion, die 1 zurueckgibt, falls die uebergenen Liste leer ist, sonst 0.@{N}Achtung: Falls der uebergebene Parameter keine Liste ist, wird ebenfalls 0 zurueckgegeben.<II>syn>II</isEmptyList liste  oder  isEmptyList(liste)<II>ex>II</if (isEmptyList(test_list)) /echo Liste leer%; /endif@{N}/test isempty:=isEmptyList(test_list)<II>fileinfo>II<lists.tf<II><I>
/set help___011115116=<I>uselists.tf>I<<II>type>II<fileinfo<II>mak>II<init_pub2, pub_extract, pub_got, pub_count, pub_done<II>info>II<Viele Anwendungsbeispiele fuer die key-value Listen ;))<II>req>II<lists.tf util.tf<II>comm>II<settank, gotank_back, pub_init, pub_test, pub_kaufe<II>version>II<uselists.tf,v 1.5 2001/10/07 18:29:53 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<uselists.tf<II><I>
/set help___000007858=<I>lp2>I<<II>type>II<mak<II>info>II<Setzt den aktuellen Knoten auf den uebergebenen Parameter. Der Inhalt der Variablen %cond_go wird geloescht. Wenn der Mapper aktiv ist (%mapper==1), wird ein 'go knotename' an den Mapper gesandt.<II>var>II<lastpoint, cond_go, showpoint<II>see>II</cond_go, mapper<II>fileinfo>II<way.tf<II><I>
/set help___029986659=<I>cmapnpc>I<<II>type>II<mak<II>info>II<Makro dass einen Eintrag aus der NPCS Liste in den Mapper uebertraegt<II>fileinfo>II<mapper.tf<II><I>
/set help___000057884=<I>aput>I<<II>type>II<comm<II>func>II<astart, alen<II>info>II<Setzt den Wert des Feldes am angegebenen Index.<II>syn>II</aput feldname index wert<II>see>II</aget<II>fileinfo>II<lists.tf<II><I>
/set help___238179951=<I>cfg_echo>I<<II>type>II<mak<II>info>II<Ein Echo-Makro, das schaut, ob fuer den uebergebenen Makronamen eine Config von Farbe und/oder Text existiert. Wenn ja gibt es die Config aus, ansonsten den Originaltext.@{N}Die Variablen heissen: CFG_*_ECHO_TEXT und CFG_*_ECHO_ATTR, das * steht fuer den als ersten uebergebenen Parameter.@{N}Dabei wird noch CFG_ECHO_GAG_LEVEL beachtet: bei 0 oder nicht gesetzt wird die Originalmeldung ausgegeben, bei 1 wird nur die Farbe beruecksichtigt, bei 2 wird Farbe und Alternativtext beruecksichtigt.<II>syn>II</cfg_echo configname %*<II>ex>II</set CFG_MG_ZAUBERER_ZSCHILD_ECHO_TEXT=ZSchild @{B}aus.@{n}@{N}/set CFG_MG_ZAUBERER_ZSCHILD_ECHO_ATTR=Cblue@{N}/cfg_echo MG_ZAUBERER_ZSCHILD %*<II>fileinfo>II<config.tf<II><I>
/set help___004248585=<I>setali>I<<II>type>II<comm<II>mak>II<forEach, echolist<II>list>II<nodealias, lastpoints<II>info>II<Erlaubt fuer beliebige Wegeknoten Aliase zu vergeben. Die Liste der Aliase wird sofort im Anschluss abgespeichert.<II>syn>II</setali zeigt alle Aliase an.@{N} '/setali knoten alias' erzeugt das Alias fuer den Knoten.@{N} '/setali alias neues_alias' ueberschreibt das vorhandene Alias.@{N} '/setali alias' loescht das Alias.<II>see>II<Knotenaliase<II>fileinfo>II<way.tf<II><I>
/set help___2060196841=<I>user_lang>I<<II>type>II<cfg<II>info>II<Sprache des Nutzers<II>update>II</i18n_mud_language<II>fileinfo>II<i18n.tf<II><I>
/set help___233419035=<I>addlines>I<<II>type>II<var<II>fileinfo>II<warok<II><I>
/set help___000068219=<I>ways>I<<II>type>II<see<II>list>II<fromidx, toidx<II>info>II<Die Liste 'ways' enthaelt alle Wege in kompletter Form:@{N}Anfang: Subliste aller wegfuehrenden Wege, naechster Anfang ...@{N}Subliste: Ziel Dimension([n]ormal|[p]arawelt|[b]eides|[0-9].Parawelt)@{N}Erlaubnis(siehe dort), Laenge des Wegs Weg, naechstes Ziel ...@{N}Aus dieser Liste werden zwei Indizes erzeugt: Der 'fromidx', der eine verkuerzte Form von Ways darstellt, d.h. ohne die eigentlichen Wege, und der 'toidx', der die nach Zielen gruppierte Liste enthaelt.<II>see>II<knoten, dimensionen, portale, wege<II>fileinfo>II<way.tf<II><I>
/set help___000064451=<I>mydc>I<<II>type>II<hook<II>info>II<Speichert bei einem Disconnect die angegebenen Variablen.<II>hook>II<SIGHUP, DISCONNECT<II>see>II<addsave, loadsaved, saveall<II>fileinfo>II<worldconnect.tf<II><I>
/set help___003711099=<I>arrays>I<<II>type>II<misc<II>info>II<Die Felder sind einfach eine Abbildung auf TF-Variablen, in denen dann die Inhalte stehen. Dabei wird der Variablenname wie folgt zusammengesetzt: 'array_feldname___index'. Die hoechsten und niedrigsten Indizes stehen in 'array_feldname___maxlen' und '*___minlen', werden aber auch von /alen und /astart geliefert.<II>see>II</aget, /aput, /ashow, /asshow, /asort, /amsort, /aforEach, alen, astart, /aclear<II>fileinfo>II<lists.tf<II><I>
/set help___033530899=<I>portals>I<<II>type>II<var<II>info>II<Gibt an, ob Portale genutzt werden sollen (1 ja, 0 nein).<II>see>II<way.tf, portale<II>fileinfo>II<warok<II><I>
/set help___246807588=<I>getpoint>I<<II>type>II<mak<II>info>II<Vergleicht die aktuelle Raumbeschreibung mit der Liste 'lastpoints' und liefert ggf. den entsprechenden Raum.<II>var>II<%getpoint_trig<II>fileinfo>II<way.tf<II><I>
/set help___000007926=<I>min>I<<II>type>II<mak<II>info>II<Liefert das Minimum von zwei Zahlenwerten ueber /echo zurueck. Also Ergebnis mit $() holen.<II>return>II<ueber /echo das Minimum der Zahlen<II>see>II<substitutions<II>fileinfo>II<util.tf<II><I>
/set help___030901696=<I>foreach>I<<II>type>II<comm<II>mak>II</getfirstkey, /deletekeyandvalue<II>info>II<Fuehrt fuer jedes Paar der Liste das angegebene Makro mit den entsprechenden Parametern (Schluessel und/oder Wert) aus. Der zweite Parameter sagt aus, was dem Makro uebergeben wird (key|value|key value).<II>syn>II</forEach listenname (k|v|kv) /makro<II>ex>II</forEach freunde k /finger<II>var>II<%fetemp_list, %value, %break_forEach<II>fileinfo>II<lists.tf<II><I>
/set help___272624453=<I>shownode>I<<II>type>II<comm<II>changes>II<3.11.99 /shownode arbeitet jetzt auch mit Wildcards, d.h. '/shownode t*' zeigt alle Knoten, an die mit 't' beginnen (Gross/Kleinschreibung egal).<II>info>II<Zeigt Knoten an.<II>syn>II<'/shownode *' zeigt alle Knoten an. (Dauert ein bisschen.)@{N}'/shownode knoten' zeigt die Beschreibung fuer den Knoten an.@{N}'/shownode' zeigt die Beschreibung fuer den aktuellen Knoten an.<II>var>II<nodelist (Speicher fuer Knotenliste)<II>see>II<wege, knoten<II>fileinfo>II<way.tf<II><I>
/set help___000068345=<I>utri>I<<II>type>II<mak<II>info>II<Definiert einen Regexp-Trigger, der den Weg fortsetzt, wenn er triggert. Dieser Trigger macht zuerst ein %mud_look_command, um ggf. schon im Raum befindliche Dinge festzustellen. Daher ist es am besten, den Trigger mit einer zweiteiligen rexexp zu versehen.<II>syn>II</utri regexp<II>ex>II</utri (Ein Schiff\\.|Ein Schiff kommt an\\.)<II>see>II<wegeingabe, tri, regxexp<II>fileinfo>II<way.tf<II><I>
/set help___030852236=<I>gettcmd>I<<II>type>II<mak<II>info>II<liefert den Befehl fuer eine Tastenbelegung zurueck.<II>syn>II</gettcmd Modus Taste<II>return>II<Beschreibung<II>fileinfo>II<keys.tf<II><I>
/set help___000454828=<I>_read>I<<II>type>II<mak<II>info>II<Ersatz fuer read(), das durch 'tfread' ersetzt wurde. Noetig, wenn die Eingabe direkt weiterverwendet werden soll, z.B. in einer regexp.<II>return>II<die Eingabe<II>ex>II</echo /_read @{N} /if (_read() =~ "test") ...<II>see>II<tfread, read<II>fileinfo>II<util.tf<II><I>
/set help___016097102=<I>load_init_config>I<<II>type>II<mak<II>info>II<fuehrt ein Initialisierungsmakro nach dem Laden des Files aus. Der Parameter ist der Dateiname, dieser wird wie bei den file_info Variablen als Praefix vor das _init gesetzt<II>ex>II</load_init_config loading.tf -> aufruf von loading_tf_init wenn existent<II>fileinfo>II<loading.tf<II><I>
/set help___017105117=<I>init_action_count>I<<II>type>II<mak<II>info>II<Initialisiert das Zaehlen von Befehlen und Prompts in den Variablen '_${world_name}(action|prompt)_count'. Dazu wird die Liste 'prompt_action' erzeugt und /def_prompt_hook aufgerufen.<II>see>II<def_prompt_hook<II>fileinfo>II<util.prompts.tf<II><I>
/set help___2113981806=<I>showlist2>I<<II>type>II<mak<II>mak>II</echo2, /unmakesub, /showlist<II>info>II<Hilfsmethode von /showlist. Fuehrt fuer alle Elemente der Liste die Darstellung durch, ggf. werden Sublisten wieder mit /showlist angezeigt.<II>see>II</showlist<II>fileinfo>II<lists.tf<II><I>
/set help___272628347=<I>showways>I<<II>type>II<comm<II>info>II<Zeigt alle Wege von und zum angegebenen Knoten, oder, wenn keiner angegeben wurde, des aktuellen Knotens an.<II>see>II<showwway<II>fileinfo>II<way.tf<II><I>
/set help___025103097=<I>highlight_untroom_actions>I<<II>type>II<cfg<II>info>II<Liste der Aktionsworte zur Hervorhebung im Ausgabetext<II>see>II<untroom_highlight_action_attr, do_highlight_untroom_actions<II>fileinfo>II<untroom.tf<II><I>
/set help___2121213876=<I>send_fast>I<<II>type>II<comm<II>info>II<Schnelles Senden von Kommandos ans Mud, direkt als String mit char(13) (Return) getrennt<II>syn>II</send_fast comm%;comm2%;comm3<II>ex>II</send_fast n%;o%;s<II>fileinfo>II<util.tf<II><I>
/set help___000464696=<I>aswap>I<<II>type>II<mak<II>info>II<Tauscht die Feldwerte an den angegebenen Indizes aus.<II>syn>II</aswap feldname index1 index2<II>see>II</asort<II>fileinfo>II<lists.tf<II><I>
/set help___268527404=<I>pre_load>I<<II>type>II<hook<II>info>II<Dieser Hook wird vor dem Laden eines Files mit dem puren Dateinamen als Parameter ausgefuehrt.<II>see>II</mload<II>fileinfo>II<loading.tf<II><I>
/set help___004124612=<I>noport>I<<II>type>II<comm<II>info>II<Schaltet die Portale aus. Loescht die Liste zwischengespeicherter Wege.<II>var>II<portals<II>see>II<portale, dimensionen, para, nopara, port<II>fileinfo>II<way.tf<II><I>
/set help___2063949072=<I>make_help>I<<II>type>II<comm<II>info>II<Wird von /mload beim Laden eines Files aufgerufen. Es werden die Variable 'file_name' gesetzt und<II>fileinfo>II<help.tf<II><I>
/set help___1971380131=<I>eval_hook>I<<II>type>II<mak<II>mak>II<hook_%hookname<II>changes>II<1.01 Testet, ob Hook existiert.<II>info>II<Fuehrt den angegebenen Hook mit den uebergebenen Parametern aus.<II>version>II<1.01<II>fileinfo>II<util.hooks.tf<II><I>
/set help___027109095=<I>mud_examine_in_room_command>I<<II>type>II<misc<II>info>II<Kommando zum Untersuchen von Details in einem Raum.<II>see>II<untroom.tf<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___000001040=<I>uh>I<<II>type>II<misc<II>info>II<Untersucht den Himmel.<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___029178693=<I>addnode>I<<II>type>II<comm<II>mak>II<getnode, getali<II>info>II<Ersetzt alle vorhandenen Knotenbeschreibungen durch die des aktuellen Raumes. Wenn der zusaetzliche Parameter Zeilenzahl angegeben wird, wird nur die gewuenschte Anzahl Zeilen gespeichert. Ansonsten wird die Variabel ?addlines beachtet. Wenn die Zeilenzahl 0 ist, wird die komplette Raumbeschreibung bis zu den Ausgaengen gespeichert.<II>syn>II</addnode [knoten [zeilenzahl]]<II>var>II<lastpoint, addlines<II>see>II<knoten, appendnode, delnode<II>fileinfo>II<way.tf<II><I>
/set help___732973493=<I>wegeingabe>I<<II>type>II<see<II>info>II<Die Wegeingabe muss von einem Knotenpunkt starten, der entweder mit /wo oder mit /lp gesetzt wurde. Es gibt zwei Arten Wege einzugeben:@{N}Mit /weg werden alle Kommandos, die eingegeben werden, im Hin- und (sofern es erkennbar ist) auch im Rueckweg abgespeichert.@{N}Wenn einfach mit dem Ziffernblock durch die Gegend gewandert wird, werden die Schritte auch mitgeloggt. Spezielle Befehle koennen durch die 0-Taste des Ziffernblocks eingegeben werden. Sofern bekannt. wird auch deren Umkehrung im Rueckweg gespeichert, wenn nicht. wird nach einer gefragt. Diese Befehle werden sofort ausgefuehrt. Mit dieser Taste koennen auch die im Weg enthaltenen Makros eingegeben werden.@{N}Wenn man mit dem Weg fertig ist, macht man einfach /end. Sofern man an einem bekannten Knoten steht, wird das erkannt, ansonsten wird man zur Namensverleihung gebeten.@{N}Dann wird der Weg abgespeichert (siehe dort).<II>see>II<weg speichern, weg editieren, weg, end, lp, wo<II>fileinfo>II<way.tf<II><I>
/set help___012097097=<I>random_param>I<<II>type>II<mak<II>info>II<Liefert zufaellig einen der uebergebenen Parameter zurueck, wenn keine uebergeben wurden, dann einen Leerstring<II>ex>II</random_param a b c -> Ergebnis a oder b oder c<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___2024075394=<I>init_pub2>I<<II>type>II<mak<II>info>II<Loescht den Trigger zum Erfassen des Inhalts des Menues und fuegt die Liste %pub_temp_list unter dem Namen %pubs_name zur Liste %pubs_hinzu.<II>fileinfo>II<uselists.tf<II><I>
/set help___012105112=<I>finger_props>I<<II>type>II<list<II>info>II<Liste der Regexp Pattern zur Auswertung der "finger" Augabe<II>fileinfo>II<mg_properties.tf<II><I>
/set help___1795059060=<I>deprecated>I<<II>type>II<mak<II>info>II<Fuegt den Parameter zu einer Liste hinzu, die veraltete Makros/Variablen enthaelt. Es kann optional ein ergaenzender Text angegeben werden, der ggf. bei ?/check_deprecated mit ausgegeben wird.<II>syn>II</deprecated name (var|mak) [ergaenzender Text]<II>ex>II</deprecated mud_shortest_output var@{N}/addh /deprecated /seher m Heisst jetzt /become_seer.<II>fileinfo>II<util.tf<II><I>
/set help___004370715=<I>vlines>I<<II>type>II<func<II>info>II<Anzahl der sichtbaren Ausgabezeilen<II>fileinfo>II<util.tf<II><I>
/set help___014114118=<I>trig_is_active>I<<II>type>II<mak<II>info>II<checks of the triggers defined with trig_grab, whose number was returned by trig_grab are still active or not<II>syn>II</trig_is_active number returned by trig_grab<II>return>II<number of still active triggers/macros (0 to 3)<II>fileinfo>II<util.trigger.tf<II><I>
/set help___241690188=<I>echolist>I<<II>type>II<mak<II>info>II<Sammelt eine Anzahl von Ausgaben und gibt sie beim Aufruf ohne Parameter durch Kommata getrennt wieder aus.<II>var>II<%echolist<II>fileinfo>II<util.echo.tf<II><I>
/set help___016103108=<I>reggetkeyofvalue>I<<II>type>II<func<II>func>II<convert_regexp<II>info>II<Wie /getkeyofvalue nur, dass der Wert als regexp angegeben ist (ohne Klammern rundherum).<II>syn>II</reggetkeyofvalue listenname regexp<II>return>II<erster zum Wert passender Schluessel als Rueckgabewert und in %value, %error bei Misserfolg<II>var>II<%value<II>see>II</convert_regexp, /reggetkeyofvalue, regexp, /reggetvalueof<II>fileinfo>II<lists.tf<II><I>reggetidxofvalue>I<<II>type>II<func<II>func>II<count_entries, isVar<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>info>II<Liefert den Index des ersten Wertes zurueck, auf den die regexp passt.@{N}Die Liste kann sowohl direkt als auch ueber ihren Namen angegeben werden (siehe Beispiel).<II>syn>II</reggetidxofvalue (liste|listenname) regexp<II>return>II<Index des ersten zur regexp passenden Wertes oder %error als Rueckgabewert und in %value<II>ex>II<Sowohl@{N}@{}  /test index:=reggetidxofvalue("skills_list","5[0-9]%")@{N}als auch@{N}@{}  /test index:=reggetidxofvalue(skills_list,"5[0-9]%")@{N}liefern den gleichen Wert.<II>var>II<%value<II>see>II<regexp, /reggetidxofkey, /getikey, /getivalue, /getidxofvalue<II>fileinfo>II<lists.tf<II><I>
/set help___000000924=<I>fl>I<<II>type>II<comm<II>info>II<Damit wird die Fluchtrichtung gesetzt. Der erste Befehl vor dem %; wird als Fluchtrichtung im Mud (%p_escape) benutzt, der Rest fuer die Fluchtrichtung im TF (%p_escape_tf). Dieser zweite Teil kann auch beliebige TF-Befehle enthalten sowie die speedwalk-Syntax (/walk) ,5o,2so nutzen.<II>ex>II</fl o%;no%;ob%;/go haus%;,o,6sw<II>see>II<walk<II>fileinfo>II<vorsicht.tf<II><I>
/set help___971710835=<I>input_idee>I<<II>type>II<comm<II>info>II<Mit diesem Kommando wird eine Idee fuer ein fehlendes Detail in der letzten Herkunftsanzeige gemeldet. Dazu wird der vorbereitete Text in die Kommandozeile geschrieben.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II<herkunftsanzeige<II>fileinfo>II<untroom.tf<II><I>
/set help___004265622=<I>tasten>I<<II>type>II<list<II>info>II<Die Liste tasten enthaelt alle Tastenbelegungen. Sie ist sozusagen die zentrale Datenbank.<II>fileinfo>II<keys.tf<II><I>
/set help___000057494=<I>alen>I<<II>type>II<func<II>info>II<Liefert den hoechsten Index des angegebenen Feldes zurueck.<II>syn>II</alen feldname<II>return>II<Index als Rueckgabewert<II>see>II<astart<II>fileinfo>II<lists.tf<II><I>
/set help___2048230765=<I>vorwaerts>I<<II>type>II<comm<II>info>II<Speichert den angegebenen Wegebefehl im Hinweg. Wenn 'verify' eingeschaltet ist, passiert das nur bei erfolgreicher Ausfuehrung des Befehls. Wenn online eingeschaltet ist, wird der Befehl sofort ausgefuehrt, ansonsten nicht. @{N}Wenn der Rueckbefehl bekannt ist, wird er im Rueckweg gespeichert. Dabei kann ggf. nachgefragt werden. Wenn der Rueckbefehl nicht bekannt ist, wird nachgefragt. Wenn ein '+' vor dem Befehl steht, wird versucht, ihn und auch den Rueckbefehl zu expandieren ('soob' wird zu 'suedostoben' etc.).<II>syn>II</vorwaerts [+]befehle<II>see>II<online, verify, rueckwaerts, wegeingabe<II>fileinfo>II<way.tf<II><I>
/set help___012105115=<I>kill_process>I<<II>type>II<mak<II>info>II<wird von killall genutzt um den Prozess zu matchen und zu toeten<II>syn>II<kill_process matchtext single line from ps<II>fileinfo>II<util.tf<II><I>
/set help___240857485=<I>continue>I<<II>type>II<comm<II>info>II<Nach einer Unterbrechung fuehrt /continue oder kurz /c den Weg entweder weiter oder geht zum letzten Knoten zurueck. Es wird vorher wieder mit 'mud_shortest_output' in den Ultrakurzmodus geschaltet.<II>see>II<wegeingabe<II>fileinfo>II<way.tf<II><I>
/set help___029104116=<I>untroom_highlight_action_attr>I<<II>type>II<cfg<II>info>II<Attribute fuer das Hervorheben besonderer Worte (Aktionen).<II>fileinfo>II<untroom.tf<II><I>
/set help___011105110=<I>simple_menu>I<<II>type>II<mak<II>info>II<Ein einfaches Menue, das seine Parameter nummeriert darstellt und als Ergebnis eine darauf normierte Zahl zurueckgibt (oder 0 im Fehlerfall). Die Eingabe von 'q' fuehrt zum Rueckgabewert -1.<II>return>II<Auswahl oder 0 bei Fehler<II>ex>II</simple_menu Laden Speichern Schliessen<II>fileinfo>II<util.echo.tf<II><I>einfuehrung>I<<II>type>II<see<II>info>II<Eine Einfuehrung als solche gibt es nicht, bitte die Hilfeseite zum Dateisystem mit "/hilfe loading.tf" anschauen und dann von dort weiter verzweigen.<II>see>II<loading.tf<II>fileinfo>II<help.tf<II><I>
/set help___013114115=<I>createnewlist>I<<II>type>II<comm<II>func>II<isList<II>mak>II</createlist<II>info>II<Erzeugt eine neue Liste, wenn die Liste noch nicht existiert<II>syn>II</createnewlist listenname<II>see>II</createlist<II>fileinfo>II<lists.tf<II><I>
/set help___030251329=<I>editway>I<<II>type>II<comm<II>info>II<Editieren von Wegen (mit jeweiliger Abfrage).<II>syn>II<'/editway * knoten' editiert alle Wege an, die zum Knoten hinfuehren.@{N}'/editway knoten *' editiert alle Wege an, die vom Knoten wegfuehren.@{N}'/editway knoten1 knoten2' editiert den Weg zwischen den Knoten an.<II>see>II<wege editieren, showway, delway, einschraenkungen<II>fileinfo>II<way.tf<II><I>
/set help___093657921=<I>reverseway>I<<II>type>II<comm<II>info>II<Kehrt den angegebenen Weg um und speichert ihn ab.<II>syn>II</reverseway (knoten1|*) (knoten2|*)<II>fileinfo>II<way.tf<II><I>
/set help___032274327=<I>maplong>I<<II>type>II<mak<II>mak>II<restricttoexit,<II>info>II<das Makro parst die Long, die als Ergebnis von /mapinfo erhalten wird<II>req>II<way.tf<II>var>II<mapper<II>fileinfo>II<mapper.tf<II><I>
/set help___015102101=<I>def_mapper_send>I<<II>type>II<hook<II>info>II<Makro dass den Send Hook fuer den Mapper Praefix definiert<II>fileinfo>II<mapper.tf<II><I>
/set help___013114116=<I>properties.tf>I<<II>type>II<fileinfo<II>changes>II<Die Properties werden nun im Spielerverzeichnis gesichert. Aus Kompatibilitaetsgruenden wird beim Laden aber auch (noch) im Mud-Verzeichnis gesucht.<II>info>II<Enthaelt die mudunabhaengigen Makros die Properties betreffend.<II>req>II<!lists.tf util.sfunc.tf util.trigger.tf<II>comm>II<whoami, who<II>version>II<properties.tf,v 1.14 2002/12/02 11:56:48 mh14 (Mesirii@mg.mud.de)<II>see>II<properties<II>fileinfo>II<properties.tf<II><I>
/set help___018108097=<I>hdeletekeyandvalue>I<<II>type>II<comm<II>func>II<hash<II>mak>II</deletekeyandvalue<II>info>II<Loescht den ersten Schluesseleintrag dieses Schluessels in der angegebenen ?Hashliste.<II>syn>II</hdeletekeyandvalue listenname schluessel<II>var>II<%hvalue, %value<II>fileinfo>II<lists.tf<II><I>
/set help___1956571759=<I>dtyp flag>I<<II>type>II<misc<II>info>II<Variable, die das automatische Aufnehmen von Teammitgliedern steuert.@{N}Umschaltbar mit /team_auto_aufnahme (/taa), /team_neu - ein, /team_voll - aus. Default ist aus.<II>fileinfo>II<team.tf<II><I>
/set help___015104110=<I>echo_hit_points>I<<II>type>II<mak<II>info>II<Berechnet Aenderung der Lebens- und Magiepunkte. Wenn die Aenderung groesser als 1 ist oder man sich im Kampf befindet: Anzeige.@{N}Wenn _pf gesetzt ist und keine Kontrolle-Zaubern laeuft und keine Sperrzeit bis zum naechsten Zauberspruch vorhanden ist, dann wird /pfunc mit ?p_lp und ?p_mp aufgerufen.<II>var>II<p_mp, p_lp, p_m_lp, p_m_mp,<II>fileinfo>II<mg_properties.tf<II><I>
/set help___274569537=<I>splitway>I<<II>type>II<comm<II>info>II<Splittet einen Weg in zwei Teilwege auf. Dafuer wird die Anzahl der zum ersten Weg gehoerenden Befehle als Parameter uebergeben und kann dann auch spaeter interaktiv veraendert werden. Es wird nach dem neuen Zwischenknoten gefragt, dann werden die neuen Wege gespeichert und das Loeschen des alten Weges abgefragt.<II>ex>II</splitway knoten1 knoten2 anzahl_befehle_in_erstem_teilweg@{N}z.B. /splitway haus kneipe 5<II>see>II<editway, showway<II>fileinfo>II<way.tf<II><I>
/set help___1974255885=<I>getivalue>I<<II>type>II<func<II>mak>II</geti<II>info>II<Liefert den Wert an Position 'index'. Der Index beginnt bei Null!<II>syn>II</getivalue listenname index<II>return>II<Wert am Index bzw. %error bei Misserfolg als Rueckgabewert und in %value<II>var>II<%value<II>see>II<index, /getikey, /getidxofvalue<II>fileinfo>II<lists.tf<II><I>
/set help___003917423=<I>ifecho>I<<II>type>II<mak<II>info>II<Macht nur die Ausgabe, wenn der als erste Parameter uebergebene Ausdruck wahr ist.<II>syn>II</ifecho expression Text<II>ex>II</ifecho debuglevel==10 Internal Warning<II>fileinfo>II<util.echo.tf<II><I>
/set help___019095102=<I>set_status_var_flag>I<<II>type>II<mak<II>info>II<Methoden um Statuszeilenvariablen die auf Flags basieren, on the Fly zu definieren, dabei werden wenn vorhanden und gewuenscht Konfigurationsvariablen fuer Attribute (CFG_STATUS_COLOR_*) und Texte (CFG_STATUS_TEXT_*) genutzt werden (ggf. auch fuer ausgeschalteten Status (CFG_STATUS_COLOR_*_OFF,CFG_STATUS_TEXT_*_OFF))@{N}Wenn Farb- und Textinformationen angegeben werden, werden mit diesen Werten die entsprechenden Konfigurationsvariablen gesetzt (s.o.)<II>syn>II</set_status_var_flag varname default breite [Text_an Attr_an [Text_aus Attr_aus]]<II>ex>II</set_status_var_flag p_frog 0 1@{N}/set_status_var_flag p_blind 0 1 B Cbgmangenta@{N}/set_status_var_flag p_block 0 1 + Cyellow - n<II>fileinfo>II<status.tf<II><I>
/set help___011105114=<I>timer_makro>I<<II>type>II<var<II>info>II<Enthaelt den Makrobody, der vom ?timer beim Ausfuehren des Triggers aufgerufen wird. In %1 steht die vergangene Zeit.<II>see>II<timer<II>fileinfo>II<util.timer.tf<II><I>
/set help___000490891=<I>hooks>I<<II>type>II<see<II>info>II<Die Hooks sind eine Ansammlung von Befehlen, die in den Makros hook_hookname gespeichert sind. Ueber die Ausfuehrungsreihenfolge kann keine Annahme getroffen werden. Sie sind dazu praktisch, bei einem Ereignis eine Reihe vorher nicht festgelegter Anweisungen auszufuehren.<II>see>II</eval_hook, /add_to_hook, /remove_from_hook, /remove_hook<II>fileinfo>II<util.hooks.tf<II><I>
/set help___015102105=<I>default_details>I<<II>type>II<cfg<II>info>II<Enthaelt alle Details, die standardmaessig mit untersucht werden sollen. Sie werden als Details der P_LONG des Raumes betrachtet.<II>see>II<untroom<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___000551985=<I>wpara>I<<II>type>II<comm<II>info>II<Schaltet die aktuelle Dimension auf Parawelt um.<II>var>II<dimension<II>see>II<dimensionen, nopara, ways, editway, portale<II>fileinfo>II<way.tf<II><I>
/set help___019095097=<I>add_default_details>I<<II>type>II<mak<II>list>II<default_details, detlist<II>info>II<Fuegt die in der Liste %default_details enthaltenen Details denen der P_LONG des Raumes hinzu.<II>cfg>II<default_details<II>fileinfo>II<untroom.tf<II><I>
/set help___000472047=<I>echow>I<<II>type>II<mak<II>mak>II<getw, listw, setw, unsetw<II>info>II<Gibt die angegebene Variable, die lokal fuer die aktuelle Welt gesetzt wurde, aus und gibt sie gleichzeitig als Funktionswert bzw. in %? zurueck.<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___434663744=<I>stack_push>I<<II>type>II<mak<II>info>II<Speichert die uebergebenen (globalen) Variablen auf dem Stack.<II>ex>II</stack_push t1 t2 t3<II>see>II<getstack, stack_put, stack_pop<II>fileinfo>II<util.stack.tf<II><I>
/set help___2015774284=<I>hsavelist>I<<II>type>II<comm<II>mak>II</custom, /hsavelist2, /addtolist, /deletekeyandvalue, /getvalueof, /ifecho<II>info>II<Wie /savelist fuer normale Listen speichert /hsavelist ?Hashlisten ab. Die Dateien heissen 'listenname.hlist'. Es koennen alle von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Speichern ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</hsavelist [/custom-Optionen] listenname<II>var>II<%value, %temp_handle, %hsavelen<II>see>II</hloadlist, /savelist, /custom, Hashliste<II>fileinfo>II<lists.tf<II><I>
/set help___011099115=<I>hcreatelist>I<<II>type>II<comm<II>info>II<Erzeugt eine ?Hashliste, d.h. es werden alle Eintraege mit diesem Listennamen geloescht.<II>syn>II</hcreatelist listenname<II>see>II</createlist, Hashliste<II>fileinfo>II<lists.tf<II><I>
/set help___000063948=<I>most>I<<II>type>II<list<II>info>II<Diese Liste enthaelt all die Worte, die beim Raumuntersuchen uebergangen werden sollen. Falls sie veraendert wurde, wird sie bei /quit sortiert und abgespeichert.<II>see>II<untroom.tf<II>fileinfo>II<untroom_actions.tf<II><I>
/set help___646404486=<I>untroom.tf>I<<II>type>II<fileinfo<II>mak>II<add_default_details, add_to_detail, find_words, do_show_origin, save_most, sort_most, delay, del_schaue, del_unt<II>tut>II<Das Untersuchen eines Raumes wird mit /untroom gestartet.@{N}/unt untersucht das angegebene Detail.@{N}/unt2 untersucht das angegebene Detail nochmal, auch wenn es schon einmal als untersucht markiert wurde.@{N}Wenn man beim Untersuchen ist, kann man: (meine Bindings)@{N}mit # (/nichts_unt) das aktuelle Detail verwerfen und zum naechsten gehen@{N}mit ^i (/detail_idee) das vorhergehende Detail der Ideenliste hinzufuegen@{N}/show_idee zeigt die bisher gesammelten Ideen@{N}/send_idee schickt sie ab@{N}mit ^a (/add_most) das aktuelle Detail zur Ignoriere-Liste hinzufuegen@{N}mit ^d (/delete_sub_details) koennen alle Details, die im gerade angezeigten Text vorkommen, als schon untersucht markiert werden!!@{N}mit /inputtypo kann ein typo fuer den aktuell angezeigten Text abgesetzt werden@{N}falls man die Zeile geloescht hat, mit /reunt das aktuelle Detail zurueckholen.@{N}Sonstiges:@{N}Das Attribut fuer das Einfaerben in der Herkunftsanzeige wird mit '/set_style attrib' gesetzt.@{N}Diese Version hat die Ignoriere-Liste (most) erweitert; in ihr steht jetzt auch, wie oft diese Details vorgekommen sind. So kann die Liste sortiert werden, so dass die haeufigsten Details vorn stehen und nicht so lange gesucht werden. Das Sortieren und _Abspeichern_ der Ignoriere-Liste erfolgt mit /save_most. Da man das meist vergisst, hab ich das /quit ueberschrieben ;)@{N}@{N}Weitere Features: Am Zeilenende getrennte Worte werden erkannt, nur nicht in der Herkunft angezeigt.@{N}<II>changes>II<1.02 Neue Liste 'origin', in der die Originalform der Details gespeichert wird, da in den englischen Muds ein Grossbuchstaben am Anfang nicht das Original wiederherstellt.@{N}Ich hatte an zwei Stellen vergessen, 'schaue' durch %mud_look_command zu ersetzen, was hiermit geschehen ist.@{N}1.03 /do_show_origin wurde debuggt: Der Fehler, dass Teilworte markiert wurden, tritt jetzt nicht mehr auf.@{N}1.04 Beim Abschluss der Untersuchung werden die gesammelten Ideen zum Absenden vorgeschlagen.<II>info>II<Das ist die Datei mit dem Untersuche-Programm in tf. Bitte die Hilfe zu /untroom, /unt, und ggf. den restlichen Kommandos lesen.<II>req>II<!lists.tf<II>comm>II<set_style, untroom, add_region_details, remove_region_details, todo, todos, unt2, unt, delete_sub_details, reunt, show_origin, detail_idee, inputtypo, input_idee, send_idee, show_idee, add_most, set_delay, add_deklination<II>misc>II<next_det, nichts_unt, nichts_unt<II>trig>II<def_save_trig<II>cfg>II<untroom_hide_mud_output, untroom_hide_mud_output, do_highlight_untroom_actions, untroom_highlight_action_attr, highlight_untroom_actions, default_details<II>version>II<untroom.tf,v 1.20 2002/09/17 09:03:51 mh14 (Mesirii@mg.mud.de)<II>var>II<save_room<II>see>II<herkunftsanzeige<II>fileinfo>II<untroom.tf<II><I>
/set help___032878810=<I>mstimer>I<<II>type>II<mak<II>info>II<Ein Timer, der im Millisekundenbereich misst, der nur nach einem Patch des TF funktioniert. Beim Anlegen des Mstimers kann ein Trigger definiert werden, der dann den Makro-Body in ?mstimer_makro ausfuehrt.<II>syn>II</mstimer count triggertext : Es wird /def -n%count %triggertext t_mstimer = /mstimer trigger erzeugt.@{N}/mstimer remove : Loescht den Mstimer.@{N}/mstimer reset : Setzt den Mstimer zurueck (geht auch fuer Initalisierung ohne Trigger).@{N}/mstimer get : Liefert in %? die vergangene Zeit.@{N}/mstimer trigger : Fuehrt den Makro-Body in 'mstimer_makro' aus, wobei %1 die vergangene Zeit enthaelt.@{N}/mstimer : Reinitialisiert den Mstimer und liefert die vergangene Zeit in %? oder als Funktionswert zurueck.<II>trig>II<t_mstimer<II>ex>II<'/mstimer 2 -t"*faellt zu Boden*" -mglob' wird zu '/def -n2 -t"*faellt zu Boden*" -mglob t_mstimer = /mstimer trigger'<II>var>II<mstimer, mstimer_makro<II>see>II<mstimer_makro<II>fileinfo>II<util.timer.tf<II><I>
/set help___022109099=<I>cfg_mud_team_infocolor>I<<II>type>II<var<II>info>II<Attribut, welches fuer die Ausgabe von "team info (lang)" verwendet wird.<II>dtype>II<color<II>fileinfo>II<team.tf<II><I>
/set help___000008441=<I>tri>I<<II>type>II<mak<II>mak>II<cont_way<II>info>II<Definiert einen Regexp-Trigger, der den Weg fortsetzt, wenn er triggert.<II>syn>II</tri regexp<II>ex>II</tri (Ein Schiff kommt an\\.)<II>see>II<wegeingabe, utri, regexp, do_tri, break_tri<II>fileinfo>II<way.tf<II><I>
/set help___014117101=<I>mud_properties>I<<II>type>II<var<II>info>II<Eine Liste der Properties vom MG.<II>var>II<p_lp, p_mp, p_maxlp, p_maxmp, p_m_lp, p_m_mp, p_escape, p_whimpie, p_name, p_race, p_align, p_tall, p_level, p_weight, p_guild, p_guild_level, p_ep, p_ap, p_maxap, base_dex, mod_dex, dex, base_int, mod_int, int, base_str, mod_str, str, base_const, mod_const, const, p_deaf, p_blind, p_frog<II>fileinfo>II<mg_properties.tf<II><I>
/set help___012111099=<I>nodes_search>I<<II>type>II<mak<II>info>II<Durchforstet die Liste der Knoteninfos nach Knoten, die in dem uebergebenen Attribut den als Restparameter uebergebenen Substring (ignore case) enthalten.<II>ex>II</nodes_search gebiet Ebene<II>fileinfo>II<way.tf<II><I>
/set help___014104111=<I>show_dimension>I<<II>type>II<mak<II>info>II<Farbige Anzeige der Dimension<II>fileinfo>II<way.tf<II><I>
/set help___000007143=<I>ago>I<<II>type>II<comm<II>info>II<ago fuehrt alles was nach dem Zielknoten als Parameter uebergeben wird am Ziel als Befehle aus. Die Parameter koennen TF oder Mudbefehle sein (Trennung durch %;)<II>ex>II</ago kneipe kaufe bier<II>fileinfo>II<way.tf<II><I>
/set help___018095095=<I>set_status_var_num>I<<II>type>II<mak<II>info>II<Definiert eine numerische Variable fuer die Statuszeile sofort (on the fly). Die Attribute werden fuer eine Vergleichsliste angegeben (siehe /attr_ordered). Wenn statt des Defaultwertes der Variablenname noch einmal angegeben wird, wird diese Variable nur per Selbstzuweisung initialisiert (d.h. bleibt unveraendert, wenn schon existent).<II>syn>II</set_status_var_num varname defaultwert breite vglwert1 attr1 vglwert2 attr2 default_attr<II>ex>II</set_status_var_num lp 220 3 80 Cred 160 Cyellow Cgreen<II>see>II<attr_ordered<II>fileinfo>II<status.tf<II><I>
/set help___017121110=<I>keys_set_bindings>I<<II>type>II<mak<II>info>II<Setzt die Standardkeybindings (ESC 0-9 und F1-F12) fuer keys<II>fileinfo>II<keys.tf<II><I>
/set help___2114036464=<I>show_help>I<<II>type>II<mak<II>mak>II</echo2, /getvalueof<II>list>II<addh_sublist<II>info>II<Zeigt die einzelnen Rubriken eines Hilfethemas an. Dabei ist der komplette Eintrag in der Liste 'addh_sublist' enthalten.<II>syn>II</show_help 0|1 Hilfeschluesselwort 0|1 Titel<II>fileinfo>II<help.tf<II><I>
/set help___1973903861=<I>get_param>I<<II>type>II<mak<II>info>II<Liefert den Parameter zurueck fuer den die Substitution von %1 zutrifft, praktisch um auf eine Space separierte Liste von Worte zuzugreifen<II>syn>II</get_param subst param1 param2 ...<II>ex>II</get_param 1 a b c -> a@{N}/get_param L a b c -> c@{N}/get_param -L a b c -> a b@{N}/get_param -1 a b c -> b c@{N}/get_param 3 a b c -> c<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___1928538086=<I>countdown>I<<II>type>II<mak<II>info>II<Zaehlt die uebergebene Variable im Sekundentakt bis auf 0 herunter. Alternativ kann statt des Sekundentakts auch ein anderer Zeitschritt angegeben werden. Nuetzlich z.B. fuer Zeitsperren, die in der Statuszeile angezeigt werden sollen. Wenn nach dem Herunterzaehlen ein Makro ausgefuehrt werden soll, muss es nach dem dann notwendigen Takt angegeben werden.<II>syn>II</countdown varname [takt]@{N}/countdown varname takt makro<II>fileinfo>II<util.repeat.tf<II><I>
/set help___000496737=<I>iskey>I<<II>type>II<func<II>info>II<Falls der angegeben Schluessel nicht in der Liste enthalte ist, wird %error zurueckgegeben.<II>syn>II</iskey listenname schluessel  oder  iskey("listenname", "schluessel")<II>return>II<%error bei Misserfolg als Rueckgabewert und in %value<II>var>II<%value<II>see>II</getvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___019095108=<I>cfg_mud_team_color1>I<<II>type>II<var<II>info>II<Attribut, das alle teambezogenen Meldungen bis auf die Ausgabe von "team info (lang)" erhalten.@{N}(Ist ?comm.tf geladen, so werden alle Zeilen Form@{N}[Team ...] ...@{N}wie in ?comm_ebenen_list angegeben gefaerbt.)<II>dtype>II<color<II>fileinfo>II<team.tf<II><I>
/set help___003703174=<I>ari.tf>I<<II>type>II<fileinfo<II>info>II<Makros fuer Ari (Fernwaffen)<II>req>II<lists.tf<II>version>II<ari.tf,v 1.6 2002/02/10 22:36:40 mh14 (Mesirii@mg.mud.de)<II>fileinfo>II<ari.tf<II><I>
/set help___032937492=<I>p_blind>I<<II>type>II<var<II>info>II<Blind oder nicht blind?<II>fileinfo>II<mg_properties.tf<II><I>
/set help___003716164=<I>astart>I<<II>type>II<func<II>info>II<Liefert den kleinsten Index des angegebenen Feldes zurueck.<II>syn>II</astart feldname<II>return>II<Index als Rueckgabewert<II>see>II<alen<II>fileinfo>II<lists.tf<II><I>
/set help___034404140=<I>sshload>I<<II>type>II<comm<II>info>II<laedt ein file ueber eine ssh verbindung, dabei werden innerhalb des Files die Kommandos /cd, /load und /exit beruecksichtigt. Alles andere wird ausgefuehrt (Makrodefinitionen, Code im File)<II>syn>II</sshload host path/file<II>ex>II</sshload server.home.net TinyMacros/private.tf<II>fileinfo>II<sshload.tf<II><I>
/set help___2119784319=<I>set_delay>I<<II>type>II<comm<II>info>II<Stellt die Zeit zwischen zwei Untersuche-Befehlen ein.<II>syn>II</set_delay Zeit in Sekunden (Default 1)<II>var>II<%pdelay<II>fileinfo>II<untroom.tf<II><I>
/set help___018101097=<I>delete_sub_details>I<<II>type>II<comm<II>info>II<Damit werden alle Substantive, die in der zuletzt angezeigten Herkunftsanzeige auftauchen, als schon untersucht markiert. Das ist nuetzlich, wenn z.B. NPCs oder Spieler untersucht werden.@{N}Tip: Keybinding im Spielerfile machen.<II>see>II<herkunftsanzeige<II>fileinfo>II<untroom.tf<II><I>
/set help___018095097=<I>add_region_details>I<<II>type>II<comm<II>info>II<Fuegt fuer eine Region hinzu. Bei Details aus mehreren Worten Leerzeichen durch "_" ersetzen.<II>syn>II</add_region_details region detail1 detail2 ...<II>ex>II</add_region_details ark nordwand ostwand suedwand westwand sonne wolken<II>see>II<remove_region_details<II>fileinfo>II<untroom.tf<II><I>
/set help___2078384662=<I>trig_grab>I<<II>type>II<trig<II>info>II<Grabbt Zeilen aus dem Output des Muds, beginnend mit einer Startzeile (-b) ueber n Zeilen Body (ggf. -y) und eine Endzeile. Das ganze wird durch drei Trigger gesteuert.@{N}Wie kann der eingefangene Text genutzt werden: Entweder es wird per -M ein Makro angegeben, dem der Text nach Abschluss uebergeben wird. Ausserdem wird er in der mit -v angegebenen Variablen (default %fulldetail) gespeichert. Die einzelnen Zeilen werden mit @@@{}{N} (siehe /echo2) oder den bei -d angegebenen Zeichen verkettet. Oder das angegebene Makro wird pro Zeile mit der Zeile aufgerufen (wie bei /quote, daher auch -q).@{N}Abgebrochen wird das Triggering nach einer Anzahl Body-Zeilen (-n), nach einer gewissen Zeit (-t) oder nachdem ein zweites Kommando (-P, mud_custom_prompt) eine weitere Ausgabe im Mud erzeugt hat (%mud_custom_prompt_response). Mit -N kann die Anzahl der Kommandos bestimmt werden, deren Ausgaben eingefangen werden sollen.@{N}Was eingefangen werden soll gibt -c an: b Beginnzeile, y Bodyzeilen, e Endzeile (z.B. -cbye fuer alles inkl. Beginn- und Endzeile).@{N}Wenn die Triggertexte mit einen Praefix beginnen, kann damit der Matching Modus festgelegt werden (r# regexp, g# glob, s# simple).@{N}Mit -C kann ein Kommando angegeben werden, dessen Ausgabe eingefangen werden soll. Alternativ kann dieses auch vor /trig_grab losgeschickt werden.<II>opt>II<a Attributes@{N}b Beginning Text syn: [[rgs]#]Text@{N}e Ending Text syn: [[rgs]#]Text@{N}q Quote Mode (def. off)@{N}n Number of Body Lines@{N}N Number of Commands (whose output shall be catched) sent to the Mud (Prompt-Hooks)@{N}E,P Prompt Text Ende@{N}B Prompt Text Beginn@{N}t Time (sec)@{N}v globale Variable name (def. fulldetail)@{N}M callback Macro name (def. none, only the variable is set)@{N}d Line delimeter (def. @@@{}{N})@{N}c Catch Mode ([b][y][e] b beginning y Body e end) (def. y)@{N}y Body Trigger Text (z.B. fuer Praefix) syn: [[rgs]#]Text (def. *)@{N}p Priority@{N}F fallthru triggers or not (def 1)@{N}C Kommando fuers Mud<II>ex>II<@{N}/trig_grab -b"g#*--------" -e"r#^-+$" -M/echo  -q -ag -cbye -Cinfo@{N}faengt die Ausgabe des info Befehls in mg.mud.de ein und gibt sie gleich wieder zeilenweise per /echo aus@{N}/trig_grab -b"g#*--------" -e"r#^-+$" -M/echo -d# -ag -cy -Cinfo@{N}faengt nur den Kern der Info-Ausgabe ein (keine Start und Endtext, siehe -c) und gibt diese per /echo nach erfolgten grabbing als einen Text (Zeilen getrennt durch #, siehe -d) aus)@{N}/trig_grab -e"r#Ausgae?nge?:" -Cschau -M/scan_raum -aCred@{N}faengt die Raumbeschreibung (P_LONG) des aktuellen Raumes ein, faerbt diese rot (-aCred) und uebergibt sie an das eigene Makro /scan_raum als Parameter.<II>fileinfo>II<util.trigger.tf<II><I>
/set help___034479314=<I>strnstr>I<<II>type>II<mak<II>info>II<Sucht den String2 ab der angegebenen Position im String1.<II>syn>II<strnstr(string1,off,string2)<II>return>II<den Offset von String2 vom Beginn von String1 oder -1 bei Fehler<II>fileinfo>II<util.sfunc.tf<II><I>
/set help___075607211=<I>rename_mac>I<<II>type>II<comm<II>mak>II</createnewlist, /uaddtolist<II>info>II<Benennt ein Makro um bzw. erstellt eine Kopie davon. Damit wird sichergestellt, dass die Probleme mit Parametern nicht auftreten (Leerzeichenverlust bei Makros, auf neun begrenzte Parameteranzahl fuer Funktionen).@{N}Das soll genutzt werden, um Kommandos aus den Namespaces der Files in benutzerfreundliche Namen umzuwandeln.@{N}Wird ein dritter Parameter uebergeben, so wird die Umbennung in der Variablen %renamed_list_<Paramter 3> gespeichert. Will man nun die Makros eines Pakets vollstaendig entfernen, so lassen sich mit ?/purge_renamed auch die Kopien der Makros loeschen.<II>syn>II</rename_mac neuer_name alter_name [paketname]<II>ex>II</rename_mac wo ways_where ways<II>see>II</purge_renamed<II>fileinfo>II<util.tf<II><I>
/set help___017108108=<I>deletekeyandvalue>I<<II>type>II<comm<II>mak>II</getvalueof<II>info>II<Loscht das (erste) Paar Schluessel-Wert.<II>syn>II</deletekeyandvalue listenname schluessel<II>return>II<%error bei Misserfolg (Schluessel nicht gefunden) als Rueckgabewert und in %value<II>var>II<%value<II>see>II</delallkeysandvalues, /delikeyandvalue, /getdvalueof, /getdlistvalueof<II>fileinfo>II<lists.tf<II><I>
/set help___000462437=<I>cache>I<<II>type>II<misc<II>info>II<Der Wegecache speichert die bisher gelaufenen Wege, so dass sie kein zweites Mal berechnet werden muessen. Dabei werden alle Bedingungen (Para/Normalwelt und die Bedingungen im Weg) mit den zur Berechnung aktuellen Werten mit im Cache aufgenommen. Wenn kein Weg gefunden wird, der mit den aktuell gueltigen Werten berechnet wurde, wird er neu berechnet, ansonsten aus den Infos im Cache erzeugt.@{N}Der Cache wird beim Ausfuehren von /editway, /delway, /delnode, /addway usw. aktualisiert.<II>ex>II<hier mal ein Beispiel fuer einen Cacheeintrag:@{N}-- neander_tpv:@{N}start: neander@{N}end: tpv@{N}steps: 35@{N}way: neander:neanderu:tdrachen:tport:tpv@{N}dim: n@{N}allow: (portals==1)&(p_state=/"seher")<II>see>II<show_cache, remove_from_cache, clear_cache<II>fileinfo>II<way.tf<II><I>
/set help___018116097=<I>status_config_attr>I<<II>type>II<mak<II>info>II<Gibt einen TF-Ausdruck zurueck, der die uebergebene Variable mit dem Operator mit den Vergleichswerten vergleicht und die korrekten Statuskonfigurationsvariablen als Ergebniswerte einsetzt (abhaengig vom ersten Parameter). Die Konfigurationsvariablen werden einfach aufsteigend nummeriert.<II>syn>II</status_config_attr [c|t] varname operator ['".] vergleichswert1 vergleichswert2<II>ex>II</status_config_attr c p_lp < . 60 120@{N}/status_config_attr t p_align =~ ' gut neutral boese<II>see>II<status_config_attr<II>fileinfo>II<status.tf<II><I>
/set help___000060247=<I>getw>I<<II>type>II<mak<II>mak>II<setw, listw, unsetw, echow<II>info>II<Liefert den Wert der mit /setw gesetzten Variablen als Funktionsrueckgabewert oder in %?.<II>fileinfo>II<util.vfunc.tf<II><I>
/set help___011111097=<I>world_local>I<<II>type>II<see<II>mak>II<setw, getw, listw, unsetw, echow<II>info>II<Hilfsfunktionen zum Verwalten von Variablen, die nur lokal fuer eine Welt zustaendig sind.<II>fileinfo>II<util.vfunc.tf<II><I>
